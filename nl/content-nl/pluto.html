
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5. PlutoSDR in Python &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. USRP in Python" href="usrp.html" />
    <link rel="prev" title="4. Digitale Modulatie" href="digital_modulation.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-nl.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: Een handleiding voor SDR en DSP met Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introductie</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Het Frequentiedomein</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ-sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digitale Modulatie</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. PlutoSDR in Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#software-drivers-installatie">Software/Drivers Installatie</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ontvangen">Ontvangen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#zenden">Zenden</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tegelijk-zenden-en-ontvangen">Tegelijk zenden en ontvangen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#referentie-api">Referentie API</a></li>
<li class="toctree-l2"><a class="reference internal" href="#python-oefeningen">Python Oefeningen</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Ruis en dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Kanaalcodering</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisatie</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Compleet voorbeeld</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-nl.html">Documentation overview</a><ul>
      <li>Previous: <a href="digital_modulation.html" title="previous chapter"><span class="section-number">4. </span>Digitale Modulatie</a></li>
      <li>Next: <a href="usrp.html" title="next chapter"><span class="section-number">6. </span>USRP in Python</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="digital_modulation.html" title="Previous document"><span class="section-number">4. </span>Digitale Modulatie</a>
        </li>
        <li>
          <a href="usrp.html" title="Next document"><span class="section-number">6. </span>USRP in Python</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="plutosdr-in-python">
<span id="pluto-chapter"></span><h1><span class="section-number">5. </span>PlutoSDR in Python<a class="headerlink" href="#plutosdr-in-python" title="Permalink to this headline">¶</a></h1>
<a class="reference internal image-reference" href="../_images/pluto.png"><img alt="../_images/pluto.png" class="align-center" src="../_images/pluto.png" style="width: 323.5px; height: 250.0px;" /></a>
<p>Je zult in dit hoofdstuk leren om de Python API voor de <a class="reference external" href="https://www.analog.com/en/design-center/evaluation-hardware-and-software/evaluation-boards-kits/adalm-pluto.html" rel="noopener noreferrer" target="_blank">PlutoSDR</a> te gebruiken; een goedkope SDR van Analog Devices.
We zullen de stappen behandelen om de drivers/software voor de PlutoSDR te kunnen draaien, en behandelen hoe je kunt zenden en ontvangen met de PlutoSDR in Python.</p>
<div class="section" id="software-drivers-installatie">
<h2>Software/Drivers Installatie<a class="headerlink" href="#software-drivers-installatie" title="Permalink to this headline">¶</a></h2>
<div class="section" id="een-vm-opzetten">
<h3>Een VM opzetten<a class="headerlink" href="#een-vm-opzetten" title="Permalink to this headline">¶</a></h3>
<p>Terwijl de gegeven Python voorbeelden ook onder Windows, Mac en Linux zouden moeten werken, zijn de instructies in het specifiek geschreven voor Ubuntu 22. Als je moeite hebt om de software op jouw OS te installeren met behulp van <a class="reference external" href="https://wiki.analog.com/university/tools/pluto/users/quick_start" rel="noopener noreferrer" target="_blank">de instructies van Analog Devices</a>, raad ik aan om een Ubuntu 22 VM te installeren met de instructies hieronder. Onder Windows 11 (en vanaf deze <a class="reference external" href="https://support.microsoft.com/en-us/topic/november-15-2022-kb5020030-os-builds-19042-2311-19043-2311-19044-2311-and-19045-2311-preview-237a9048-f853-4e29-a3a2-62efdbea95e2" rel="noopener noreferrer" target="_blank">update</a> ook onder windows 10) is een alternatieve route, Windows Subsystem for Linux (WSL) met Ubuntu 22. Dit draait vrij goed en ondersteund standaard al grafische linux applicaties.</p>
<ol class="arabic simple">
<li>Installeer en open <a class="reference external" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener noreferrer" target="_blank">VirtualBox</a>.</li>
<li>Maak een nieuwe VM aan. Voor de geheugengrootte raad ik 50% van je RAM aan.</li>
<li>Creëer een dynamisch groeiende virtuele harde schijf, kies hiervoor VDI. 15 GB zou voldoende moeten zijn. Als je zeker wilt zijn kun je nog meer toekennen.</li>
<li>Download de <a class="reference external" href="https://ubuntu.com/download/desktop" rel="noopener noreferrer" target="_blank">Ubuntu 22 Desktop .iso</a></li>
<li>Start de VM. Kies het gedownloade .iso bestand als installatiemedium. Kies “install ubuntu”, met de standaard opties en klik op “continue” bij het venster wat je waarschuwt over de veranderingen. Kies een naam/wachtwoord en wacht op de VM om te installeren. Wanneer de installatie klaar is zal de VM herstarten. Schakel na de herstart de VM uit.</li>
<li>Ga naar de VM instellingen (het tandwieltje).</li>
<li>Onder system &gt; processor &gt; kies tenminste 3 processors. Als je een discrete videokaart hebt, dan kun je meer videogeheugen toekennen onder display &gt; video memory.</li>
<li>Start jouw VM.</li>
<li>Ik raad ook aan om de “VM guest additions” te installeren. Ga binnen de VM naar Devices &gt; Insert Guest Additions CD &gt; druk op “run” in het nieuwe venster en volg de instructies. Herstart de VM. Je kunt het klembord delen met de Host via Devices &gt; Shared Clipboard &gt; Bidirectional.</li>
</ol>
</div>
<div class="section" id="plutosdr-verbinden">
<h3>PlutoSDR verbinden<a class="headerlink" href="#plutosdr-verbinden" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Drivers installeren</li>
</ol>
<blockquote>
<div><ol class="upperalpha simple">
<li>Voor MacOS, onder systeem voorkeuren, zet “kernel extensions” aan. Installeer vervolgens HoRNDIS (Misschien moet je herstarten).</li>
<li>Voor Windows kun je deze driver installeren: <a class="reference external" href="https://github.com/analogdevicesinc/plutosdr-m2k-drivers-win/releases/download/v0.7/PlutoSDR-M2k-USB-Drivers.exe" rel="noopener noreferrer" target="_blank">https://github.com/analogdevicesinc/plutosdr-m2k-drivers-win/releases/download/v0.7/PlutoSDR-M2k-USB-Drivers.exe</a></li>
<li>Voor Linux zou je niets speciaals hoeven te doen.</li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>Plug je Pluto in de host machine via USB. Gebruik de middelste usb poort van de Pluto want de andere is alleen voor voeding. Na het inpluggen van de Pluto wordt er een virtuele netwerkkaart aangemaakt, het verschijnt als een USB ethernet adapter.</li>
<li>Open jouw favoriete tool op de host machine (niet de VM) en ping 192.168.2.1. Zorg er eerst voor dat dit werkt voordat je verder gaat.</li>
<li>Open een nieuwe terminal binnen de VM</li>
<li>Ping 192.168.2.1. Als dat niet werk, los dat eerst op. Wanneer je, tijdens het pingen, de Pluto uit de computer haalt zou de ping geen antwoord meer moeten geven. Als het gewoon door blijft gaan dan zit er waarschijnlijk een ander apparaat op hetzelfde IP-adres. Je zult het adres van de Pluto (of het andere netwerkapparaat) moeten aanpassen.</li>
<li>Schrijf het juiste IP-adres van de Pluto ergens op, want dit hebben we nodig om later verbinding te maken.</li>
</ol>
</div>
<div class="section" id="plutosdr-driver-installeren">
<h3>PlutoSDR Driver installeren<a class="headerlink" href="#plutosdr-driver-installeren" title="Permalink to this headline">¶</a></h3>
<p>De onderstaande terminal commando’s (op de VM) zou de volgende zaken moeten installeren:</p>
<ol class="arabic simple">
<li><strong>libiio</strong>, Analog Device’s “cross-platform” bibliotheek</li>
<li><strong>libad9361-iio</strong>, AD9361 is de specifieke RF-chip binnen de PlutoSDR</li>
<li><strong>pyadi-iio</strong>, de Pluto’s Python API, <em>ons einddoel</em>, maar het is afhankelijk van de eerste twee</li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo apt-get install build-essential git libxml2-dev bison flex libcdk5-dev cmake python3-pip libusb-1.0-0-dev libavahi-client-dev libavahi-common-dev libaio-dev
<span class="nb">cd</span> ~
git clone --branch v0.23 https://github.com/analogdevicesinc/libiio.git
<span class="nb">cd</span> libiio
mkdir build
<span class="nb">cd</span> build
cmake -DPYTHON_BINDINGS<span class="o">=</span>ON ..
make -j<span class="k">$(</span>nproc<span class="k">)</span>
sudo make install
sudo ldconfig

<span class="nb">cd</span> ~
git clone https://github.com/analogdevicesinc/libad9361-iio.git
<span class="nb">cd</span> libad9361-iio
mkdir build
<span class="nb">cd</span> build
cmake ..
make -j<span class="k">$(</span>nproc<span class="k">)</span>
sudo make install

<span class="nb">cd</span> ~
git clone --branch v0.0.14 https://github.com/analogdevicesinc/pyadi-iio.git
<span class="nb">cd</span> pyadi-iio
pip3 install --upgrade pip
pip3 install -r requirements.txt
sudo python3 setup.py install
</pre></div>
</div>
</div>
<div class="section" id="plutosdr-drivers-testen">
<h3>PlutoSDR Drivers testen<a class="headerlink" href="#plutosdr-drivers-testen" title="Permalink to this headline">¶</a></h3>
<p>Open een nieuwe terminal (in jouw VM) en type de volgende commando’s:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3
import adi
<span class="nv">sdr</span> <span class="o">=</span> adi.Pluto<span class="o">(</span><span class="s1">&#39;ip:192.168.2.1&#39;</span><span class="o">)</span> <span class="c1"># of wat jouw Pluto&#39;s IP ook is</span>
sdr.sample_rate <span class="o">=</span> int<span class="o">(</span><span class="m">2</span>.5e6<span class="o">)</span>
sdr.rx<span class="o">()</span>
</pre></div>
</div>
<p>Als je tot nu toe geen problemen ervaart dan kun je verder met de volgende stappen.</p>
</div>
<div class="section" id="pluto-s-ip-adres-aanpassen">
<h3>Pluto’s IP Adres aanpassen<a class="headerlink" href="#pluto-s-ip-adres-aanpassen" title="Permalink to this headline">¶</a></h3>
<p>Mocht je om een of andere reden het standaard IP van 192.168.2.1 niet willen, dan kun je het IP met deze stappen aanpassen:</p>
<ol class="arabic simple">
<li>Bewerk het config.txt bestand op de PlutoSDR schijf (dus het USB-drive achtige ding wat tevoorschijn komt wanneer je de Pluto inplugt). Voer het nieuwe IP-adres in.</li>
<li>Werp de schijf uit maar laat de Pluto in de computer zitten! In Ubuntu 22 is er een naast de PlutoSDR device een uitwerp symbool, binnen de verkenner.</li>
<li>Wacht een paar seconden na het uitwerpen en plug daarna de Pluto uit en in de computer. Ga terug naar config.txt en verifieer dat de wijziging is opgeslagen.</li>
</ol>
<p>Op dezelfde manier zou je de firmware van de Pluto kunnen updaten. Zie voor meer info <a class="reference external" href="https://wiki.analog.com/university/tools/pluto/users/firmware" rel="noopener noreferrer" target="_blank">https://wiki.analog.com/university/tools/pluto/users/firmware</a>.</p>
</div>
<div class="section" id="hack-de-plutosdr-voor-een-groter-rf-bereik">
<h3>“Hack” de PlutoSDR voor een groter RF bereik<a class="headerlink" href="#hack-de-plutosdr-voor-een-groter-rf-bereik" title="Permalink to this headline">¶</a></h3>
<p>De PlutoSDR komt standaard met een beperkt frequentiebereik en beperkte sample-frequentie, maar de onderliggende chip kan veel hogere frequenties aan. Volg deze stappen om het volle frequentiebereik aan te zeten. Dit proces wordt door Analog Devices zelf uitgelegd dus heeft minimale risico’s. De restricties zijn door Analog Devices aangezet omdat de specifieke chips niet voldeden aan de strenge performance-eisen op deze hogere frequenties. Maar als SDR studenten maken we ons niet zo druk over die performance-eisen.</p>
<p>Tijd om te hacken! Open een terminal (host of VM):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ssh root@192.168.2.1
</pre></div>
</div>
<p>Het wachtwoord is analog.</p>
<p>Je zou een welkomst ‘scherm’ moeten zien. Je hebt nu geSSHd naar de linux-omgeving van de Pluto zelf!
Type de volgende commando’s in:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fw_setenv attr_name compatible
fw_setenv attr_val ad9364
fw_setenv compatible ad9364
reboot
</pre></div>
</div>
<p>Nu moet het mogelijk zijn om af te stemmen op frequenties tussen de 70 MHz en 6 GHz, en een sample rate te gebruiken van 56 MHz! Joepie!</p>
</div>
</div>
<div class="section" id="ontvangen">
<h2>Ontvangen<a class="headerlink" href="#ontvangen" title="Permalink to this headline">¶</a></h2>
<p>Via de PlutoSDR’s Python API is het simpel om samples te ontvangen.
Voor elke SDR-applicatie wil je weten wat de middenfrequentie, sample-frequentie en versterking is, en of je eventueel automatic gain control (AGC) wilt gebruiken.
Er zijn andere details, maar deze drie parameters zijn essentieel voor de SDR om samples te kunnen ontvangen.
Sommige SDR’s hebben een commando om te beginnen met het samplen, en anderen zoals de Pluto beginnen zodra je het initialiseert.
Op het moment dat de interne buffers van de Pluto vol zitten, dan zal het de oudste samples gaan verwijderen.
Alle SDR API’s hebben een “ontvang samples” functie dat een stapel samples teruggeeft, en voor de Pluto is dit rx(),
De hoeveelheid samples dat het teruggeeft is gedefinieerd door de buffergrootte wat van tevoren is ingesteld.</p>
<p>De onderstaande code gaat ervan uit dat je Pluto’s Python API hebt geïnstalleerd.
Deze code initialiseert de Pluto, stelt de sample-frequentie in op 1 MHz, stelt de middenfrequentie in op 100 MHz en stelt de versterking in op 70 dB met AGC uitgeschakeld.
Het maakt meestal niets uit in welke volgorde je deze dingen doet.
In de onderstaande code vragen we de Pluto om 10000 samples per rx() functieaanroep.
We drukken de eerste 10 samples af.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">adi</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># Hz</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">100e6</span> <span class="c1"># Hz</span>
<span class="n">num_samps</span> <span class="o">=</span> <span class="mi">10000</span> <span class="c1"># aantal samples per rx() aanroep</span>

<span class="n">sdr</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">Pluto</span><span class="p">()</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">gain_control_mode_chan0</span> <span class="o">=</span> <span class="s1">&#39;manual&#39;</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_hardwaregain_chan0</span> <span class="o">=</span> <span class="mf">70.0</span> <span class="c1"># dB</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="c1"># kantelfrequentie = sample frequentie</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">num_samps</span>

<span class="n">samples</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">rx</span><span class="p">()</span> <span class="c1"># ontvang de samples van de Pluto</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
<p>Voor nu doen we niets interessants met deze samples, maar de rest van dit boek staat vol met Python code dat werkt met IQ-samples zoals we zojuist hebben ontvangen.</p>
<div class="section" id="ontvangstversterking">
<h3>Ontvangstversterking<a class="headerlink" href="#ontvangstversterking" title="Permalink to this headline">¶</a></h3>
<p>De Pluto kan worden ingesteld op een vaste versterking of een automatische. Een automatische versterkingscontrole of automatic gain control (AGC) zal automatisch de versterking van de ontvanger aanpassen om een sterk signaalniveau te behouden (-12dBFS om exact te zijn).
AGC moet je niet verwarren met een analoog-naar-digitaal converter (ADC) dat het signaal digitaliseert.
Technisch gezien is de AGC een gesloten-lus feedbackschakeling dat de versterking beheert op basis van het ontvangen signaal met als doel om een constant vermogensniveau te behouden desondanks variërende ingangsvermogens.
Typisch zorgt de AGC ervoor dat het signaal de ADC niet overstuurt maar wel zo goed mogelijk het volledige bereik van de ADC gebruikt.</p>
<p>Het RFIC, binnen de PlutoSDR, heeft een AGC-module met een paar verschillende instellingen.
(Een RFIC is een transceiver chip; het stuurt en ontvangt radiogolven.)
Als eerste merken we op dat de Pluto ontvangstversterking een bereik heeft van 0 tot 74.5 dB.
In de “manual” of handmatige modus is de AGC uitgeschakeld, en moet je zelf instellen welke versterking de Pluto moet gebruiken. Bijv.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sdr</span><span class="o">.</span><span class="n">gain_control_mode_chan0</span> <span class="o">=</span> <span class="s2">&quot;manual&quot;</span> <span class="c1"># zet AGC uit</span>
<span class="n">gain</span> <span class="o">=</span> <span class="mf">50.0</span> <span class="c1"># toegestane bereik is 0 tot 74.5 dB</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_hardwaregain_chan0</span> <span class="o">=</span> <span class="n">gain</span> <span class="c1"># stel ontvangstversterking in</span>
</pre></div>
</div>
<p>Wanneer je de AGC wilt gebruiken kun je kiezen tussen twee modi:</p>
<ol class="arabic simple">
<li><code class="code docutils literal notranslate"><span class="pre">sdr.gain_control_mode_chan0</span> <span class="pre">=</span> <span class="pre">&quot;slow_attack&quot;</span></code></li>
<li><code class="code docutils literal notranslate"><span class="pre">sdr.gain_control_mode_chan0</span> <span class="pre">=</span> <span class="pre">&quot;fast_attack&quot;</span></code></li>
</ol>
<p>En wanneer de AGC is aangezet hoef je geen waarde te geven voor <code class="code docutils literal notranslate"><span class="pre">rx_hardwaregain_chan0</span></code>.
Deze waarde wordt genegeerd omdat de Pluto dan zelf de versterking voor het signaal regelt.
De Pluto heeft twee modi voor de AGC: fast attack (snel reageren) en slow attack (langzaam reageren).
De termen spreken voor zichzelf.
Fast attack modus reageert sneller op de signalen.
In andere woorden, de versterkingsfactor zal sneller veranderen wanneer het ingangssignaal verandert.
Het ingangsvermogen aanpassen is bijv. belangrijk voor tijd-divisie duplex (TDD) systemen. Deze gebruiken dezelfde frequentie voor zenden en ontvangen.
Als je voor deze situatie de AGC op fast attack zet dan wordt de demping van het signaal gelimiteerd.
Met beide modi, wanneer er geen signaal maar alleen ruis aanwezig is, zal de AGC de versterking maximaal maken; wanneer een signaal tevoorschijn komt, zal het de ontvanger (ADC) kort satureren tot de AGC kan reageren en de versterking doet zakken. Je kunt de huidige versterkingsfactor in real-time bekijken met:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sdr</span><span class="o">.</span><span class="n">_get_iio_attr</span><span class="p">(</span><span class="s1">&#39;voltage0&#39;</span><span class="p">,</span><span class="s1">&#39;hardwaregain&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Voor meer informatie over de AGC binnen de Pluto refereren we naar de <a class="reference external" href="https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9361" rel="noopener noreferrer" target="_blank">RX Gain Control sectie van deze pagina:</a>.</p>
</div>
</div>
<div class="section" id="zenden">
<h2>Zenden<a class="headerlink" href="#zenden" title="Permalink to this headline">¶</a></h2>
<p>Zorg ervoor, voordat je een signaal gaat versturen met jouw Pluto, dat je een SMA-kabel tussen de TX en ontvanger stopt.
Het is belangrijk dat je als beginner altijd eerst over een kabel zendt om zeker te zijn dat de SDR doet wat je wilt. Hou in dit geval het zendvermogen extreem laag om te voorkomen dat je de ontvanger sloopt. Een kabel heeft immers niet zoveel demping als een draadloos kanaal.
Mocht je een attenuator (demper) hebben (bijv. 30 dB), dan is dit een goed moment om het te gebruiken.
Als je niet een andere SDR of spectrum analyzer als ontvanger tot je beschikking hebt, dan zou je in theorie de RX-poort van dezelfde Pluto kunnen gebruiken, maar dat kan ingewikkeld worden.
Ik raad aan om een RTL-SDR van 20€ als ontvanger te gebruiken.</p>
<p>Zenden werkt bijna hetzelfde als ontvangen. In plaats dat we de SDR vertellen om samples te ontvangen, zullen we een bepaalde hoeveelheid samples geven om uit te zenden.
We stellen i.p.v. de <code class="code docutils literal notranslate"><span class="pre">rx_lo</span></code> de <code class="code docutils literal notranslate"><span class="pre">tx_lo</span></code> in, om aan te geven welke zendfrequentie we willen gebruiken.
De sample-rate is hetzelfde voor de RX en TX, dus die instelling blijft gelijk.
Een volledig voorbeeld waarin wordt gezonden is beneden te zien. Hier genereren we een sinusoïde van +100 kHz, en zenden het complexe signaal op een draaggolf van 915 MHz. De ontvanger ziet dan een draaggolf op 915.1 MHz.
Er is geen praktische reden om dit zo te doen, we hadden een array van 1’en kunnen versturen op een zendfrequentie van 915.1e6 Hz. We wilden echter complexe samples genereren als voorbeeld.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">adi</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># Hz</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">915e6</span> <span class="c1"># Hz</span>

<span class="n">sdr</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">Pluto</span><span class="p">(</span><span class="s2">&quot;ip:192.168.2.1&quot;</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="c1"># filter kantelfrequentie, stel in gelijk aan sample rate</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_hardwaregain_chan0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">50</span> <span class="c1"># tx demping, bereik is -90 tot 0 dB</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">10000</span> <span class="c1"># aantal samples om te versturen</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span>
<span class="n">samples</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">2.0</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">100e3</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># simuleer een sinusoide van 100 kHz, dan ziet de ontvanger het op 915.1 MHz</span>
<span class="n">samples</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">14</span> <span class="c1"># De PlutoSDR verwacht samples met waarden tussen -2^14 en +2^14, niet -1 en +1</span>

<span class="c1"># Stuur de samples 100 keer, dus 1 seconde totaal, als USB het kan bijhouden</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">sdr</span><span class="o">.</span><span class="n">tx</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="c1"># stuurt de N samples een keer</span>
</pre></div>
</div>
<p>Nog wat opmerkingen over deze code.
Eerst wil je de IQ samples tussen -1 en 1 simuleren, maar voor het versturen moeten we het vermenigvuldigen met 2^14 vanwege hoe Analog Devices de <code class="code docutils literal notranslate"><span class="pre">tx()</span></code> functie heeft geïmplementeerd.
Als je niet zeker weet wat de min/max waardes van je signaal zijn, kun je ze afdrukken met <code class="code docutils literal notranslate"><span class="pre">print(np.min(samples),</span> <span class="pre">np.max(samples))</span></code> of je schrijft een statement om zeker te zijn dat de samples nooit boven 1 of onder -1 komen (dit komt dan voor de 2^14 vermenigvuldiging).
De demping op het zendvermogen heeft een bereik van -90 tot 0 dB, waar 0 dB dus het hoogste zendvermogen oplevert.
We willen altijd met een laag zendvermogen beginnen en daarna, wanneer nodig, het laten toenemen.
De standaardwaarde van -50 dB is gelukkig al aan de lage (en juiste) kant.
Zet de waarde niet zomaar op 0 dB wanneer je niets ziet bij de ontvanger, er kunnen andere redenen zijn waarom dit zo is, en je wilt niet je ontvanger slopen.</p>
<div class="section" id="oneindig-samples-versturen">
<h3>Oneindig samples versturen<a class="headerlink" href="#oneindig-samples-versturen" title="Permalink to this headline">¶</a></h3>
<p>Als je voortdurend dezelfde set samples wilt versturen kun je, i.p.v. een for/while loop, de Pluto instrueren om dit te doen met een regel code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sdr</span><span class="o">.</span><span class="n">tx_cyclic_buffer</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Zet cyclic buffers aan</span>
</pre></div>
</div>
<p>Hierna kun je op dezelfde manier samples versturen: <code class="code docutils literal notranslate"><span class="pre">sdr.tx(samples)</span></code> waarna de Pluto het oneindig blijft versturen, totdat het SDR-object wordt vernietigd.
Om een nieuwe set aan samples te versturen moet je dan eerst <code class="code docutils literal notranslate"><span class="pre">sdr.tx_destroy_buffer()</span></code> aanroepen, en daarna <code class="code docutils literal notranslate"><span class="pre">sdr.tx(samples)</span></code>.</p>
</div>
<div class="section" id="legaal-door-de-lucht-zenden">
<h3>Legaal door de lucht zenden<a class="headerlink" href="#legaal-door-de-lucht-zenden" title="Permalink to this headline">¶</a></h3>
<p>Onderstaande vertaling gaat over de regels in de VS. Voor Nederland is er de <a class="reference external" href="https://wetten.overheid.nl/BWBR0009950/2022-05-01/" rel="noopener noreferrer" target="_blank">telecommunicatiewet</a> met naar mijn weten vrijwel dezelfde conclusie als de rest van dit stuk. Er is ook de amateur zendband rond 433-435 MHz waar je met licentie mag zenden, <a class="reference external" href="https://wetten.overheid.nl/BWBR0036375/2021-06-18#Bijlagen" rel="noopener noreferrer" target="_blank">zie</a>.</p>
<p>Een veelvoorkomende vraag van studenten is op welke frequenties ze mogen zenden met een antenne (in de VS). Het korte antwoord is niet, zover ik weet. Meestal wordt er verwezen naar de wetten die zendvermogen beperken, <a class="reference external" href="https://www.ecfr.gov/cgi-bin/text-idx?SID=7ce538354be86061c7705af3a5e17f26&amp;mc=true&amp;node=pt47.1.15&amp;rgn=div5" rel="noopener noreferrer" target="_blank">de FCC’s “Title 47, Part 15” (47 CFR 15) regulations</a>.</p>
<p>Maar die regels zijn voor producenten die apparaten bouwen en verkopen die opereren in de ISM banden, de regels beschrijven hoe ze getest mogen worden. Een “Part 15” apparaat is er een waar je geen licentie voor nodig hebt om het te gebruiken, maar het apparaat zelf moet wel gecertificeerd zijn om te laten zien dat het aan de FCC-regels voldoet.</p>
<p>De wetten in “Part 15” specificeren wel een maximaal zend- en ontvangstvermogen voor de verschillende gebieden van het spectrum, maar niets slaat op een persoon die zendt met een SDR of zelfgebouwde zenders. De enige wet die ik kon vinden over niet-commerciële zenders gaat over lage vermogenszenders voor AM en FM in de AM/FM banden. Er is ook een sectie over “zelfgebouwde” apparaten maar er wordt specifiek gezegd dat dit niet geldt bij het gebruik van kits. Samenvattend, de FCC-wetten zijn niet zo simpel als “je mag op deze frequenties zenden maar onder dit vermogen”, maar is meer een grote verzameling wetten voor het testen van producten.</p>
<p>Een andere manier om ernaar te kijken is om te zeggen “Nou, dit voldoet niet aan Part 15 maar laten we toch die regels volgen”. Voor de 915 MHz ISM band is de regels dat “De veldsterkte van een uitstraling binnen de gespecificeerde frequentieband zal niet boven de 500 microvolt/meter op 30 meter afstand komen. Gemeten met officiële apparatuur.”. Dus, zoals je kunt zien is het niet zo simpel als een maximaal zendvermogen in Watt.</p>
<p>Als je een amateur radio (ham) licentie hebt, dan mag je van de FCC bepaalde banden gebruiken voor amateur radio. Er zijn nog steeds regels om te volgen, en maximale zendvermogens, maar die zijn tenminste uitgedrukt in Watt van effectief uitgestraald vermogen. <a class="reference external" href="http://www.arrl.org/files/file/Regulatory/Band%20Chart/Band%20Chart%20-%2011X17%20Color.pdf" rel="noopener noreferrer" target="_blank">Dit info-graphic</a> laat zien welke banden beschikbaar zijn afhankelijk van je licentietype. Iedereen die geïnteresseerd is in zenden met SDR’s raadt ik aan om hun HAM licentie te halen.</p>
<p>Als iemand meer details heeft over wat er wel en niet is toegestaan, email me alsjeblieft.</p>
</div>
</div>
<div class="section" id="tegelijk-zenden-en-ontvangen">
<h2>Tegelijk zenden en ontvangen<a class="headerlink" href="#tegelijk-zenden-en-ontvangen" title="Permalink to this headline">¶</a></h2>
<p>De tx_cyclic_buffer truc staat je toe om tegelijkertijd te zenden en te ontvangen door eerst de zender te starten, en daarna te gaan ontvangen. Het volgende stuk code geeft een werkend voorbeeld waarin een QPSK signaal wordt verstuurd in de 915 MHz band, wordt ontvangen, en de PSD ervan wordt weergeven.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">adi</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># Hz</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">915e6</span> <span class="c1"># Hz</span>
<span class="n">num_samps</span> <span class="o">=</span> <span class="mi">100000</span> <span class="c1"># aantal samples voor een aanroep van rx()</span>

<span class="n">sdr</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">Pluto</span><span class="p">(</span><span class="s2">&quot;ip:192.168.2.1&quot;</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>

<span class="c1"># Config Tx</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="c1"># filter kantelfrequentie, gelijk aan samplerate</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_hardwaregain_chan0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">50</span> <span class="c1"># demping op zendvermogen</span>

<span class="c1"># Config Rx</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">num_samps</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">gain_control_mode_chan0</span> <span class="o">=</span> <span class="s1">&#39;manual&#39;</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_hardwaregain_chan0</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># dB, maakt dit groter voor sterker ontvangst, kijk uit dat je de ADC niet overstuurt</span>

<span class="c1"># Maak de symboolreeks om te versturen (QPSK, 16 samples per symbool)</span>
<span class="n">num_symbols</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">x_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num_symbols</span><span class="p">)</span> <span class="c1"># 0 tot 3</span>
<span class="n">x_degrees</span> <span class="o">=</span> <span class="n">x_int</span><span class="o">*</span><span class="mi">360</span><span class="o">/</span><span class="mf">4.0</span> <span class="o">+</span> <span class="mi">45</span> <span class="c1"># 45, 135, 225, 315 graden</span>
<span class="n">x_radians</span> <span class="o">=</span> <span class="n">x_degrees</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span> <span class="c1"># sin() en cos() werken in radialen</span>
<span class="n">x_symbols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x_radians</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x_radians</span><span class="p">)</span> <span class="c1"># dit geeft de complexe QPSK symbolen</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x_symbols</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="c1"># 16 samples per symbool (blokgolf)</span>
<span class="n">samples</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">14</span> <span class="c1"># versterken voor de Pluto</span>

<span class="c1"># Zender starten</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_cyclic_buffer</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># cyclic buffers aanzetten</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="c1"># start met zenden</span>

<span class="c1"># Voor de zekerheid buffer leegmaken</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">rx</span><span class="p">()</span>

<span class="c1"># samples ontvangen</span>
<span class="n">rx_samples</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">rx</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rx_samples</span><span class="p">)</span>

<span class="c1"># Stop zender</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_destroy_buffer</span><span class="p">()</span>

<span class="c1"># Bereken de power spectral density (frequentiedomein van ons signaal)</span>
<span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">rx_samples</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span>
<span class="n">psd_dB</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">/-</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">psd</span><span class="p">))</span>

<span class="c1"># Plot tijddomein</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">rx_samples</span><span class="p">[::</span><span class="mi">100</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">rx_samples</span><span class="p">[::</span><span class="mi">100</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Tijd&quot;</span><span class="p">)</span>

<span class="c1"># Plot freqdomein</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">psd_dB</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequentie [MHz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;PSD&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Met een goede antenne of kabel zou je zoiets moeten zien:</p>
<img alt="../_images/pluto_tx_rx.svg" class="align-center" src="../_images/pluto_tx_rx.svg" /><p>Een goede oefening is om <code class="code docutils literal notranslate"><span class="pre">sdr.tx_hardwaregain_chan0</span></code> en <code class="code docutils literal notranslate"><span class="pre">sdr.rx_hardwaregain_chan0</span></code> langzaam te veranderen om zeker van te zijn dat je ontvangen signaal sterker of zwakker wordt zoals verwacht.</p>
</div>
<div class="section" id="referentie-api">
<h2>Referentie API<a class="headerlink" href="#referentie-api" title="Permalink to this headline">¶</a></h2>
<p>Voor de volledige lijst van functies en instellingen die je kunt aanroepen kun je de <a class="reference external" href="https://github.com/analogdevicesinc/pyadi-iio/blob/master/adi/ad936x.py" rel="noopener noreferrer" target="_blank">pyadi-iio Pluto Python code (AD936X)</a> raadplegen.</p>
</div>
<div class="section" id="python-oefeningen">
<h2>Python Oefeningen<a class="headerlink" href="#python-oefeningen" title="Permalink to this headline">¶</a></h2>
<p>In plaats van de volledige code te geven, heb ik meerdere opdrachten gemaakt waar 99% van de code al is gegeven en de overige code simpel is om te maken. De opdrachten zijn niet bedoeld om moeilijk te zijn. Ze missen net genoeg code om je na te laten denken.</p>
<div class="section" id="opdracht-1-bepaal-de-doorvoersnelheid-van-je-usb-verbinding">
<h3>Opdracht 1: Bepaal de doorvoersnelheid van je USB-verbinding<a class="headerlink" href="#opdracht-1-bepaal-de-doorvoersnelheid-van-je-usb-verbinding" title="Permalink to this headline">¶</a></h3>
<p>We gaan samples proberen te ontvangen en tegelijkertijd gaan we kijken hoeveel samples per seconde we door de USB 2.0 connectie kunnen duwen.</p>
<p><strong>Het is jouw taak om een Python script te schrijven dat bepaalt hoe snel de samples in Python binnenkomen. Dus tel het aantal samples wat binnenkomt en hou de tijd bij om de sample-rate te bepalen. Probeer daarna andere sample_rate’s en buffer_size’s te gebruiken om te zien wat de hoogste haalbare snelheid is.</strong></p>
<p>Vergeet niet wanneer je minder samples per seconde binnenkrijgt dan de ingestelde sample-rate, dat je samples aan het verliezen bent, wat hoogstwaarschijnlijk gebeurt op hoge snelheden. De Pluto gebruikt immers maar USB 2.0.</p>
<p>Het volgende stuk code is een mooi beginpunt maar bevat ook de benodigde instructies om deze opdracht af te ronden.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">adi</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">10e6</span> <span class="c1"># Hz</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">100e6</span> <span class="c1"># Hz</span>

<span class="n">sdr</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">Pluto</span><span class="p">(</span><span class="s2">&quot;ip:192.168.2.1&quot;</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="c1"># kantelfrequentie = sample-frequentie</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="mi">1024</span> <span class="c1"># bufferlengte Pluto</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">rx</span><span class="p">()</span> <span class="c1"># start met samples ontvangen</span>
</pre></div>
</div>
<p>Om hiernaast bij te houden hoeveel tijd iets in beslag neemt kun je het volgende stukje code gebruiken:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="c1"># doe iets</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;seconds elapsed:&#39;</span><span class="p">,</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
</div>
<p>Nog wat hints om je op weg te helpen.</p>
<p>Hint 1: Je zult de regel “samples = sdr.rx()” in een loop meerdere keer moeten aanroepen (bijv., 100 keer). Telkens moet je tellen hoeveel samples je terugkrijgt en hoeveel tijd is verlopen.</p>
<p>Hint 2: Ook al probeer je het aantal samples per seconde te berekenen, dat betekent niet dat je ook precies 1 seconde aan samples moet ontvangen. Je kunt ook het aantal ontvangen samples delen door de verlopen tijd.</p>
<p>Hint 3: Begin met een sample_rate = 10e6 zoals de code laat zien, want dit is veel meer dan de USB 2.0 verbinding aan kan. Je kunt zien hoeveel data erdoorheen komt. Daarna kun je de rx buffergrootte aanpassen om te zien wat er gebeurt. Op het moment dat je een werkend script hebt en je hebt gespeeld met de rx_buffer_size dan kun je proberen de sample_rate aan te passen. Bepaal hoever je de sample-rate moet verlagen om 100% van de samples te kunnen ontvangen in Python.</p>
<p>Hint 4: In de loop waarin je sdr.rx() uitvoert wil je zo min mogelijk vertraging toevoegen. Ga geen intensieve functies aanroepen zoals print() binnen de loop.</p>
<p>Als resultaat krijg je een goed idee van de maximale doorvoersnelheid van USB 2.0. Je kunt online kijken om je bevindingen te verifiëren.</p>
<p>Als bonus: probeer eens de center_freq en rx_rf_bandwidth aan te passen om te zien hoe dat de snelheid beïnvloedt.</p>
</div>
<div class="section" id="opdracht-2-maak-een-spectrogram-waterval">
<h3>Opdracht 2: Maak een Spectrogram/Waterval<a class="headerlink" href="#opdracht-2-maak-een-spectrogram-waterval" title="Permalink to this headline">¶</a></h3>
<p>Voor deze opdracht zul je een spectrogram of watervaldiagram moeten maken zoals besproken in het <a class="reference internal" href="frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a> hoofdstuk.
Een spectrogram is niets meer dan een hoop FFT’s die je, op elkaar gestapeld weergeeft. In andere woorden, het is een figuur waar 1 as de frequentie weergeeft en de andere as tijd.</p>
<p>In het <a class="reference internal" href="frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a> hoofdstuk hebben we de Python code gegeven om een FFT uit te voeren. Voor deze opdracht kun je de codevoorbeelden uit dat hoofdstuk en uit de vorige opdracht gebruiken.</p>
<p>Hints:</p>
<ol class="arabic simple">
<li>Maak sdr.rx_buffer_size gelijk aan de lengte van de FFT zodat je altijd 1 FFT uitvoert voor elke aanroep naar <cite>sdr.rx()</cite>.</li>
<li>Bouw een 2D array om alle FFT-resultaten in te bewaren. Dus 1 FFT per rij. Je kunt zo’n array met vullen met nullen: <cite>np.zeros((num_rows, fft_size))</cite>.  Je kunt rij ‘i’ van de array benaderen met: <cite>waterfall_2darray[i,:]</cite>.</li>
<li><cite>plt.imshow()</cite> is een handige manier om een 2D array te weergeven in een figuur. De kleur wordt automatisch bepaalt aan de hand van de waarden.</li>
</ol>
<p>Als een extra uitdaging kun je de spectrogram live laten updaten.</p>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="digital_modulation.html" title="Previous document"><span class="section-number">4. </span>Digitale Modulatie</a>
        </li>
        <li>
          <a href="usrp.html" title="Next document"><span class="section-number">6. </span>USRP in Python</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>