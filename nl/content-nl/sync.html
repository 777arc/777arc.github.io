
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>14. Synchronisatie &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="15. Compleet voorbeeld" href="rds.html" />
    <link rel="prev" title="13. Pulse Shaping" href="pulse_shaping.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/nl/index-nl.html">Dutch</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-nl.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: Een handleiding voor SDR en DSP met Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introductie</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Het Frequentiedomein</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ-sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digitale Modulatie</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Ruis en dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Kanaalcodering</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">14. Synchronisatie</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introductie">Introductie</a></li>
<li class="toctree-l2"><a class="reference internal" href="#draadloos-kanaal-simuleren">Draadloos kanaal simuleren</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tijdsynchronisatie">Tijdsynchronisatie</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tijdsynchronisatie-met-interpolatie">Tijdsynchronisatie met interpolatie</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grove-frequentiesynchronisatie">Grove Frequentiesynchronisatie</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fine-frequency-synchronization">Fine Frequency Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#frame-synchronisatie">Frame-synchronisatie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Compleet voorbeeld</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-nl.html">Documentation overview</a><ul>
      <li>Previous: <a href="pulse_shaping.html" title="previous chapter"><span class="section-number">13. </span>Pulse Shaping</a></li>
      <li>Next: <a href="rds.html" title="next chapter"><span class="section-number">15. </span>Compleet voorbeeld</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pulse_shaping.html" title="Previous document"><span class="section-number">13. </span>Pulse Shaping</a>
        </li>
        <li>
          <a href="rds.html" title="Next document"><span class="section-number">15. </span>Compleet voorbeeld</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="synchronisatie">
<span id="sync-chapter"></span><h1><span class="section-number">14. </span>Synchronisatie<a class="headerlink" href="#synchronisatie" title="Permalink to this headline">¶</a></h1>
<p>Dit hoofdstuk gaat over het synchroniseren van draadloze signalen in tijd en frequentie. Hiermee corrigeren we frequentieafwijking en stellen het moment van samplen af op symbool niveau. We zullen de klokhersteltechniek van Mueller en Muller, en de Costas Loop, gebruiken in Python.</p>
<div class="section" id="introductie">
<h2>Introductie<a class="headerlink" href="#introductie" title="Permalink to this headline">¶</a></h2>
<p>We hebben besproken hoe je digitale signalen draadloos kunt versturen met een digitaal modulatieschema zoals QPSK en het toepassen van vormgevende filters om de bandbreedte te beperken. We kunnen kanaalcodering toepassen bij slechte signaalruisverhoudingen.
Het zal sowieso helpen om zoveel mogelijk te filteren voordat we het signaal verwerken.
In dit hoofdstuk zullen we onderzoeken hoe synchronisatie wordt uitgevoerd aan de ontvangende kant.
Synchronisatie is een reeks bewerkingen die plaatsvindt <em>vóór</em> demodulatie en kanaaldecodering.
Hieronder zie je de totale zender-kanaal-ontvanger keten waarbij de blokken die we in dit hoofdstuk zullen behandelen, geel zijn gemaakt. (Dit diagram is niet allesomvattend - de meeste systemen bevatten ook egalisatie en multiplexing).</p>
<div class="figure" style="text-align: center"><p><img  src="../_images/tikz-7605a8623ca3102f71c5bbd5439f9a6e79dfa891.svg" alt="Figure made with TikZ" /></p>
</div></div>
<div class="section" id="draadloos-kanaal-simuleren">
<h2>Draadloos kanaal simuleren<a class="headerlink" href="#draadloos-kanaal-simuleren" title="Permalink to this headline">¶</a></h2>
<p>We zullen een realistischer kanaalmodel moeten gaan gebruiken voordat we het over synchronisatie gaan hebben. Zolang er geen willekeurige vertraging plaatsvindt is er namelijk geen synchronisatie nodig, of tenminste is het erg simpel om te synchroniseren (met de sampleklok). Je zou in dat geval alleen maar rekening hoeven houden met de vertraging die jouw filters introduceren. Naast een tijdsvertraging zullen we ook een frequentieafwijking simuleren; oscillators zijn immers niet perfect, er zal altijd een verschil zijn tussen de middenfrequentie van de zender en ontvanger.</p>
<p>We zullen eerst wat Python code gaan bekijken waarmee we een vertraging en frequentieafwijking kunnen simuleren. De code zal verder gaan waar het <a class="reference internal" href="pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a> is geeindigt; alle code uit dit hoofdstuk kun je erachter toevoegen. Voor het gemak is de code hier ook te vinden:</p>
<details>
<summary>Python Code van het vorige hoofdstuk</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># symbolen genereren</span>
<span class="n">num_symbols</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">sps</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_symbols</span><span class="p">)</span> <span class="c1"># De te verzenden bits</span>
<span class="n">pulse_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
<span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">:</span>
    <span class="n">pulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sps</span><span class="p">)</span>
    <span class="n">pulse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bit</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># alleen eerste waarde gelijk aan bitwaarde</span>
    <span class="n">pulse_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pulse_train</span><span class="p">,</span> <span class="n">pulse</span><span class="p">))</span> <span class="c1"># de 8 samples toevoegen aan x</span>

<span class="c1"># het RC filter bouwen</span>
<span class="n">num_taps</span> <span class="o">=</span> <span class="mi">101</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.35</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">sps</span> <span class="c1"># sample rate is 1 Hz, periodetijd is 1, *symbool*periodetijd is 8</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">51</span><span class="p">,</span> <span class="mi">52</span><span class="p">)</span> <span class="c1"># neemt laatste nummer niet mee</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># signaal x filteren.</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">pulse_train</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
</details><p>De code die te maken heeft met het weergeven van de figuren hebben we weg gelaten, we gaan ervan uit dat je nu hebt geleerd hoe je dat moet doen.
Om de figuren extra mooi te maken zoals in dit boek heb je veel extra code nodig, wat niet het leerdoel is.</p>
<div class="section" id="vetraging-toevoegen">
<h3>Vetraging toevoegen<a class="headerlink" href="#vetraging-toevoegen" title="Permalink to this headline">¶</a></h3>
<p>We zouden makkelijk het signaal kunnen vertragen door de samples te verschuiven, maar dit simuleert alleen een vertraging dat een veelvoud is van onze sampletijd. Realistisch gezien zal de vertraging nooit exact gelijk zijn aan de sampletijd. We kunnen een willekeurige vertraging geven met een speciaal filter dat alle frequenties doorlaat maar de samples wel vertraagt met een fractie van de sampletijd. Je kunt het zien als een alles-doorlaatfiler dat een faseverschuiving introduceert op alle frequenties. (Een tijdsvertraging en faseverschuiving zijn immers hetzelfde!) De Python code van dit filter staat hieronder:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># filter maken en toepassen</span>
<span class="n">delay</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1"># fractie van de sampletijd</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">21</span> <span class="c1"># aantal coefficienten</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># ...-3,-2,-1,0,1,2,3...</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">delay</span><span class="p">)</span> <span class="c1"># coefficienten berekenen</span>
<span class="n">h</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># venster toepassen om beide kanten naar 0 te latten gaan</span>
<span class="n">h</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="c1"># normaliseren zodat de versterking 1 is en we het signaal niet dempen</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="c1"># filter toepassen.</span>
</pre></div>
</div>
<p>Zoals je ziet berekenen we de filtercoefficienten met behulp van de sinc() functie. Een sinc in het tijddomein is een rechthoek in het frequentiedomein en de rechthoek voor dit filter reikt over het hele frequentiebereik van ons signaal. Er is geen vervoming, alleen een vertraging. In dit voorbeeld is dat <img class="math" src="../_images/math/7bc37e60460554d9b28ee631828955067b87a08f.svg" alt="0.4*T_s"/>. Hou in je achterhoofd dat <em>elk</em> filter een vertraging toevoegt gelijk aan het aantal coefficienten/2 -1 vanwege de convolutieoperatie.</p>
<p>De vertraging is te zien wanneer we de in en uitgang van het filter weergeven. Als je alleen een paar symbolen bekijkt is het goed zichtbaar.</p>
<a class="reference external image-reference" href="images/fractional-delay-filter.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fractional-delay-filter.svg" class="align-center" src="../_images/fractional-delay-filter.svg" /></a>
</div>
<div class="section" id="frequentieafwijking-introduceren">
<h3>Frequentieafwijking introduceren<a class="headerlink" href="#frequentieafwijking-introduceren" title="Permalink to this headline">¶</a></h3>
<p>Om het ontvangen signaal nog realistcher te maken kunnen we een frequentieafwijking toepassen. Stel we hebben een samplerate van 1 MHz gebruikt (dit is niet belangrijk maar maakt het vervolg wat makkelijker). Mochten we een frequentieverschuiving van 13 kHz (willekeurig gekozen) willen toepassen dan kan dat met deze code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># freq afwijking</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># samplerate van 1 MHz</span>
<span class="n">fo</span> <span class="o">=</span> <span class="mi">13000</span> <span class="c1"># offset 13 khz</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span> <span class="c1"># sampletijd</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ts</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="n">Ts</span><span class="p">)</span> <span class="c1"># tijdvector</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">fo</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># verschuiving</span>
</pre></div>
</div>
<p>Dit figuur laat het signaal voor en na de frequentieverschuiving zien.</p>
<a class="reference external image-reference" href="images/sync-freq-offset.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/sync-freq-offset.svg" class="align-center" src="../_images/sync-freq-offset.svg" /></a>
<p>Tot nu toe konden we alleen het reele I-deel weergeve omdat we BPSK gebruiken. Maar nu we een frequentieverschuiving hebben geintroduceerd om een draadloos kanaal te simuleren verspreidt de energie zich over het I en Q deel. Dus vanaf nu moeten we beide delen weergeven. Voel je vrij een andere frequentieverschuiving te kiezen. Bij een verschuiving van 1 kHz zul je ook een sinusoide kunnen herkennen in de omlijning van het signaal; het varieert dan langzaam genoeg om een paar symbolen te overspannen.</p>
<p>Als je de code bestudeert zul je zien dat de samplerate niet helemaal arbitrair is, het is afhankelijk van het ratio tussen <code class="code docutils literal notranslate"><span class="pre">fo</span></code> en <code class="code docutils literal notranslate"><span class="pre">fs</span></code>.</p>
<p>Voor nu kun je de code beschouwen als de simulatie van een draadloos kanaal. De code komt na de zender maar voor de ontvanger. De kan van de ontvanger gaan we verder bestuderen in dit hoofdstuk.</p>
</div>
</div>
<div class="section" id="tijdsynchronisatie">
<h2>Tijdsynchronisatie<a class="headerlink" href="#tijdsynchronisatie" title="Permalink to this headline">¶</a></h2>
<p>Wanneer een signaal draadloos wordt verzonden ervaart het een willekeurige faseverschuiving vanwege de reistijd. We kunnen niet zomaar beginnen te samplen op onze samplefrequentie want dan zitten we hoogstwaarschijnlijk naast het juiste samplemoment zoals aan het eind van <a class="reference internal" href="pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a> is besproken. Bekijk de laatste drie figuren van dat hoofdstuk eens als je dit niet kunt volgen. Het doel is dus om origenele samplefrequentie en fase terug te vinden. Het wordt ook “clock-recovery” (herstellen van de klok) genoemd.</p>
<p>De meeste synchronisatietechnieken zijn gebaseerd op de phase locked loop (PLL); we zullen PLLs hier niet bespreken maar het is goed om te weten en je kunt er zelf informatie over opzoeken als je geinteresseerd bent. PLL’s zijn closed-loop systemen die feedback gebruiken om voortdurend wat bij te stellen; in dit geval een tijdsvertraging om op de pieken te kunnen samplen.</p>
<p>Je kunt de synchronisatie zien als een blok welk een stroom aan samples ontvangt en uitstuurt, net als een filter. Dit blok wordt ingesteld met informatie over ons signaal, met name het aantal samples per symbool (onze beste inschatting). Het blok werkt als een decimator, de samplefrequnetie aan de uitgang is lager dan aan de ingang. We willen maar 1 sample per symbool hebben dus de factor is gelijk aan het aantal samples per symbool.
Als we 1M symbolen per seconde zenden, en het signaal bij de ontvanger samplen met 16 MHz, dan krijgen we 16 samples per symbool.
De ingangsfrequentie van het blok is dan 16 MHz maar de uitgang 1 MHz, gezien we maar 1 sample per symbool willen.</p>
<p>De meeste algoritmes leunen op het feit dat digitale symbolen stijgen en dalen en de overgang is het moment waarop we willen samplen. Anders verwoord, als we de absolute versie van ons signaal nemen dan willen we op de pieken samplen:</p>
<a class="reference internal image-reference" href="../_images/symbol_sync2.png"><img alt="../_images/symbol_sync2.png" class="align-center" src="../_images/symbol_sync2.png" style="width: 667.6px; height: 194.8px;" /></a>
<p>De meeste algoritmen zijn op een PLL gebaseerd en het verschil tussen ze is de vergelijking die de afwijking in de tijd (<img class="math" src="../_images/math/c859a8f80a5b73b97ecb9d3c15842e979a0f6fe2.svg" alt="\mu"/>) probeert te corrigeren. De waarde van <code class="code docutils literal notranslate"><span class="pre">mu</span></code> wordt in elke iteratie van de loop geüpdatet. Je kunt het bekijken als de waarde die verteld hoeveel samples we het signaal moeten verschuiven om het “perfecte” samplemoment te vinden. Dus met een waard van <code class="code docutils literal notranslate"><span class="pre">mu</span> <span class="pre">=</span> <span class="pre">3.61</span></code> zouden we de ingang 3.61 samples moeten verschuiven om correct te kunen samplen. Omdat we 8 samples per symbool hebben zou een <code class="code docutils literal notranslate"><span class="pre">mu&gt;8</span></code> gewoon weer terugvouwen naar 0.</p>
<p>Het volgende stuk code implementeert het Mueller en Muller klokherstel algoritme. Je kunt het testen zolang je de frequentieverschuiving 0 laat; dit corrigeert alleen een faseverschuiving:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Eerste inschatting</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">out_rail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span> <span class="c1"># stores values, each iteration we need the previous 2 values plus current value</span>
<span class="n">i_in</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># input samples index</span>
<span class="n">i_out</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># output index (eerste twee zijn 0)</span>
<span class="k">while</span> <span class="n">i_out</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i_in</span><span class="o">+</span><span class="mi">16</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i_in</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="p">)]</span> <span class="c1"># probeer het &quot;beste&quot; sample.</span>
    <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#90,45,-45 of -90</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">+=</span> <span class="n">sps</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">mm_val</span>
    <span class="n">i_in</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="c1"># het is een index dus afronden</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="c1"># getal achter de punt bepalen</span>
    <span class="n">i_out</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># index uitgang ophogen</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">i_out</span><span class="p">]</span> <span class="c1"># eerste 2 verwijderen, alles na i_out is niet gebruikt</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">out</span> <span class="c1"># samples zijn de uitgang</span>
</pre></div>
</div>
<p>Het blok wordt de “ontvangen” samples gevoerd en geeft aan de uitgang 1 sample per keer (<code class="code docutils literal notranslate"><span class="pre">i_out</span></code> wordt telkens opgehoogd).
Het gebruikt niet alle ontvangen samples achter elkaar, maar slaat samples over in een poging sneller het juiste sample te vinden, op de piek van de puls.
Tijdens de herhaling probeert het langzaam met het symbool te synchroniseren door <code class="code docutils literal notranslate"><span class="pre">mu</span></code> aan te passen.
Als de synchronisatie volledig is zou de uitgang alleen samples moeten bevatten die op de juiste momenten zijn genomen.
De snelheid waarmee de lus reageert wordt bepaald door de 0.3 constante; een hogere waarde reageert heftiger of sneller, maar kan het systeem instabiel maken.</p>
<p>De volgende grafiek toont een voorbeelduitvoer waarbij we zowel de fractionele tijdvertraging als de frequentieverschuiving <em>uitgeschakeld</em> hebben. We tonen alleen I omdat Q nu uit nullen bestaat vanwege het gebrek aan frequentieverschuiving. De drie plots zijn op elkaar gestapeld om te laten zien hoe de bits verticaal zijn uitgelijnd.</p>
<dl class="docutils">
<dt><strong>Top Plot</strong></dt><dd>De originele BPSK symbolen, i.e., 1’en end -1’en.  Er zitten nullen tussen vanwege de 8 samples per symbool.</dd>
<dt><strong>Middle Plot</strong></dt><dd>Na het vormgeven van de pulsen.</dd>
<dt><strong>Bottom plot</strong></dt><dd>Na het uitvoeren van de Tijdsynchronisatie blijft er 1 sample per symbool over. Deze samples worden direct in de demodulator gestopt wat voor BPSK een vergelijking met 0 betekent.</dd>
</dl>
<a class="reference external image-reference" href="../_images/time-sync-output.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-output.svg" class="align-center" src="../_images/time-sync-output.svg" /></a>
<p>Als we kijken naar de uitgang van het synchronisatieblok in het onderste figuur, dan zien we dat het bijna 30 symbolen duurde voordat de juiste tijdvertraging was gevonden. Omdat een feedback-systeem altijd tijd nodig heeft om te reageren maken vele communicatieprotocolen gebruik van een “preamble” (Nederlands: reeks aan bits die het signaal voorgaan). Deze preamble bevat een synchronisatiesequentie: het verkondigt dat een nieuw pakketje is aangekomen, en geeft de ontvanger de tijd om te synchroniseren. Maar na ~30 symbolen werkt het perfect (in het figuur). Wat we over houden zijn perfecte 1’en en -1’en die overeenkomen met de verzonden data. Natuurlijk helpt het dat dit voorbeeld geen ruis had. Voel je vrij het ruisniveau en de tijdsvertraging aan te passen om te kijken hoe de synchronisatie werkt. In geval van QPSK zouden we met complexe getallen werken, maar de aanpak blijft hetzelfde.</p>
</div>
<div class="section" id="tijdsynchronisatie-met-interpolatie">
<h2>Tijdsynchronisatie met interpolatie<a class="headerlink" href="#tijdsynchronisatie-met-interpolatie" title="Permalink to this headline">¶</a></h2>
<p>Meestal interpoleren synchronisatieblokken de ingangssamples door een bepaald nummer, bijv. 16, zodanig dat het signaal ook een fractie van de sampletijd verschoven kan worden. De willekeurige vertraging dat een draadloos kanaal introduceert, is hoogstwaarschijnlijk niet perfect gelijk aan een veelvoud van de sampletijd. Dit zal helemaal niet het geval zijn wanneer we 2 of 4 samples per symbool ontvangen. Door de samples te interpoleren geeft het ons de mogelijkheid om “tussen” de samples te samplen om de uiterste piek van het symbool te vinden. De uitgang zal nog steeds 1 sample per symbool bevatten, het is de ingang dat geïnterpoleerd wordt.</p>
<p>De Python code voor tijdsynchronisatie dat we hierboven gebruikten bevat geen interpolatie. Om de code uit te breiden kun je de fractionele tijdvertraging aanzetten dat we aan het begin van dit hoofdstuk hebben geimplementeerd, dit geeft een realistischer beeld. Laat de frequentieverschuiving uit staan. Wanneer je de simulatie opnieuw uitrvoert zul je zien dat er nooit volledig gesynchroniseerd wordt met het signaal. Dit komt omdat we niet interpoleren en het dus niet mogelijk is om tussen de samples in te samplen. Laten we interpolatie toevoegen.</p>
<p>De snelste en makkelijkste manier om met Python een signaal te interpoleren is door gebruik te maken van scipy’s <code class="code docutils literal notranslate"><span class="pre">signal.resample</span></code> of <code class="code docutils literal notranslate"><span class="pre">signal.resample_poly</span></code>. Beide functies bereiken hetzelfde, maar werken iets anders. We zullen de tweede functie toepassen omdat deze wat sneller is. We gaan een interpolatiefactor van 16 gebruiken, dus we voegen 15 extra samples tussen elke sample toe. Dit kan worden toegepast in 1 regel code en moet <em>voor</em> de tijdsynchronisatie worden toegevoegd. Het synchronisatie-algoritme moet ook iets aangepast worden. We kunnen het verschil bekijken:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples_interpolated</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Plot the old vs new</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;before interp&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;after interp&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples_interpolated</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Als we het <em>heel erg</em> vergroten dan zien we dat het hetzelfde signaal is, maar met 16x zoveel punten:</p>
<a class="reference external image-reference" href="images/time-sync-interpolated-samples.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-interpolated-samples.svg" class="align-center" src="../_images/time-sync-interpolated-samples.svg" /></a>
<p>Hopelijk is de reden achter het interpoleren duidelijk aan het worden. De extra samples staan ons toe om ook een fractie van de sampletijd te kunnen zien. Naar het interpoleren van de samples zullen we ook twee regels van het synchronisatieblok moeten aanpassen. De eerste twee regels van de while loop worden dan:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">i_out</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i_in</span><span class="o">*</span><span class="mi">16</span><span class="o">+</span><span class="mi">16</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
  <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i_in</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="mi">16</span><span class="p">)]</span> <span class="c1"># probeer het &quot;beste&quot; sample.</span>
</pre></div>
</div>
<p>We hebben een aantal dingen aangepast. Als eerste kunnen we <code class="code docutils literal notranslate"><span class="pre">i_in</span></code> niet meer gebruiken als de sampleindex. We hebben nu 16 keer zoveel samples dus we moeten de index met 16 vermenigvuldigen. De loop past <code class="code docutils literal notranslate"><span class="pre">mu</span></code> aan. Dit stelt de vertraging voor dat we nodig hebben om correct te samplen.
Eerder kon we niet een fractie van de sampletijd wachten, maar nu wel, in stappen van een 16e van de sampletijd.
We vermenigvuldigen <code class="code docutils literal notranslate"><span class="pre">\mu</span></code> dus met 16 om uit te vogelen met hoeveel samples we ons geinterpoleerde signaal moeten vertragen.
Als deze paragraaf niet duidelijk is, probeer dan de initiele code met het commentaar nogmaals door te lezen.
Het is niet heel belangrijk dat je het algoritme snapt, maar wel de limitaties ervan.</p>
<p>Voel je vrij om met eigen interpolatiefactoren te spelen. Je kunt ook proberen om de frequentieverschuiving nu toe te passen, of ruis toe te voegen, om te zien hoe het synchronisatiealgoritme dit aanpakt (hint: misschien moet je die 0.3 factor ook aanpassen).</p>
<p>Als de een frequentieverschuiving toepassen van 1 kHz dan zie je de volgende reactie. We zullen beide I en Q moeten weergeven omdat een frequentieverschuiving toe hebben gevoegd (door een complex exponent):</p>
<a class="reference external image-reference" href="images/time-sync-output2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-output2.svg" class="align-center" src="../_images/time-sync-output2.svg" /></a>
<p>Het is nu iets lastiger te zien maar de tijdsynchronisatie werkt nog steeds prima. Er is nu een sinusoide zichtbaar omdat we een frequentieverschuiving hebben geintroduceerd. In het volgende deel leren we hier mee om te gaan.</p>
<p>Het IQ-diagram (constellatie-diagram) is hieronder te zien van voor en na synchronisatie. Mocht je het zijn vergeten; je kunt een IQ-diagram maken d.m.v. een “scatter plot”: <code class="code docutils literal notranslate"><span class="pre">plt.plot(np.real(samples),</span> <span class="pre">np.imag(samples),</span> <span class="pre">'.')</span></code>. In de animatie hebben we bewust de eerste en laatste 30 symbolen niet meegenomen omdat het algoritme toen nog niet klaar was met synchroniseren. De symbolen die overblijven zijn allemaal rond de eenheidscirkel verdeelt vanwege de frequentieverschuiving.</p>
<a class="reference external image-reference" href="images/time-sync-constellation.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-constellation.svg" class="align-center" src="../_images/time-sync-constellation.svg" /></a>
<p>We kunnen nog meer leren wanneer we de constellatie over de tijd uitzetten. Aan het begin zie zijn de symbolen eventjes niet 0 of op de eenheidscirkel. Dat is de tijd die het synchronisatiealgoritme nodig heeft om de juiste tijdsvertraging te vinden. Het gebeurt in een korte tijd dus kijk goed! Het ronddraaien komt door de frequentieverschuiving. Frequentie is een constante verandering in de fase, dus een frequentieverschuiving resulteert in het ronddraaien van het BPSK-diagram, wat leid tot een cirkel in het statische diagram van hierboven.</p>
<img alt="../_images/time-sync-constellation-animated.gif" class="align-center" src="../_images/time-sync-constellation-animated.gif" />
<p>Hopelijk heb je dankzij de animatie een beter beeld van wat er echt gebeurt , en een gevoel voor hoe het werkt. In de praktijk werkt de while loop alleen op een beperkt aantal samples (bijv. 1000) en zul je het herhaaldelijk moeten aanroepen. Tussen de aanroepen in moet je de waarde van <code class="code docutils literal notranslate"><span class="pre">mu</span></code> , en de laatste paar waarden van <code class="code docutils literal notranslate"><span class="pre">out</span></code> en <code class="code docutils literal notranslate"><span class="pre">out_rail</span></code> , moeten onthouden.</p>
<p>Nu gaan we ons druk maken over frequentiesynchronisatie, opgedeelt in grove en fijne synchronisatie. Meestal doen we eerst de grove en daarna de fijne.</p>
</div>
<div class="section" id="grove-frequentiesynchronisatie">
<h2>Grove Frequentiesynchronisatie<a class="headerlink" href="#grove-frequentiesynchronisatie" title="Permalink to this headline">¶</a></h2>
<p>Ook al stellen we de zender en ontvanger in op dezelfde frequentie, er zal altijd een klein frequentieverschil zijn vanwege imperfecte hardware (de oscillator) of het Doppler-effect vanwege beweging. Het frequentieverschil zal minimaal zijn vergeleken met de draaggolf, maar zelfs een klein verschil kan een digitaal signaal verpesten. De oscillator binnen de Pluto heeft bijvoorbeeld een nauwkeurigheid van 25 PPM. Dus als je op 2.4 GHz afstelt, dan zou dat er maximaal +/- 60 kHz naast kunnen zitten. De samples die we van de SDR krijgen zitten in de basisband, we zien dan het frequentieverschil ook in de basisband. Een BPSK signaal met een klein verschil in draaggolf ziet er ongeveer als het onderstaande figuur uit, wat duidelijk niet zo handig is voor de demodulatie. We zullen dus elke frequentieverschuiving moeten verwijderen voordat we demoduleren.</p>
<a class="reference internal image-reference" href="../_images/carrier-offset.png"><img alt="../_images/carrier-offset.png" class="align-center" src="../_images/carrier-offset.png" style="width: 744.6px; height: 147.6px;" /></a>
<p>Frequentiesynchronisatie wordt meestal opgedeeld in de grove en fijne sync, waar de grove synchronisatie grote verschillen, van een kHz of meer, kan corrigeren, en de fijne sync corrigeert het overgebleven verschil. Grove correctie gebeurt voor tijdsynchronisatie en fijne correctie erna.</p>
<p>Wiskundig gezien, als een basisband signaal <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> een frequentie(draaggolf)verschuiving ervaart van <img class="math" src="../_images/math/90ca84a8ff16423f1f608d7694dbd97c7e88d5e2.svg" alt="f_v"/> Hz, dan is het ontvangen signaal <img class="math" src="../_images/math/84de64fb0b5040cd6bff471e2e8edb3edf35fcb5.svg" alt="r(t)"/> uit te drukken als:</p>
<div class="math">
<p><img src="../_images/math/04b2fa68b3225c93b87dbb73dcc836701199adf1.svg" alt="r(t) = s(t) e^{j2\pi f_v t} + n(t)"/></p>
</div><p>Waar <img class="math" src="../_images/math/9a5bb2f9fe74aa0a2242ca907f54bb133b0ca3f7.svg" alt="n(t)"/> de ruis is.</p>
<p>De eerste truc voor grove instchatting van de frequentieafwijking, is om het kwadraat van ons signaal te nemen. Wanneer we de afwijking weten, dan kunnen we het ongedaan maken. We negeren de ruis voor nu om het simpel te houden:</p>
<div class="math">
<p><img src="../_images/math/c8a6126a02a32c47e6f1fe20177dd176f64a17ec.svg" alt="r^2(t) = s^2(t) e^{j4\pi f_v t}"/></p>
</div><p>Wat zou er gebeuren wanneer we het kwadraat nemen van een QPSK signaal? Kwadrateren van complexe getallen geeft een interessant resultaat, met name wanneer we de constellatiediagrammen van BPSK en QPSK bekijken. De volgende animatie laat zien wat er gebeurt wanneer we QPSK twee maal kwadrateren. Er is bewust voor QPSK gekozen zodat je ziet dat eenmaal kwadrateren een BPSK signaal geeft. Als je het nog een keer kwadrateert zie je een cluster. (Dank aan Ventrella voor deze gave app <a class="reference external" href="http://ventrella.com/ComplexSquaring/" rel="noopener noreferrer" target="_blank">http://ventrella.com/ComplexSquaring/</a> .)</p>
<a class="reference internal image-reference" href="../_images/squaring-qpsk.gif"><img alt="../_images/squaring-qpsk.gif" class="align-center" src="../_images/squaring-qpsk.gif" style="width: 480.0px; height: 468.0px;" /></a>
<p>En nog een keer met een kleine fasedraaing en amplitudeaanpassing om het realistischer te maken:</p>
<a class="reference internal image-reference" href="../_images/squaring-qpsk2.gif"><img alt="../_images/squaring-qpsk2.gif" class="align-center" src="../_images/squaring-qpsk2.gif" style="width: 480.0px; height: 468.0px;" /></a>
<p>Het resultaat blijft een cluster, maar nu met een fasedraaing. De clue is, dat wanneer je QPSK tweemaal kwadrateert (en BPSK eenmaal), het alle vier de clusters samenvoegt tot een cluster. Waarom is dit handig? Door het samenvoegen verwijderen we de modulatie. Nu alle punten in een cluster vallen houden we effectief een rij van constanten over voor <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/>. Het enige wat dan overblijft is de sinusoide die wordt veroorzaakt door het frequentieverschil (en nog ruis maar dat negeren we voor nu). Het blijkt dat je een signaal N maal moet kwadrateren, waarbij N de orde van het modulatieschema is. Deze truc werkt dan alleen wanneer je van ten voren het modulatieschema kent. De algemene vergelijking wordt dan:</p>
<div class="math">
<p><img src="../_images/math/23035d0c71fae77f37b0f8761fcdd34ead94c703.svg" alt="r^N(t) = s^N(t) e^{j2N\pi f_v t}"/></p>
</div><p>In het geval van BPSK hebben we een 2e orde modulatieschema, dus dan zou de vergelijking dit worden:</p>
<div class="math">
<p><img src="../_images/math/c8a6126a02a32c47e6f1fe20177dd176f64a17ec.svg" alt="r^2(t) = s^2(t) e^{j4\pi f_v t}"/></p>
</div><p>We weten nu wat er met het <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> deel van de vergelijking, maar hoe zit het met het sinusoide deel (het complexe exponent)?
Zoals is te zien voegt het <img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/> toe aan de vergelijking, dus in plaats van de originele frequentieveschuiving <img class="math" src="../_images/math/90ca84a8ff16423f1f608d7694dbd97c7e88d5e2.svg" alt="f_v"/> is het nu N keer zo veel: <img class="math" src="../_images/math/1a69a30af9b8b2f59c206a55e76d6572271104cf.svg" alt="N\cdot f_v"/>. De makkelijkste manier om de waar <img class="math" src="../_images/math/1a69a30af9b8b2f59c206a55e76d6572271104cf.svg" alt="N\cdot f_v"/> te vinden in Python is met behulp van de FFT. Laten we dat doen. We nemen weer ons BPSK signaal, maar in plaats van een fractionele vertraging gaan we nu een frequentieverschuiving toevoegen door het signaal te vermenigvuldigen met <img class="math" src="../_images/math/226b304dd210bb038b11265f241851a89755b42b.svg" alt="e^{j2\pi f_o t}"/> zoals we in het <a class="reference internal" href="filters.html#filters-chapter"><span class="std std-ref">Filters</span></a> hadden gedaan.</p>
<p>Met behulp van de code uit het begin van dit hoofdstuk kun je een afwijking van 13 kHz aan ons signaal toevoegen. De afwijking wordt geintroduceerd door het kanaal. Je kunt het dus tussen de twee RRC filters, of na het enkele RC-filter toevoegen.</p>
<p>Laten we de FFT weergeven en kijken wat voor resultaat het kwadrateren geeft in het frequentiedomein. Je zou nu moeten weten hoe je een FFT uitvoert, inclusief de abs() en fftshift() functies. Het maakt in dit geval niet uit of je de log neemt, we zijn alleen geinteresseerd in waar de frequentiepiek zit. Niet hoe hoog het is is.</p>
<p>Eerst bekijken we het signaal zonder te kwadrateren, met een normale FFT:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">samples</span><span class="p">)))</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">psd</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="images/coarse-freq-sync-before.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/coarse-freq-sync-before.svg" class="align-center" src="../_images/coarse-freq-sync-before.svg" /></a>
<p>Er is helemaal geen draaggolf te herkennen, het wordt verborgen door ons signaal.</p>
<p>Nogmaals na het kwadrateren:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add this before the FFT line</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>Door het figuur te vergroten kunnen we bepalen waar de piek zit:</p>
<a class="reference external image-reference" href="images/coarse-freq-sync.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/coarse-freq-sync.svg" class="align-center" src="../_images/coarse-freq-sync.svg" /></a>
<p>Je zou het aantal symbolen kunnen vergroten (bijv. 1000 symbolen) zodat we genoeg samples hebben voor de FFT. Hoe meer samples de FFT gebruikt, hoe nauwkeuriger we de frequentieafwijking kunnen inschatten. Ter herinnering, de bovenstaande code moet <em>voor</em> de tijdsynchronisatie plaatsvinden. Deze kan immers niet goed omgaan met een grote frequentieafwijking.</p>
<p>De frequentiepiek verschijnt bij <img class="math" src="../_images/math/1a69a30af9b8b2f59c206a55e76d6572271104cf.svg" alt="N\cdot f_v"/>. We moeten de bin (26.6 kHz) dus door 2 delen om <img class="math" src="../_images/math/90ca84a8ff16423f1f608d7694dbd97c7e88d5e2.svg" alt="f_v"/> te vinden. 13.3 kHz is bijzonder dicht bij de frequentieverschuiving die we hebben toegepast aan het begin van dit hoofdstuk. Als je een andere frequentie had gekozen is dat ook geen probleem, zolang je maar bewust bent wat het zou moeten zijn.</p>
<p>De maximale frequenties die we kunnen zien met een samplerate van 1 MHz zijn -500 kHz tot 500 kHz. Wanneer we ons signaal tot de macht N verheffen, dan kunnen we alleen nog de frequentieverschuivingen tot <img class="math" src="../_images/math/ac3f385ee8392aff6eba657b6319240252627cf3.svg" alt="\frac{500e3}{N}"/> “zien”, dus in het geval van BPSK +- 250 kHz. Voor QPSK slechts 125 kHz; zou de afwijking van de draaggolf groter zijn dan dit, dan kunnen we het niet meer vinden met deze techniek. Om je een gevoel te geven voor het Doppler-effect, als we op 2.4 GHz zouden zenden, en de zender of ontvanger gingen zo’n 100 km/u (het gaat om het relatieve verschil), dan levert dat een verschuiving op van ongeveer 215 Hz. De afwijking dat een goedkope oscillator introduceert is hoogstwaarschijnlijk de grootste bron van afwijking.</p>
<p>De afwijking ook echt corrigeren gebeurt op dezelfde manier als waarop we het hebben toegevoegd: vermenigvuldigen met een complex (negatieve) exponent.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">max_freq</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">psd</span><span class="p">)]</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span> <span class="c1">#  sampletijd</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ts</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="n">Ts</span><span class="p">)</span> <span class="c1"># tijdvector</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">max_freq</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Het is aan jou of je de afwijking wilt corrigeren, of gewoon verlagen tot zo’n 500 Hz om te kijken hoe fijne synchronisatie daarmee omgaat. Daar gaan we nu naar kijken.</p>
</div>
<div class="section" id="fine-frequency-synchronization">
<h2>Fine Frequency Synchronization<a class="headerlink" href="#fine-frequency-synchronization" title="Permalink to this headline">¶</a></h2>
<p>We zullen nu overschakelen op fijne frequentiecorrectie. De vorige truc was open-lus en is alleen geschikt om een grove correctie uit te voeren. Voor de fijne correctie willen we terugkoppeling gaan toepassen in de vorm van een PLL. Het doel is om het frequentieverschil tot nul te brengen en te houden, zelfs wanneer het frequentieverschil over de tijd varieert. We zullen continu het verschil moeten bijhouden. Fijne synchronisatietechnieken werken het beste op symboolniveau zonder een tijdafwijking. De code die we hier behandelen komt dus <em>na</em> de tijdsynchronisatie.</p>
<p>We zullen de Costas-loop gaan toepassen. Dit is een soort PLL dat speciaal is ontwikkeld om een draaggolfafwijking te corrigeren bij digitale signalen zoals BPSK en QPSK. Het is uitgevonden door John P. Costas bij General Electric in de jaren 50 en heeft een enorme inpact gehad op moderne digitale communicatie. De Costas-loop zal niet alleen de frequentieafwijking corrigeren, maar ook elke faseverschuiving. Frequentie is gewoon een faseverandering dus ze kunnen beiden gevolgd worden. De Costat-loop kan worden samengevat met het volgende figuur (let op dat de halven zijn weggelaten uit de vergelijkingen omdat ze geen invloed hebben).</p>
<a class="reference external image-reference" href="../_images/costas-loop.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop.svg" class="align-center" src="../_images/costas-loop.svg" /></a>
<p>De spanningsgestuurde oscillator (VCO) is gewoon een sin/cos signaalgenerator dat een frequentie gebruikt op basis van de ingang. In ons geval, omdat we een draadloos kanaal simuleren, is het geen spanning maar een niveau aangegeven door een variabele. Het bepaalt de frequentie en fase van de gegenereerde sinus en cosinus golven. Het vermenigvuldigt het ontvangen signaal met een zelf gegenereerde sinusoide in een poging de frequentie- en faseafwijking ongedaan te maken. Dit gedrag is vergelijkbaar met hoe een SDR een signaal naar de basisband verschuift en de I- en Q-takken maakt.</p>
<p>Hieronder is de code te vinden van de Costas-Loop:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">fase</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Deze volgende twee parameters bepalen of de feedback loop sneller of langzamer reageert (wat de stabiliteit beinvloed)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.132</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.00932</span>
<span class="n">uit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">freq_log</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">uit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">fase</span><span class="p">)</span> <span class="c1"># pas de ingang aan met de inverse van de geschatte faseafwijking</span>
    <span class="n">fout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">uit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">uit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># De is de foutvergelijking voor de 2e orde Costas-loop (dus voor BPSK)</span>

    <span class="c1"># Update de fase en frequentie</span>
    <span class="n">freq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">fout</span><span class="p">)</span>
    <span class="n">freq_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="c1"># zet hoekfrfequentie om naar Hz voor het loggen</span>
    <span class="n">fase</span> <span class="o">+=</span> <span class="n">freq</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">fout</span><span class="p">)</span>

    <span class="c1"># Optioneel: zorg dat de fase tussen 0 en 2pi blijft</span>
    <span class="k">while</span> <span class="n">fase</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">fase</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">while</span> <span class="n">fase</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fase</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="c1"># druk frequentie over de tijd af om de voortgang te kunnen zien</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq_log</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1">#als je verder wilt gaan met samples...</span>
<span class="c1">#samples=uit</span>
</pre></div>
</div>
<p>Er gebeurt een hoop dus laten we erdoorheen lopen. Sommige regels zijn eenvoudig en andere super ingewikkeld.
<code class="code docutils literal notranslate"><span class="pre">samples</span></code> is onze ingang, <code class="code docutils literal notranslate"><span class="pre">uit</span></code> onze uitgang.
<code class="code docutils literal notranslate"><span class="pre">fase</span></code> en <code class="code docutils literal notranslate"><span class="pre">freq</span></code> werken zoals de <code class="code docutils literal notranslate"><span class="pre">mu</span></code> bij het tijdsynchronisatievoorbeeld.
Ze bevatten de huidig geschatte afwijking en elke iteratie worden de samples van de ingang vermenigvuldigt met <code class="code docutils literal notranslate"><span class="pre">np.exp(-1j*phase)</span></code>.
De <code class="code docutils literal notranslate"><span class="pre">fout</span></code> variabele kwantificeert de fout in de correctie, en voor een 2e orde Costat-loop is dit een simpele vergelijking.
We vermenigvuldigen het reele deel van de sample (I) met het imaginaire deel (Q). Omdat het Q-deel 0 zou moeten zijn voor BPSK wordt de foutvergelijking geminimaliseerd wanneer er geen fase- of frequentieafwijking is.
De 4e orde vergelijking (QPSK) is nog steeds relatief simpel maar niet meer een regel gezien beide I en Q energie zullen bevatten, zelfs wanneer het signaal geen afwijking heeft.
We gaan het nu niet toepassen, maar mocht je benieuwd zijn naar hoe de QPSK versie eruit ziet in code dan kun je hieronder klikken.</p>
<details>
<summary>4e orde Costas-Loop foutvergelijking (voor de geinteresseerden)</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For QPSK</span>
<span class="k">def</span> <span class="nf">phase_detector_4</span><span class="p">(</span><span class="n">sample</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">real</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sample</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sample</span><span class="o">.</span><span class="n">real</span>
</pre></div>
</div>
</details><p>De <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> en <code class="code docutils literal notranslate"><span class="pre">beta</span></code> variabelen bepalen hoe snel de fase en frequentie worden geupdatet. Er is een reden waarom ik die twee aarden heb gekozen, maar dat gaan we niet behandelen. Als je nieuwsgierig bent kun je alpha en/of beta kunnen varieren om te kijken wat er gebeurt.</p>
<p>Iedere iteratie loggen we <code class="code docutils literal notranslate"><span class="pre">freq</span></code> naar het scherm zodat we responsie zien van het regelalgoritme bij het corrigeren van de frequentieafwijking. Om de frequentie in Hz te laten zien moeten we <code class="code docutils literal notranslate"><span class="pre">freq</span></code> vermenigvuldigen met de samplerate en door <img class="math" src="../_images/math/bf50b56b21d67ede45fc1ec5b8213871824fe365.svg" alt="2\pi"/> delen.
Mocht je eerste de time sync hebben uitgevoerd dan zul je <code class="code docutils literal notranslate"><span class="pre">freq</span></code> ook nog door <code class="code docutils literal notranslate"><span class="pre">sps</span></code> moeten delen omdat de originele samplerate <code class="code docutils literal notranslate"><span class="pre">sps</span></code> keer zo klein is.</p>
<p>Als laatste moet de berekende fase gecorrigeerd worden om het tussen 0 en <img class="math" src="../_images/math/adbf740b3ae712140edad99b950ffd8c9ec2919b.svg" alt="2 \pi"/> te houden.</p>
<p>Het signaal voor en na onze Costas Loop ziet er dan zo uit:</p>
<a class="reference external image-reference" href="images/costas-loop-output.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop-output.svg" class="align-center" src="../_images/costas-loop-output.svg" /></a>
<p>De frequentieinschatting uitgezet over de tijd (een -300 Hz offset werdt voor dit voorbeeld gebruikt):</p>
<a class="reference external image-reference" href="images/costas-loop-freq-tracking.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop-freq-tracking.svg" class="align-center" src="../_images/costas-loop-freq-tracking.svg" /></a>
<p>Het duurt bijna 70 samples voordat het algoritme de afwijking heeft gevonden.
Je kunt zien dat de grove frequentiesynchronisatie nog steeds 300 Hz ernaast zat. De jouwe kan een andere waarde hebben. Zoals ik al eerder zei, kun je de grove frequentiesynchronisatie uitschakelen en de initiële frequentieafwijking instellen op elke gewenste waarde en kijken of de Costas Loop het kan corrigeren.</p>
<p>De Costas-loop heeft niet alleen de frequentieafwijking gecorrigeerd, maar ook ons BPSK signaal uitgelijnd met het I deel waardoor Q weer nul is geworden. Dit is een bijkomend voordeel van de Costas-loop, en maakt het in essentie ook onze demodulator. We hoeven alleen nog maar te kijken of het reele I-deel boven of onder de 0 is. Helaas weten we nog niet of de negatieve of positieve waarde correspondeert met 0 of 1 want er kan een inversie plaats hebben gevonden; de costas-loop kan dat in geen mogelijkheid weten. Hier komt differentiele codering om de hoek kijken. Dit verwijdert de twijfel omdat 1’en en 0’en nu worden gebaseerd op het feit dat er een verandering heeft plaatsgevonden, niet of het een -1 of +1 was. Wanneer de differentiele codering toepassen dan gebruiken we nog steeds BPSK. We zouden dit coderingsblok net voor de modulatie op de tx kant, en net na demodulatie op de rx kant , stoppen.</p>
<p>Hieronder zie je een animatie van de tijdsynchronisatie en frequentiecorrectie algoritmen, de tijdsynchronisatie gebeurd bijna meteen, maar de frequentiecorrectie heeft bijna de hele animatie nodig om de juist instelling te vinden. Dit komt omdat we een te lage waarde hadden gekozen voor <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> en <code class="code docutils literal notranslate"><span class="pre">beta</span></code> (0.005 en 0.001). De code van deze animatie is hier te <a class="reference external" href="https://github.com/777arc/textbook/blob/master/figure-generating-scripts/costas_loop_animation.py" rel="noopener noreferrer" target="_blank">vinden</a>.</p>
<img alt="../_images/costas.gif" class="align-center" src="../_images/costas.gif" />
</div>
<div class="section" id="frame-synchronisatie">
<h2>Frame-synchronisatie<a class="headerlink" href="#frame-synchronisatie" title="Permalink to this headline">¶</a></h2>
<p>We hebben behandeld hoe je een tijd-, frequentie- of faseafwijking in een ontvangen signaal kunt corrigeren. De meeste communicatieprotocollen sturen echter niet alleen data, maar maken gebruik van pakketten/frames. De ontvanger moet namelijk kunnen zien waar een frame start. Gewoonlijk is er een frame header (op de MAC laag) dat verteld hoeveel byts in het frame zitten. We kunnen die infroamtie gebruiken om te weten hoe lang het hele frame is in samples of symbolen. Desalniettemin is het vinden van de start van een frame een hele taak op zich. Hieronder zie je de structuur van een wifi-frame. Het valt op dat het eerste ding wat verstuurt wordt een PHY-laag header is, en de eerste helft van die header is een “preamble” (aankondiging).Deze preamble bevat een rij van bits die de ontvanger kan gebruiken om de start van een frame te herkennen. De preamble is van te voren bekend bij de ontvanger.</p>
<a class="reference internal image-reference" href="../_images/wifi-frame.png"><img alt="../_images/wifi-frame.png" class="align-center" src="../_images/wifi-frame.png" style="width: 772.1999999999999px; height: 147.0px;" /></a>
<p>Een veel gebruikte en logische methode om deze rij van bits de detecteren is door de ontvangen data te (kruis)corelleren met de bekende preamble. Wanneer de juiste rijs bits binnen komt dan lijkt de correlatie op de eigencorrelatie (maar met ruis). Om deze reden worden de preambles zo gekozen dat de eigencorrelatie mooie eigenschappen heeft. De autocorrelatie moet bijvoorbeeld alleen op plek 0 een piek geven, en niet op andere plekken. Een voorbeeld is een Barker code, i 802.11/wifi wordt een Barker code van lengte 11 toegepast voor de 1 en 2 Mbit.sec snelheden:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>+1 +1 +1 −1 −1 −1 +1 −1 −1 +1 −1
</pre></div>
</div>
<p>In feite zouden dit 11 BPSK symbolen kunnen zijn. We kunnen de eigecorrelatie van deze rij gemakkelijk met Python vinden:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;same&#39;</span><span class="p">),</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/barker-code.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/barker-code.svg" class="align-center" src="../_images/barker-code.svg" /></a>
<p>De piek is in het midden en 11 hoog (de lengte van de rij). Op alle andere vertragingen levert het -1 of 0 op. Dit werkt goed om de start van een frame te vinden omdat het in feite de energy van 11 symbolen integreert tot een piek van een enkele bit aan de uitgang van de kruiscorrelatie.
Het moeilijkste aan het detecteren van de start is om de juiste threshold te kiezen. Je wilt niet dat data dat geen onderdeel van het protocol is, toch een start aangeeft.
Dus naar de kruiscorrelatie zul je ook vermogen moeten gaan normaliseren, wat buiten de scope valt van dit boek. In het bepalen van de juiste threshold zul je een afweging moeten maken tussen de kans op detectie en de kans op een vals alarm.
De frame-header bevat immers zelf ook informatie, dus bepaalde valse alarmen zijn niet erg; zodra je de header decodeert en de CRC faalt, dan weet je dat het geen frame was.
Het zou erger zijn als je een frame helemaal mist.</p>
<p>Een andere sequentie van bits met hele goede eigencorrelatie-eigenschappen is de Zadoff-Chu reeks. Dit wordt in LTE toegepast. Zij hebben het voordeel dat ze in sets komen; er zijn meerdere verschillende sequenties die goede eigenschappen hebben, maar elkaar niet zullen triggeren (dus ook goede kruiscorrelatie eigenschappen ten opzicht van elkaar). Dankzij die feature kunnen verschillende telefoonmasten verschillende sequenties gebruiken zodat een telefoon niet alleen de start van een frame van detecteren, maar ook van welke mast het signaal komt.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pulse_shaping.html" title="Previous document"><span class="section-number">13. </span>Pulse Shaping</a>
        </li>
        <li>
          <a href="rds.html" title="Next document"><span class="section-number">15. </span>Compleet voorbeeld</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>