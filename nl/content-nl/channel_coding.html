
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>10. Kanaalcodering &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. IQ Files and SigMF" href="iq_files.html" />
    <link rel="prev" title="9. Link Budgets" href="link_budgets.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-nl.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: Een handleiding voor SDR en DSP met Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introductie</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Het Frequentiedomein</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ-sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digitale Modulatie</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Ruis en dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">10. Kanaalcodering</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#waarom-we-kanaalcodering-nodig-hebben">Waarom we kanaalcodering nodig hebben</a></li>
<li class="toctree-l2"><a class="reference internal" href="#typen-codes">Typen Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code-snelheid">Code-snelheid</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modulatie-en-codering">Modulatie en codering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hamming-code">Hamming Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#soft-vs-hard-decodering">Soft vs Hard Decodering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shannon-limiet">Shannon Limiet</a></li>
<li class="toctree-l2"><a class="reference internal" href="#state-of-the-art-codes">State of the Art Codes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisatie</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Compleet voorbeeld</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-nl.html">Documentation overview</a><ul>
      <li>Previous: <a href="link_budgets.html" title="previous chapter"><span class="section-number">9. </span>Link Budgets</a></li>
      <li>Next: <a href="iq_files.html" title="next chapter"><span class="section-number">11. </span>IQ Files and SigMF</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="link_budgets.html" title="Previous document"><span class="section-number">9. </span>Link Budgets</a>
        </li>
        <li>
          <a href="iq_files.html" title="Next document"><span class="section-number">11. </span>IQ Files and SigMF</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="kanaalcodering">
<span id="channel-coding-chapter"></span><h1><span class="section-number">10. </span>Kanaalcodering<a class="headerlink" href="#kanaalcodering" title="Permalink to this headline">¶</a></h1>
<p>Dit hoofdstuk introduceert de basis van kanaalcodering, bekend als voorwaartse foutcorrectie (Forward Error Correction: FEC), de Shannon-Limiet, Hamming-codes, Turbo- en LDPC-codes.
Kanaalcodering is een enorm gebied binnen de draadloze communicatie. Het is een tak van de “informatietheorie” wat de studie is over de kwantificatie, opslag en communicatie van informatie.</p>
<div class="section" id="waarom-we-kanaalcodering-nodig-hebben">
<h2>Waarom we kanaalcodering nodig hebben<a class="headerlink" href="#waarom-we-kanaalcodering-nodig-hebben" title="Permalink to this headline">¶</a></h2>
<p>Zoals we hebben geleerd in het <a class="reference internal" href="noise.html#noise-chapter"><span class="std std-ref">Ruis en dB</span></a> hoofdstuk, hebben draadloze kanalen last van ruis en komen onze symbolen dus niet perfect bij de ontvanger aan.
Mocht je een cursus over netwerken hebben gedaan dan weet je waarschijnlijk al iets over cyclic redundancy checks (CRC) wat fouten <strong>detecteert</strong> bij de ontvanger.
Het doel van kanaalcodering is niet alleen om bij de ontvanger fouten te herkennen, maar ook te <strong>repareren</strong>.
Als we wat fouten toelaten dan is het mogelijk om een hogere orde van modulatieschema toe te passen zonder verlies van kwaliteit.
Bekijk, voor een visueel voorbeeld, de onderstaande constellatiediagrammen voor QPSK (links) en 16QAM (rechts) met dezelfde hoeveelheid ruis.
QPSK geeft 2 bits per symbool, terwijl 16QAM een dubbele datasnelheid heeft van 4 bits per symbool. Maar zie hoe, voor QPSK, de symbolen niet de beslissingsgrens (x- en y-as) overlappen en dus de symbolen correct worden ontvangen. Tegelijkertijd overlappen de clusters wel in het 16QAM-diagram, met als resultaat dat er een hoop verkeerde symbolen worden ontvangen.</p>
<a class="reference internal image-reference" href="../_images/qpsk_vs_16qam.png"><img alt="../_images/qpsk_vs_16qam.png" class="align-center" src="../_images/qpsk_vs_16qam.png" style="width: 591.3000000000001px; height: 217.8px;" /></a>
<p>Een CRC-fout resulteert bij een protocol als TCP meestal in het opnieuw verzenden van een pakket.
Als Alice een bericht stuurt naar Bob we zouden we liever niet Bob nog een bericht naar Alice laten sturen om de informatie opnieuw aan te vragen.
Het doel van kanaalcodering is om overtollige of <strong>redundante</strong> informatie te sturen.
Door redundante data mee te sturen bouwen we een failsafe in om foute pakketten, her transmissies en verloren data te kunnen voorkomen.</p>
<p>Nu we weten waarom het nodig is kunnen we zien waar het wordt toegepast in de communicatieketen:</p>
<div class="figure" style="text-align: center"><p><img  src="../_images/tikz-ed6bcc27a41a1f31f64986feebe225bab43d2792.svg" alt="Figure made with TikZ" /></p>
</div><p>Er vinden meerdere stappen van codering plaats in de keten. Broncodering, de eerste stap, is lijkt op kanaalcodering; broncodering heeft als doel de data zoveel mogelijk te comprimeren voordat het verzonden wordt, net als een bestandje zippen voordat je het e-mailt.
In andere woorden, de uitgang van de broncodering zal <strong>kleiner</strong> zijn dan de data ingang, maar de uitgang van kanaalcodering zal langer zijn dan de ingang want er is redundante informatie toegevoegd.</p>
</div>
<div class="section" id="typen-codes">
<h2>Typen Codes<a class="headerlink" href="#typen-codes" title="Permalink to this headline">¶</a></h2>
<p>Om kanaalcodering uit te voeren moeten we een “foutcorrectiecode” gebruiken.
Deze code vertelt ons, gegeven de te versturen bits, welke bits we echt moeten versturen.
De meest simpele vorm wordt een “herhalingscode” genoemd; we herhalen een bit N keer op een rij.
Voor een herhalings-3 code zouden we elk bit driemaal versturen:</p>
<ul class="simple">
<li>0 <span class="raw-html">&rarr;</span> 000</li>
<li>1 <span class="raw-html">&rarr;</span> 111</li>
</ul>
<p>Het bericht 10010110 wordt na de kanaalcodering dan verstuurt als 111000000111000111111000.</p>
<p>Sommige van de codes werken op blokken van bits terwijl anderen op een stroom van bits werken.
De codes die op blokken werken worden “blokcodes” genoemd, de codes die op stromen werken heten “convolutionele codes”. Dit zijn de twee primaire codes. Onze herhalings-3 code is een blokcode dat werkt op blokken van drie bits.</p>
<p>Trouwens, deze codes worden niet alleen voor draadloze kanalen gebruikt. Ooit eens data op een harde schijf of SSD gezet en afgevraagd waarom dat altijd goed gaat? Geheugen schrijven en dan lezen is vergelijkbaar met een communicatiesysteem. Harde schijf/SSD controllers hebben foutcorrectie ingebouwd. Dit is volledig onzichtbaar voor het OS omdat het in de controller zit ingebouwd. Cd-roms gebruikten de gestandaardiseerde Reed-Solomon codes.</p>
</div>
<div class="section" id="code-snelheid">
<h2>Code-snelheid<a class="headerlink" href="#code-snelheid" title="Permalink to this headline">¶</a></h2>
<p>Elke foutcorrectiecode bevat een vorm van redundantie. Dit betekent dat wanneer we 100 bits aan informatie willen versturen dat we eigenlijk <strong>meer dan</strong> 100 bits nodig hebben.
De snelheid is dan de verhouding tussen de informatie bits en het totale aantal bits dat is verzonden (dus informatie plus de redundante bits).
Als we teruggaan naar ons voorbeeld van herhaling-3, als ik 100 bits aan informatie verstuur, dan kunnen we de snelheid als volgt bepalen:</p>
<ul class="simple">
<li>300 bits worden verstuurt</li>
<li>Slechts 100 bits aan informatie</li>
<li>Code-snelheid = 100/300 = 1/3</li>
</ul>
<p>De code-snelheid zal altijd minder zijn dan 1; er is een afweging tussen redundantie en doorvoersnelheid.
Een lagere code-snelheid betekent meer redundantie maar minder doorvoer.</p>
</div>
<div class="section" id="modulatie-en-codering">
<h2>Modulatie en codering<a class="headerlink" href="#modulatie-en-codering" title="Permalink to this headline">¶</a></h2>
<p>In het <a class="reference internal" href="digital_modulation.html#modulation-chapter"><span class="std std-ref">Digitale Modulatie</span></a> hoofdstuk hebben we de invloed van ruis op modulatieschema’s bekeken. Bij een lage signaalruisverhouding heb je lager orde modulatieschema nodig (bijv. QPSK) om met de ruis om te kunnen gaan. Bij een hoge SNR kun je een schema als 256QAM toepassen om meer bits per seconden over te kunnen sturen. Kanaalcodering werkt hetzelfde; je wilt een lagere code-snelheid bij lage signaal-ruis verhoudingen en bij hoge signaal-ruis verhoudingen wil je een code-snelheid van bijna 1 gebruiken. Moderne communicatiesystemen hebben een combinaties van modulatie- en codeschema’s, MCS. Elke MCS specificeert een modulatie- plus codeschema wat bij een specifieke SNR gebruikt moet worden.</p>
<p>Moderne systemen passen de MCS real-time aan op basis van de draadloze kanaalcondities. De ontvanger geeft feedback aan de zender over de kanaalkwaliteit.
Deze feedback moet worden gegeven voordat de kwaliteit van het draadloze kanaal verandert, wat in ms kan gebeuren.
Deze adaptieve aanpak leidt tot de hoogste doorvoersnelheid mogelijk, en wordt gebruikt door moderne technologieën zoals LTE, 5G en wifi.
Hieronder zie je hoe een telefoontoren de MCS aanpast op basis van de afstand tot de gebruiker.</p>
<a class="reference external image-reference" href="../_images/adaptive_mcs.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/adaptive_mcs.svg" class="align-center" src="../_images/adaptive_mcs.svg" /></a>
<p>Wanneer de MCS wordt aangepast, als je dit uitzet tegenover de SNR, dan krijg je een stapvormige grafiek zoals het figuur hieronder. Protocollen zoals LTE hebben vaak een tabel wat aangeeft welke MCS gebruikt zou moeten worden bij welke SNR.</p>
<a class="reference external image-reference" href="../_images/adaptive_mcs2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/adaptive_mcs2.svg" class="align-center" src="../_images/adaptive_mcs2.svg" /></a>
</div>
<div class="section" id="hamming-code">
<h2>Hamming Code<a class="headerlink" href="#hamming-code" title="Permalink to this headline">¶</a></h2>
<p>Laten we eens kijken naar simpele foutcorrectiecodes. De Hamming-code was de eerste niet-triviale code dat werkt ontwikkeld.
Aan het einde van 1940, bij Bell Laboratories, werkte Richard Hamming met een elektromechanische computer die ponskaarten gebruikte.
Wanneer er fouten werden gevonden moest de computer stoppen en de bedienden moesten de kaarten repareren.
Hamming raakte gefrustreerd dat zijn programma telkens bij een fout opnieuw opgestart moest worden.
Hij zei, “Damn it, als de machine een fout kan detecteren, waarom kan hij de fout niet vinden en ongedaan maken?”.
De volgende paar jaren spendeerde hij om de Hamming-code te ontwikkelen die precies dat voor elkaar kreeg.</p>
<p>In Hamming-code worden extra bits toegevoegd, pariteits- of controlebits, om redundantie in te bouwen.
Alle bitposities op machten van 2 zijn pariteitsbits: 1,2,4,8, etc.
De andere bitposities bevatten de informatie.
De onderstaande tabel laat de pariteitsbits in het groen zien.
Elke pariteitsbit <img class="math" src="../_images/math/d40e7b990bb5ccef11dafe576c8a4a09db2f2e94.svg" alt="p_x"/> is <em>verantwoordelijk</em> voor alle databits <img class="math" src="../_images/math/b308654f1138a709981f592072d2fa209956f8eb.svg" alt="d_n"/> waarbij de bitpositie van de databits en de bitwise AND operatie met de pariteitsbit, een getal oplevert ongelijk aan 0.
Dit is met een rode X hieronder aangegeven.
Wanneer we dan een databit willen gebruiken, dan hebben we de pariteitsbits nodig die hier verantwoordelijk voor zijn.
Om databit <img class="math" src="../_images/math/860096af1bc6d8f83048dd8270590626186b352c.svg" alt="d_{11}"/> te gebruiken zouden we pariteitsbit <img class="math" src="../_images/math/7fdcc9d4554d3b87718322178254291595097e7e.svg" alt="p_8"/> ,en alle pariteitsbits die daarvoor kwamen, nodig hebben.
De tabel verteld ons dan hoeveel pariteitsbits we nodig hebben voor elke databit. Dit patroon gaat oneindig door.</p>
<a class="reference external image-reference" href="../_images/hamming.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/hamming.svg" class="align-center" src="../_images/hamming.svg" /></a>
<p>De hamming-code is een blokcode wat opereert op N databits per keer.
Met 3 pariteitsbits kunnen we opereren op een blok van 4 databits per keer.
Dit schema zouden we aangeven als Hamming(7,4), waarbij het eerste getal aangeeft hoeveel bits in totaal worden overgestuurd en het tweede getal hoeveel databits daarin zitten.</p>
<a class="reference external image-reference" href="../_images/hamming2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/hamming2.svg" class="align-center" src="../_images/hamming2.svg" /></a>
<p>Hier volgen belangrijke eigenschappen van de Hamming-code:</p>
<ul class="simple">
<li>Het kan een bitfout repareren</li>
<li>Het kan twee fouten detecteren maar niet repareren</li>
</ul>
<p>Het proces van databits coderen met de Hamming-code kan worden gaan door een matrixvermenigvuldiging uit te voeren met de “generator matrix”.
In het onderstaande voorbeeld is 1011 de databit-vector dat we willen coderen en naar de ontvanger sturen.
De 2D matrix is de “generator matrix” dat het codeschema definieert. Het resultaat van de vermenigvuldiging is een <em>code-woord</em> dat we willen versturen.</p>
<div class="math">
<p><img src="../_images/math/4c51db812fcdef8e8dc61ab65357dad5fdfa04d1.svg" alt="\vec{x}=\vec{a}G
=\begin{pmatrix}1&amp;0&amp;1&amp;1\end{pmatrix}
\begin{pmatrix}1&amp;0&amp;0&amp;0&amp;1&amp;1&amp;0\\0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;1\\0&amp;0&amp;1&amp;0&amp;0&amp;1&amp;1\\0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;1\end{pmatrix}
=\begin{pmatrix}1&amp;0&amp;1&amp;1&amp;2&amp;3&amp;2\end{pmatrix}
=\begin{pmatrix}1&amp;0&amp;1&amp;1&amp;0&amp;1&amp;0\end{pmatrix}"/></p>
</div><p>De laatste vector is verkregen door modulo-2 uit te voeren.
De reden waarom we even in Hamming-codes zijn gedoken is om te proeven hoe foutcodering werkt.
De blokcodes volgen ditzelfde concept.
Convolutionele codes werken anders, maar daar zullen we niet dieper op in gaan; meestal gebruiken ze Trellis-stijl decodering wat kan worden weergeven in zo’n soort diagram:</p>
<img alt="../_images/trellis.svg" class="align-center" src="../_images/trellis.svg" /></div>
<div class="section" id="soft-vs-hard-decodering">
<h2>Soft vs Hard Decodering<a class="headerlink" href="#soft-vs-hard-decodering" title="Permalink to this headline">¶</a></h2>
<p>Demodulatie gebeurt bij de ontvanger voor het decoderen. De demodulator kan zijn beste inschatting geven over welk symbool was verzonden, of het geeft een “zachte” waarde. Voor BPSK, in plaats van 1 of 0, zou het bijvoorbeeld 0.23345 of -1.75634 kunnen geven, of wat de zachte waarde ook was.
Er wordt nu onderscheid gemaakt tussen het hard of zacht decoderen:</p>
<ul class="simple">
<li><strong>zachte beslissingsdecodering</strong> – gebruik de zachte waarden</li>
<li><strong>Harde beslissingsdecodering</strong> – gebruikt alleen de 1’en en 0’en</li>
</ul>
<p>Zachte decodering is robuuster omdat we meer informatie tot onze beschikking hebben, maar tegelijkertijd is het ook complexer om te implementeren.
De Hamming-codes van eerder, gebruiken harde beslissingen, convolutionele codes gebruiken meestal zachte beslissingen.</p>
</div>
<div class="section" id="shannon-limiet">
<h2>Shannon Limiet<a class="headerlink" href="#shannon-limiet" title="Permalink to this headline">¶</a></h2>
<p>De limiet van Shannon, of de capaciteit van Shannon, is een ongelofelijk stuk theorie dat ons verteld hoeveel bits-per-seconde foutvrij kan worden verzonden:</p>
<div class="math">
<p><img src="../_images/math/64252d6abb25eef45398e28a159e06f80531a981.svg" alt="C = B \cdot log_2 \left( 1 + \frac{S}{N}   \right)"/></p>
</div><ul class="simple">
<li>C – Kanaalcapaciteit [bits/sec]</li>
<li>B – Bandbreedte kanaal [Hz]</li>
<li>S – Gemiddelde signaalvermogen ontvanger [Watt]</li>
<li>N – Gemiddelde ruisvermogen [Watt]</li>
</ul>
<p>Deze vergelijking geeft aan welke snelheid een MCS zou kunnen bereiken om zonder fouten data over te sturen bij een gegeven SNR.
Het zou iets logischer zijn om de limiet in bits/sec/Hz uit te drukken i.p.v. bits/sec per spectrumdeel:</p>
<div class="math">
<p><img src="../_images/math/baccf5717719d4baf9026eb75dad3377e7586ec3.svg" alt="\frac{C}{B} = log_2 \left( 1 + \mathrm{SNR}   \right)"/></p>
</div><p>Hierbij is de SNR lineair gegeven (niet dB).
Maar bij het plotten geven we voor het gemakt de SNR meestal wel in dB:</p>
<img alt="../_images/shannon_limit.svg" class="align-center" src="../_images/shannon_limit.svg" /><p>Soms wordt de Shannon-limiet weergeven met een x-as in “signaal/ruisenergie per bit” of <img class="math" src="../_images/math/047c5a05d03a18274f646f1a02b75c96bea3b71f.svg" alt="E_n/N_0"/>; dit is gewoon een alternatief voor SNR.</p>
<p>Het kan helpen om te beseffen dat wanneer de SNR vrij hoog is (bijv. boven de 10 dB) de Shannon-limiet benadert kan worden met <img class="math" src="../_images/math/2a73be06bb83e105c5fbe8c0f7bbb3eefdc57746.svg" alt="log_2 \left( \mathrm{SNR} \right)"/>, wat ongeveer gelijk is aan <img class="math" src="../_images/math/323369ba08410c0ddc520da937179ff76d808817.svg" alt="\mathrm{SNR_{dB}}/3"/> (<a class="reference external" href="https://en.wikipedia.org/wiki/Shannon%E2%80%93Hartley_theorem#Bandwidth-limited_case" rel="noopener noreferrer" target="_blank">(wordt hier uitgelegd)</a>).
Als je bijvoorbeeld een SNR hebt van 24 dB, dan komt dat overeen met ongeveer 8 bits/sec/Hz, dus als je 1 MHz moet gebruiken, dan geeft dat 8 Mbps.
Nu denk je misschien “Dat is alleen theoretisch”, maar moderne communicatiesystemen komen erg dicht bij die limiet, dus het geeft je tenminste een grove inschatting om naartoe te werken.
Je zou dat getal altijd kunnen halveren om rekening te houden met de overhead die pakketjes of frames introduceren en niet-ideale MCS.</p>
<p>De maximale snelheid dat 802.11n wifi kan halen in de 2.4 GHz band, met een kanaalbreedte van 20 MHz, is 300 Mbps volgens de specificaties.
Een optie om die snelheid te halen is om pal naast de router te gaan zitten.
In dit geval krijg je misschien een SNR van 60 dB, maar om praktische redenen heeft de snelste MCS waarschijnlijk niet zo’n hoge SNR nodig.
Je zou zelfs naar de <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_802.11n-2009#Data_rates" rel="noopener noreferrer" target="_blank">MCS lijst voor 802.11n</a> kunnen kijken.
802.11n gaat tot 64-QAM, gecombineerd met kanaalcodering heeft het een SNR van ongeveer 25 dB nodig volgens <a class="reference external" href="https://d2cpnw0u24fjm4.cloudfront.net/wp-content/uploads/802.11n-and-802.11ac-MCS-SNR-and-RSSI.pdf" rel="noopener noreferrer" target="_blank">deze tabel</a>.
Dat bekent dus dat zelfs bij 60 dB het wifi signaal nog steeds 64-QAM zal gebruiken.
Bij 25 dB is de Shannon-limiet ongeveer 8.3 bits/sec/Hz, dus 166 Mbps bij een bandbreedte van 20 MHz.
Als we ook rekening houden met MIMO, dit wordt later behandeld, dan krijgen we 4 64-QAM signalen tegelijkertijd met een totale snelheid van 664 Mbps.
Als we dat getal halveren dan komen we behoorlijk in de buurt van de 300 Mbps dat 802.11n wifi beloofd op de 2.4 GHz band.</p>
<p>Het bewijs achter de Shannon-limiet is best gestoord; dit heeft wiskunde wat hierop lijkt:</p>
<a class="reference internal image-reference" href="../_images/shannon_limit_proof.png"><img alt="../_images/shannon_limit_proof.png" class="align-center" src="../_images/shannon_limit_proof.png" style="width: 784.0px; height: 296.09999999999997px;" /></a>
<p>Kijk voor meer informatie <a class="reference external" href="https://en.wikipedia.org/wiki/Shannon%E2%80%93Hartley_theorem" rel="noopener noreferrer" target="_blank">hier</a>.</p>
</div>
<div class="section" id="state-of-the-art-codes">
<h2>State of the Art Codes<a class="headerlink" href="#state-of-the-art-codes" title="Permalink to this headline">¶</a></h2>
<p>Momenteel zijn de beste kanaalcoderingsschema’s:</p>
<ol class="arabic simple">
<li>Turbo codes, dit wordt gebruikt in 3G, 4G, NASA’s ruimtevaartuigen.</li>
<li>LDPC-codes, gebruikt in DVB-S2, WiMAX, IEEE 802.11n.</li>
</ol>
<p>Beide codes benaderen de Shannon-limiet (dus onder bepaalde signaalruisverhoudingen wordt de limiet bijna gehaald).
Hamming-codes of andere simpele codes komen niet eens in de buurt van de Shannon-limiet.
Voor wat betreft onderzoek valt er niet veel meer te halen in het verbeteren van de codes voor wat betreft toegevoegde overhead. Huidig onderzoek is meer gericht het verbeteren van het decoderen; minder rekenintensief maken en kunnen omgaan met kanaalfeedback.</p>
<p>Low-density parity-check (LDPC) codes zijn een groep van hele efficiënte lineaire blokcodes.
In 1960 werden deze codes geïntroduceerd door Robert G. Gallager in zijn doctoraat aan de MIT-universiteit.
Helaas waren deze codes zo rekenintensief dat het genegeerd werd tot de jaren 90!
Op het moment van schrijven (2022) is hij 91 en heeft hij vele prijzen gewonnen voor zijn werk (decennia nadat hij het had uitgevonden). LPDC heeft geen patenten en is daarom vrij te gebruiken (in tegenstelling tot Turbo-codes) en dat is de reden waarom het in vele open protocollen wordt toegepast.</p>
<p>Turbo-codes zijn convolutionair. Dit is een klasse codes dat gebruik maakt van twee of meerdere simpele convolutionele codes en een samenvoeger (interleaver).
De fundamentele patentaanvraag voor turbo-codes is van 23 April 1991.
De uitvinders waren Frans, en toen Qualcomm de turbo-codes wou toepassen in CDMA voor 3G moesten ze een licentieovereenkomst aangaan met de Franse Telecom.
Het eerste patent is verlopen op 29 Augustus 2013.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="link_budgets.html" title="Previous document"><span class="section-number">9. </span>Link Budgets</a>
        </li>
        <li>
          <a href="iq_files.html" title="Next document"><span class="section-number">11. </span>IQ Files and SigMF</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>