
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>10. Channel Coding &#8212; PySDR: A Guide to SDR and DSP using Python 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. IQ Files and SigMF" href="iq_files.html" />
    <link rel="prev" title="9. Link Budgets" href="link_budgets.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Frequency Domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digital Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Noise and dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">10. Channel Coding</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#why-we-need-channel-coding">Why We Need Channel Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#types-of-codes">Types of Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code-rate">Code-Rate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modulation-and-coding">Modulation and Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hamming-code">Hamming Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#soft-vs-hard-decoding">Soft vs Hard Decoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shannon-limit">Shannon Limit</a></li>
<li class="toctree-l2"><a class="reference internal" href="#state-of-the-art-codes">State of the Art Codes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronization</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">15. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="link_budgets.html" title="previous chapter"><span class="section-number">9. </span>Link Budgets</a></li>
      <li>Next: <a href="iq_files.html" title="next chapter"><span class="section-number">11. </span>IQ Files and SigMF</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="link_budgets.html" title="Previous document"><span class="section-number">9. </span>Link Budgets</a>
        </li>
        <li>
          <a href="iq_files.html" title="Next document"><span class="section-number">11. </span>IQ Files and SigMF</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="channel-coding">
<span id="channel-coding-chapter"></span><h1><span class="section-number">10. </span>Channel Coding<a class="headerlink" href="#channel-coding" title="Permalink to this headline">¶</a></h1>
<p>In this chapter we introduce the basics of channel coding, a.k.a. forward error correction (FEC), the Shannon Limit, Hamming codes, Turbo codes, and LDPC codes.  Channel coding is an enormous area within wireless communications, and is a branch of “information theory”, which is the study of the quantification, storage, and communication of information.</p>
<div class="section" id="why-we-need-channel-coding">
<h2>Why We Need Channel Coding<a class="headerlink" href="#why-we-need-channel-coding" title="Permalink to this headline">¶</a></h2>
<p>As we learned in the <a class="reference internal" href="noise.html#noise-chapter"><span class="std std-ref">Noise and dB</span></a> chapter, wireless channels are noisy, and our digital symbols won’t reach the receiver perfectly.  If you have taken a networking course, you may already know about cyclic redundancy checks (CRCs), which <strong>detect</strong> errors at the receiving end.  The purpose of channel coding is to detect <strong>and correct</strong> errors at the receiver.  If we allow some room for error, then we can transmit at a higher order modulation scheme, for example, without having a broken link.  As a visual example, consider the following constellations showing QPSK (left) and 16QAM (right) under the same amount of noise.  QPSK provides 2 bits per symbol, while 16QAM is twice the data rate at 4 bits per symbol.  But note how in the QPSK constellation that the symbols tend to not pass the symbol decision boundary, or the x-axis and y-axis, which means the symbols will be received correctly.  Meanwhile in the 16QAM plot, there is overlap in the clusters, and, as a result, there will be many incorrectly received symbols.</p>
<a class="reference internal image-reference" href="../_images/qpsk_vs_16qam.png"><img alt="../_images/qpsk_vs_16qam.png" class="align-center" src="../_images/qpsk_vs_16qam.png" style="width: 591.3000000000001px; height: 217.8px;" /></a>
<p>A failed CRC usually results in a retransmission, at least when using a protocol like TCP.  If Alice is sending a message to Bob, we would rather not have to make Bob send a message back to Alice requesting the information again.  The purpose of channel coding is to transmit <strong>redundant</strong> information. The redundancy is a failsafe that reduces the amount of erroneous packets, retransmissions, or dropped data.</p>
<p>We discussed why we need channel coding, so let’s see where it occurs in the transmit-receive chain:</p>
<a class="reference external image-reference" href="../_images/tx_rx_chain.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/tx_rx_chain.svg" class="align-center" src="../_images/tx_rx_chain.svg" /></a>
<p>Observe that there are multiple encoding steps in the transmit-receive chain. Source coding, our first step, is not the same as channel coding; source coding is meant to compress the data to be transmitted as much as possible, just like when you zip files to reduce the space taken.  Namely the output of the source encoding block should be <strong>smaller</strong> than the data input, but the output of channel encoding will be larger than its input because redundancy is added.</p>
</div>
<div class="section" id="types-of-codes">
<h2>Types of Codes<a class="headerlink" href="#types-of-codes" title="Permalink to this headline">¶</a></h2>
<p>To perform channel coding we use an “error correction code”.  This code tells us, given the bits we have to transmit, what bits do we actually transmit?  The most basic code is called “repetition coding”, and it’s when you simply repeat a bit N times in a row.  For repetition-3 code, one would transmit each bit three times:</p>
<ul class="simple">
<li>0 <span class="raw-html">&rarr;</span> 000</li>
<li>1 <span class="raw-html">&rarr;</span> 111</li>
</ul>
<p>The message 10010110 is transmitted as 111000000111000111111000 after channel encoding.</p>
<p>Some codes work on “blocks” of input bits, while others use a stream approach. Codes that work on blocks, data of a definite length, are called “Block Codes”, while codes that work on a stream of bits, where data length is arbitrary, are called “Convolutional Codes”.  These are the two primary types of codes.  Our repetition-3 code is a block code where each block is three bits.</p>
<p>As an aside, these error correction codes are not solely used in channel coding for wireless links.  Ever store information to a hard drive or SSD and wonder how there are never bit errors when reading information back off?  Writing, then reading, from memory is similar to a communication system.  Hard drive/SSD controllers have error correction built in. It’s transparent to the OS and can be proprietary since it’s all onboard the hard drive/SSD.  For portable media like CDs, the error correction must be standardized.  Reed-Solomon codes were common in CD-ROMs.</p>
</div>
<div class="section" id="code-rate">
<h2>Code-Rate<a class="headerlink" href="#code-rate" title="Permalink to this headline">¶</a></h2>
<p>All error correction includes some form of redundancy.  That means if we want to transmit 100 bits of information, we will have to actually send <strong>more than</strong> 100 bits.  “Code-rate” is the ratio between the number of information bits and the total number of bits sent (i.e., information plus redundancy bits).  Returning to the repetition-3 coding example, if I have 100 bits of information then we can determine the following:</p>
<ul class="simple">
<li>300 bits are sent</li>
<li>Only 100 bits represent information</li>
<li>Code-rate = 100/300 = 1/3</li>
</ul>
<p>The code-rate will always be less than 1, as there is a trade-off between redundancy and throughput.  A lower code-rate means more redundancy and less throughput.</p>
</div>
<div class="section" id="modulation-and-coding">
<h2>Modulation and Coding<a class="headerlink" href="#modulation-and-coding" title="Permalink to this headline">¶</a></h2>
<p>In the <a class="reference internal" href="digital_modulation.html#modulation-chapter"><span class="std std-ref">Digital Modulation</span></a> chapter we tackled noise in modulation schemes. At a low SNR you need a low-order modulation scheme (e.g., QPSK) to deal with the noise, and at a high SNR you can use modulation like 256QAM to get more bits per second.  Channel coding is the same; you want lower code-rates at low SNRs, and at high SNRs you can use a code-rate of almost 1.  Modern communications systems have a set of combined modulation and coding schemes, called MCS.  Each MCS specifies a modulation scheme and a coding scheme to be used at specific SNR levels.</p>
<p>Modern communications adaptively change the MCS in real-time based on the wireless channel conditions.  The receiver sends feedback about channel quality to the transmitter.  Feedback must be shared before the wireless channel quality changes, which could be on the order of ms.  This adaptive process leads to the highest throughput communications possible, and is used by modern technologies like LTE, 5G, and WiFi. Beneath is a visualization of a cell tower changing MCS during transmission as a user’s distance to the cell changes.</p>
<a class="reference external image-reference" href="../_images/adaptive_mcs.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/adaptive_mcs.svg" class="align-center" src="../_images/adaptive_mcs.svg" /></a>
<p>When using adaptive MCS, if you plot throughput over SNR, you get a staircase-shaped curve like the graph below.  Protocols like LTE often have a table indicating which MCS should be used at what SNR.</p>
<a class="reference external image-reference" href="../_images/adaptive_mcs2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/adaptive_mcs2.svg" class="align-center" src="../_images/adaptive_mcs2.svg" /></a>
</div>
<div class="section" id="hamming-code">
<h2>Hamming Code<a class="headerlink" href="#hamming-code" title="Permalink to this headline">¶</a></h2>
<p>Let’s look at a simple error correcting codes.  Hamming Code was the first non-trivial code developed.  In the late 1940’s Richard Hamming worked at Bell Labs, using an electromechanical computer that used punched paper tape.  When errors in the machine were detected, it would stop and operators would have to fix them. Hamming grew frustrated with having to restart his programs from scratch due to detected errors.  He said, “Damn it, if the machine can detect an error, why can’t it locate the position of the error and correct it?”  He spent the next few years developing the Hamming Code so the computer could do exactly that.</p>
<p>In Hamming Codes, extra bits, called parity bits or check bits, are added to information for redundancy.  All bit positions that are powers of two are parity bits: 1, 2, 4, 8, and etc. The other bit positions are for information. The table beneath this paragraph highlights parity bits in green.  Each parity bit “covers” all bits where the bitwise AND of the parity and the bit position is non-zero, marked with a red X below.  If we want to use a data bit, we need the parity bits that cover it.  To be able to go up to data bit d9, we need parity bit p8 and all the parity bits that come before it, so this table tells us how many parity bits we need for a certain number of bits.  This pattern continues indefinitely.</p>
<a class="reference external image-reference" href="../_images/hamming.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/hamming.svg" class="align-center" src="../_images/hamming.svg" /></a>
<p>Hamming codes are block codes so they operate on N data bits at a time.  So with three parity bits we can operate on blocks of four data bits at a time.  We represent this error encoding scheme as Hamming(7,4), where the first argument is the total bits transmitted and the second argument is the bits of data.</p>
<a class="reference external image-reference" href="../_images/hamming2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/hamming2.svg" class="align-center" src="../_images/hamming2.svg" /></a>
<p>The following are three important properties of Hamming codes:</p>
<ul class="simple">
<li>The minimal number of bit changes needed to go from any code word to any other code word is three</li>
<li>It can correct one-bit errors</li>
<li>It can detect but not correct two-bit errors</li>
</ul>
<p>Algorithmically, the coding process can be done using a simple matrix multiply, using what is called the “generator matrix”.  In the example below, the vector 1011 is the data to be encoded, i.e., the information we want to send to the receiver.  The 2D matrix is the generator matrix, and it defines the code scheme.  The result of the multiply provides the code word to transmit.</p>
<a class="reference internal image-reference" href="../_images/hamming3.png"><img alt="../_images/hamming3.png" class="align-center" src="../_images/hamming3.png" style="width: 720.0px; height: 108.0px;" /></a>
<p>The point of diving into Hamming codes was to give a taste of how error coding works.  Block codes tend to follow this type of pattern.  Convolutional codes work differently, but we won’t get into it here; they often use Trellis-style decoding, which can be displayed in a diagram that looks like this:</p>
<img alt="../_images/trellis.svg" class="align-center" src="../_images/trellis.svg" /></div>
<div class="section" id="soft-vs-hard-decoding">
<h2>Soft vs Hard Decoding<a class="headerlink" href="#soft-vs-hard-decoding" title="Permalink to this headline">¶</a></h2>
<p>Recall that at the receiver demodulation occurs before decoding.  The demodulator can tell us its best guess as to which symbol was sent, or it can output the “soft” value.  For BPSK, instead of telling us 1 or 0, the demodulator can say 0.3423 or -1.1234, whatever the “soft” value of the symbol was.  Typically the decoding is designed to use hard or soft values.</p>
<ul class="simple">
<li><strong>Soft decision decoding</strong> – uses the soft values</li>
<li><strong>Hard decision decoding</strong> – uses only the 1’s and 0’s</li>
</ul>
<p>Soft is more robust because you are using all of the information at your disposal, but soft is also much more complicated to implement.  The Hamming Codes we talked about used hard decisions, while convolutional codes tend to use soft.</p>
</div>
<div class="section" id="shannon-limit">
<h2>Shannon Limit<a class="headerlink" href="#shannon-limit" title="Permalink to this headline">¶</a></h2>
<p>The Shannon limit or Shannon capacity is an incredible piece of theory that tell us how many bits per second of error-free information we can send:</p>
<div class="math">
<p><img src="../_images/math/64252d6abb25eef45398e28a159e06f80531a981.svg" alt="C = B \cdot log_2 \left( 1 + \frac{S}{N}   \right)"/></p>
</div><ul class="simple">
<li>C – Channel capacity [bits/sec]</li>
<li>B – Bandwidth of channel [Hz]</li>
<li>S – Average received signal power [watts]</li>
<li>N – Average noise power [watts]</li>
</ul>
<p>This equation represents the best any MCS can do when operating at a high enough SNR to be error-free.  It makes more sense to plot the limit in bits/sec/Hz, i.e., bits/sec per amount of spectrum:</p>
<div class="math">
<p><img src="../_images/math/baccf5717719d4baf9026eb75dad3377e7586ec3.svg" alt="\frac{C}{B} = log_2 \left( 1 + \mathrm{SNR}   \right)"/></p>
</div><p>with SNR in linear terms (not dB).  However, when plotting it, we usually represent SNR in dB for convenience:</p>
<img alt="../_images/shannon_limit.svg" class="align-center" src="../_images/shannon_limit.svg" /><p>If you see Shannon limit plots elsewhere that look a little different, they are probably using an x-axis of “energy per bit” or <img class="math" src="../_images/math/0939b649ae229cc6f5075427efe1ffea03ae78d6.svg" alt="E_b/N_0"/>, which is just an alternative to working in SNR.</p>
<p>It might help simplify things to realize when the SNR is fairly high (e.g., 10 dB or higher), the Shannon limit can be approximated as <img class="math" src="../_images/math/2a73be06bb83e105c5fbe8c0f7bbb3eefdc57746.svg" alt="log_2 \left( \mathrm{SNR} \right)"/>, which is roughly <img class="math" src="../_images/math/323369ba08410c0ddc520da937179ff76d808817.svg" alt="\mathrm{SNR_{dB}}/3"/> (<a class="reference external" href="https://en.wikipedia.org/wiki/Shannon%E2%80%93Hartley_theorem#Bandwidth-limited_case" rel="noopener noreferrer" target="_blank">explained here</a>).  For example, at 24 dB SNR you’re looking at 8 bits/sec/Hz, so if you have 1 MHz to use, that’s 8 Mbps.  You might be thinking, “well that’s just the theoretical limit”, but modern communications get fairly close to that limit, so at a minimum it gives you a rough ballpark.  You can always cut that number in half to take into account packet/frame overhead and non-ideal MCS.</p>
<p>The max throughput of 802.11n WiFi operating in the 2.4 GHz band (which uses 20 MHz wide channels), according to the specs, is 300 Mbps.  Obviously you could sit right next to your router and get an extremely high SNR, maybe 60 dB, but to be reliable/practical the max throughput MCS (recall the staircase curve from above) is unlikely to require an SNR that high.  You can even take a look at the <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_802.11n-2009#Data_rates" rel="noopener noreferrer" target="_blank">MCS list for 802.11n</a>.  802.11n goes up to 64-QAM, and combined with channel coding, it requires a SNR around 25 dB according to <a class="reference external" href="https://d2cpnw0u24fjm4.cloudfront.net/wp-content/uploads/802.11n-and-802.11ac-MCS-SNR-and-RSSI.pdf" rel="noopener noreferrer" target="_blank">this table</a>.  That means, even at 60 dB SNR your WiFi will still use 64-QAM.  So at 25 dB the Shannon limit is roughly 8.3 bits/sec/Hz, which given 20 MHz of spectrum is 166 Mbps.  However, when you take into account MIMO, which we will cover in a future chapter, you can get four of those streams running in parallel, resulting in 664 Mbps.  Cut that number in half and you get something very close to the advertised max speed of 300 Mbps for 802.11n WiFi in the 2.4 GHz band.</p>
<p>The proof behind the Shannon limit is pretty crazy; it involves math that looks like this:</p>
<a class="reference internal image-reference" href="../_images/shannon_limit_proof.png"><img alt="../_images/shannon_limit_proof.png" class="align-center" src="../_images/shannon_limit_proof.png" style="width: 784.0px; height: 296.09999999999997px;" /></a>
<p>For more information see <a class="reference external" href="https://en.wikipedia.org/wiki/Shannon%E2%80%93Hartley_theorem" rel="noopener noreferrer" target="_blank">here</a>.</p>
</div>
<div class="section" id="state-of-the-art-codes">
<h2>State of the Art Codes<a class="headerlink" href="#state-of-the-art-codes" title="Permalink to this headline">¶</a></h2>
<p>Currently, the best channel coding schemes are:</p>
<ol class="arabic simple">
<li>Turbo codes, used in 3G, 4G, NASA’s spacecraft.</li>
<li>LDPC codes, used in DVB-S2, WiMAX, IEEE 802.11n.</li>
</ol>
<p>Both of these codes approach the Shannon limit (i.e., almost hit it under certain SNRs).  Hamming codes and other simpler codes get nowhere near the Shannon limit.  From a research point of view, there is not much room left to improve in terms of the codes themselves.  Current research is focusing more on making the decoding more computationally efficient and adaptive to channel feedback.</p>
<p>Low-density parity-check (LDPC) codes are a class of highly efficient linear block codes.  They were first introduced by Robert G. Gallager in his PhD dissertation in 1960 at MIT.  Due to the computational complexity in implementing them, they were ignored until the 1990’s!  He is 89 at the time of this writing (2020), is still alive, and has won many prizes for his work (decades after he did it).  LDPC is not patented and therefore free to use (unlike turbo codes), which is why it was used in many open protocols.</p>
<p>Turbo codes are based on convolutional codes.  It’s a class of code that combines two or more simpler convolutional codes and an interleaver.  The fundamental patent application for turbo codes was filed on April 23, 1991.  The inventors were French, so when Qualcomm wanted to use turbo codes in CDMA for 3G they had to create a fee-bearing patent license agreement with France Telecom.  The primary patent expired August 29, 2013.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="link_budgets.html" title="Previous document"><span class="section-number">9. </span>Link Budgets</a>
        </li>
        <li>
          <a href="iq_files.html" title="Next document"><span class="section-number">11. </span>IQ Files and SigMF</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>