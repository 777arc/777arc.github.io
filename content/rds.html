
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>15. End-to-End Example &#8212; PySDR: A Guide to SDR and DSP using Python 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="16. About the Author" href="about_author.html" />
    <link rel="prev" title="14. Synchronization" href="sync.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Frequency Domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digital Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Noise and dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Channel Coding</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronization</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">15. End-to-End Example</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-to-fm-radio-and-rds">Introduction to FM Radio and RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-rds-signal">The RDS Signal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#acquiring-a-signal">Acquiring a Signal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fm-demodulation">FM Demodulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#frequency-shift">Frequency Shift</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filter-to-isolate-rds">Filter to Isolate RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#decimate-by-10">Decimate by 10</a></li>
<li class="toctree-l2"><a class="reference internal" href="#resample-to-19-khz">Resample to 19 kHz</a></li>
<li class="toctree-l2"><a class="reference internal" href="#band-pass-filter">Band-Pass Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-synchronization-symbol-level">Time Synchronization (Symbol-Level)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fine-frequency-synchronization">Fine Frequency Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#demodulate-the-bpsk">Demodulate the BPSK</a></li>
<li class="toctree-l2"><a class="reference internal" href="#differential-decoding">Differential Decoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rds-decoding">RDS Decoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rds-parsing">RDS Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wrap-up-and-final-code">Wrap-Up and Final Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="sync.html" title="previous chapter"><span class="section-number">14. </span>Synchronization</a></li>
      <li>Next: <a href="about_author.html" title="next chapter"><span class="section-number">16. </span>About the Author</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="sync.html" title="Previous document"><span class="section-number">14. </span>Synchronization</a>
        </li>
        <li>
          <a href="about_author.html" title="Next document"><span class="section-number">16. </span>About the Author</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="end-to-end-example">
<span id="rds-chapter"></span><h1><span class="section-number">15. </span>End-to-End Example<a class="headerlink" href="#end-to-end-example" title="Permalink to this headline">¶</a></h1>
<p>In this chapter we bring together many of the concepts we previously learned about, and walk through a full example of receiving and decoding a real digital signal.  We will be looking at Radio Data System (RDS), which is a communications protocol for embedding small amounts of information in FM radio broadcasts, such as station and song name.  We will have to demodulate FM, frequency shift, filter, decimate, resample, synchronize, decode, and parse the bytes.  An example IQ file is provided for testing purposes or if you don’t have an SDR handy.</p>
<div class="section" id="introduction-to-fm-radio-and-rds">
<h2>Introduction to FM Radio and RDS<a class="headerlink" href="#introduction-to-fm-radio-and-rds" title="Permalink to this headline">¶</a></h2>
<p>To understand RDS we must first review FM radio broadcasts and how their signals are structured.  You are probably familiar with the audio portion of FM signals, which are simply audio signals frequency modulated and transmitted at center frequencies corresponding to the station’s name, e.g., “WPGC 95.5 FM” is centered at exactly 95.5 MHz.  In addition to the audio portion, each FM broadcast contains some other components that are frequency modulated along with the audio.  Instead of just Googling the signal structure, let’s take a look at the power spectral density (PSD) of an example FM signal, <em>after</em> the FM demodulation. We only view the positive portion because the output of FM demodulation is a real signal, even though the input was complex (we will view the code to perform this demodulation shortly).</p>
<a class="reference external image-reference" href="../_images/fm_psd.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fm_psd.svg" class="align-center" src="../_images/fm_psd.svg" /></a>
<p>By looking at the signal in the frequency domain, we notice the following individual signals:</p>
<ol class="arabic simple">
<li>A high power signal between 0 - 17 kHz</li>
<li>A tone at 19 kHz</li>
<li>Centered at 38 kHz and roughly 30 kHz wide we see an interesting looking symmetric signal</li>
<li>Double-lobe shaped signal centered at 57 kHz</li>
<li>Single-lobe shaped signal centered at 67 kHz</li>
</ol>
<p>This is essentially all we are able to determine by just looking at the PSD, and remember that this is <em>after</em> the FM demodulation.  The PSD before the FM demodulation looks like the following, which doesn’t really tell us much.</p>
<a class="reference external image-reference" href="../_images/fm_before_demod.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fm_before_demod.svg" class="align-center" src="../_images/fm_before_demod.svg" /></a>
<p>That being said, it’s important to understand that when you FM modulate a signal, a higher frequency in the data signal will lead to a higher frequency in the resulting FM signal.  So that signal centered at 67 kHz being present is increasing the total bandwidth occupied by the transmitted FM signal, as the maximum frequency component is now around 75 kHz as shown in the first PSD above.  <a class="reference external" href="https://en.wikipedia.org/wiki/Carson_bandwidth_rule" rel="noopener noreferrer" target="_blank">Carson’s bandwidth rule</a> applied to FM tells us that FM stations occupy roughly 250 kHz of spectrum, which is why we usually sample at 250 kHz (recall that when using quadrature/IQ sampling, your received bandwidth equals your sampling rate).</p>
<p>As a quick aside, some readers may be familiar with looking at the FM band using an SDR or spectrum analyzer and seeing the following spectrogram, and thinking that the block-y signals adjacent to some of the FM stations are RDS.</p>
<a class="reference internal image-reference" href="../_images/fm_band_psd.png"><img alt="../_images/fm_band_psd.png" class="align-center" src="../_images/fm_band_psd.png" style="width: 696.8000000000001px; height: 201.60000000000002px;" /></a>
<p>It turns out that those block-y signals are actually HD Radio, a digital version of the same FM radio signal (same audio content).  This digital version leads to a higher quality audio signal at the receiver because analog FM will always include some noise after demodulation, since it’s an analog scheme, but the digital signal can be demodulated/decoded with zero noise, assuming there are zero bit errors.</p>
<p>Back to the five signals we discovered in our PSD; the following diagram labels what each signal is used for.</p>
<a class="reference internal image-reference" href="../_images/fm_components.png"><img alt="../_images/fm_components.png" class="align-center" src="../_images/fm_components.png" style="width: 625.6px; height: 380.8px;" /></a>
<p>Going through each of these signals in no particular order:</p>
<p>The mono and stereo audio signals simply carry the audio signal, in a pattern where adding and subtracting them gives you the left and right channels.</p>
<p>The 19 kHz pilot tone is used to demodulate the stereo audio.  If you double the tone it acts as a frequency and phase reference, since the stereo audio signal is centered at 38 kHz.  Doubling the tone can be done by simply squaring the samples, recall the frequency shift Fourier property we learned about in the <a class="reference internal" href="frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Frequency Domain</span></a> chapter.</p>
<p>DirectBand was a North America wireless datacast network owned and operated by Microsoft, also called “MSN Direct” within consumer markets. DirectBand transmitted information to devices like portable GPS receivers, wristwatches, and home weather stations.  It even allowed users to receive short messages from Windows Live Messenger.  One of the most successful applications of DirectBand was realtime local traffic data displayed on Garmin GPS receivers, which were used by millions of people before smartphones became ubiquitous.  The DirectBand service was shut down on January 2012, which raises the question, why do we see it in our FM signal that was recorded after 2012?  My only guess is that most FM transmitters were designed and built way before 2012, and even without any DirectBand “feed” active, it still transmits something, perhaps pilot symbols.</p>
<p>Lastly, we come to RDS, which is the focus of the rest of this chapter.  As we can see in our first PSD, RDS is roughly 4 kHz in bandwidth (before it gets FM modulated), and sits in between the stereo audio and DirectBand signal.  It is a low data rate digital communications protocol that allows FM stations to include station identification, program information, time, and other miscellaneous information alongside the audio.  The RDS standard is published as IEC standard 62106 and can be <a class="reference external" href="http://www.interactive-radio-system.com/docs/EN50067_RDS_Standard.pdf" rel="noopener noreferrer" target="_blank">found here</a>.</p>
</div>
<div class="section" id="the-rds-signal">
<h2>The RDS Signal<a class="headerlink" href="#the-rds-signal" title="Permalink to this headline">¶</a></h2>
<p>In this chapter we will use Python to receive RDS, but in order to best understand how to receive it, we must first learn about how the signal is formed and transmitted.</p>
<div class="section" id="transmit-side">
<h3>Transmit Side<a class="headerlink" href="#transmit-side" title="Permalink to this headline">¶</a></h3>
<p>The RDS information to be transmitted by the FM station (e.g., track name, etc.) is encoded into sets of 8 bytes.  Each set of 8 bytes, which corresponds to 64 bits, is combined with 40 “check bits” to make a single “group”.  These 104 bits are transmitted together, although there is no gap of time between groups, so from the receiver’s perspective it receives these bits nonstop and must determine the boundary between the groups of 104 bits.   We will see more details on the encoding and message structure once we dive into the receive side.</p>
<p>To transmit these bits wirelessly, RDS uses BPSK, which as we learned in the <a class="reference internal" href="digital_modulation.html#modulation-chapter"><span class="std std-ref">Digital Modulation</span></a> chapter is a simple digital modulation scheme used to map 1’s and 0’s to the phase of a carrier.  Like many BPSK-based protocols, RDS uses differential coding, which simply means the 1’s and 0’s of data are encoded in changes of 1’s and 0’s instead, which lets you no longer care whether you are 180 degrees out of phase (more on this later).  The BPSK symbols are transmitted at 1187.5 symbols per second, and because BPSK carries one bit per symbol, that means RDS has a raw data rate of roughly 1.2 kbps (including overhead).  RDS does not contain any channel coding (a.k.a. forward error correction), although the data packets do contain a cyclic redundancy check (CRC) to know when an error occurred.   The experienced BPSK-er may be wondering why we saw a double-lobe shaped signal in the first PSD; BPSK usually has one main lobe.  It turns out RDS takes the BPSK signal and duplicates/mirrors it across the 57 kHz center frequency, for robustness through redundancy.  When we dive into the Python code used to receive RDS, one of our steps will involve filtering to isolate just one of these BPSK signals.</p>
<p>The final “double BPSK” signal is then frequency shifted up to 57 kHz and added to all the other components of the FM signal, before being FM modulated and transmitted over the air at the station’s frequency.  FM radio signals are transmitted at an extremely high power compared to most other wireless communications, up to 80 kW!  This is why many SDR users have an FM-reject filter (i.e., a band-stop filter) in-line with their antenna; so FM does not add interference to what they are trying to receive.</p>
<p>While this was only a brief overview of the transmit side, we will be diving into more details when we discuss receiving RDS.</p>
</div>
<div class="section" id="receive-side">
<h3>Receive Side<a class="headerlink" href="#receive-side" title="Permalink to this headline">¶</a></h3>
<p>In order to demodulate and decode RDS, we will perform the following steps, many of which are transmit-side steps in reverse (no need to memorize this list, we will walk through each step individually below):</p>
<ol class="arabic simple">
<li>Receive an FM radio signal centered at the station’s frequency (or read in an IQ recording), usually at a sample rate of 250 kHz</li>
<li>Demodulate the FM using what is called “quadrature demodulation”</li>
<li>Frequency shift by 57 kHz so the RDS signal is centered at 0 Hz</li>
<li>Low-pass filter, to filter out everything besides RDS</li>
<li>Decimate by 10 so that we can work at a lower sample rate, since we filtered out the higher frequencies anyway</li>
<li>Resample to 19 kHz which will give us an integer number of samples per symbol</li>
<li>Isolate one of the two RDS BPSK signals with a band-pass filter</li>
<li>Symbol-level time synchronization, using Mueller and Muller in this example</li>
<li>Fine frequency synchronization using a Costas loop</li>
<li>Demodulate the BPSK to 1’s and 0’s</li>
<li>Differential decoding, to undo the differential encoding that was applied</li>
<li>Decoding of the 1’s and 0’s into groups of bytes</li>
<li>Parsing of the groups of bytes into our final output</li>
</ol>
<p>While this may seem like a lot of steps, RDS is actually one of the simplest wireless digital communications protocols out there.  A modern wireless protocol like WiFi or 5G requires a whole textbook to cover just the high-level PHY/MAC layer information.</p>
<p>We will now dive into the Python code used to receive RDS.  This code has been tested to work using an <a class="reference external" href="https://github.com/777arc/498x/blob/master/fm_rds_250k_1Msamples.iq?raw=true" rel="noopener noreferrer" target="_blank">FM radio recording you can find here</a>, although you should be able to feed in your own signal as long as its received at a high enough SNR, simply tune to the station’s center frequency and sample at a rate of 250 kHz.  In this section we will present small portions of the code individually, with discussion, but the same code is provided at the end of this chapter in one large block.  Each section will present a block of code, and then explain what it is doing.</p>
</div>
</div>
<div class="section" id="acquiring-a-signal">
<h2>Acquiring a Signal<a class="headerlink" href="#acquiring-a-signal" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">resample_poly</span><span class="p">,</span> <span class="n">firwin</span><span class="p">,</span> <span class="n">bilinear</span><span class="p">,</span> <span class="n">lfilter</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Read in signal</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;/home/marc/Downloads/fm_rds_250k_1Msamples.iq&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">250e3</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">99.5e6</span>
</pre></div>
</div>
<p>We read in our test recording, which was sampled at 250 kHz and centered on an FM station received at a high SNR.  Make sure to update the file path to reflect your system and where you saved the recording.  If you have an SDR already set up and working from within Python, feel free to receive a live signal, although it helps to have first tested the entire code with a <a class="reference external" href="https://github.com/777arc/498x/blob/master/fm_rds_250k_1Msamples.iq?raw=true" rel="noopener noreferrer" target="_blank">known-to-work IQ recording</a>.  Throughout this code we will use <code class="code docutils literal notranslate"><span class="pre">x</span></code> to store the current signal being manipulated.</p>
</div>
<div class="section" id="fm-demodulation">
<h2>FM Demodulation<a class="headerlink" href="#fm-demodulation" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Quadrature Demod</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="c1"># see https://wiki.gnuradio.org/index.php/Quadrature_Demod</span>
</pre></div>
</div>
<p>As discussed at the beginning of this chapter, several individual signals are combined in frequency and FM modulated to create what is actually transmitted through the air.  So the first step is to undo that FM modulation.  Another way to think about it is the information is stored in the frequency variation of the signal we receive, and we want to demodulate it so the information is now in the amplitude not frequency.  Note that the output of this demodulation is a real signal, even though we fed in a complex signal.</p>
<p>What this single line of Python is doing, is first calculating the product of our signal with a delayed and conjugated version of our signal.  Next, it finds the phase of each sample in that result, which is the moment at which it goes from complex to real.  To prove to ourselves that this gives us the information contained in the frequency variations, consider a tone at frequency <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> with some arbitrary phase <img class="math" src="../_images/math/f41d2a61cd1827c3e57537176609abab588ccc27.svg" alt="\phi"/>, which we can represent as <img class="math" src="../_images/math/aeac5aa1d2208522259f5d0cd24b363631ecce9a.svg" alt="e^{j2 \pi (f t + \phi)}"/>.  When dealing in discrete time, which uses an integer <img class="math" src="../_images/math/f7a9f3c7a45b9df2dac17c2a197dd82e66e4a44a.svg" alt="n"/> instead of <img class="math" src="../_images/math/de24e9d9b4f685051e7f51c8931d4f7f53a37457.svg" alt="t"/>, this becomes <img class="math" src="../_images/math/607c18b46862d6504e95efda4552d5a4a9346485.svg" alt="e^{j2 \pi (f n + \phi)}"/>.  The conjugated and delayed version is <img class="math" src="../_images/math/ed969a9f9a6f32e3a84981843e060acfd3d09bea.svg" alt="e^{-j2 \pi (f (n-1) + \phi)}"/>.  Multiplying these two together leads to <img class="math" src="../_images/math/4c10af995bdc4051fc71891f029058db0b888e64.svg" alt="e^{j2 \pi f}"/>, which is great because <img class="math" src="../_images/math/f41d2a61cd1827c3e57537176609abab588ccc27.svg" alt="\phi"/> is gone, and when we calculate the phase of that expression we are left with just <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/>.</p>
<p>One convenient side effect of FM modulation is that amplitude variations of the received signal does not actually change the volume of the audio, unlike AM radio.</p>
</div>
<div class="section" id="frequency-shift">
<h2>Frequency Shift<a class="headerlink" href="#frequency-shift" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Freq shift</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">f_o</span> <span class="o">=</span> <span class="o">-</span><span class="mf">57e3</span> <span class="c1"># amount we need to shift by</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># time vector</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f_o</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># down shift</span>
</pre></div>
</div>
<p>Next we frequency shift down by 57 kHz, using the <img class="math" src="../_images/math/75b1957b6af6705b15dad8edeed42a40232645cb.svg" alt="e^{j2 \pi f_ot}"/> trick we learned in the <a class="reference internal" href="sync.html#sync-chapter"><span class="std std-ref">Synchronization</span></a> chapter where <code class="code docutils literal notranslate"><span class="pre">f_o</span></code> is the frequency shift in Hz and <code class="code docutils literal notranslate"><span class="pre">t</span></code> is just a time vector, the fact it starts at 0 isn’t important, what matters is that it uses the right sample period (which is inverse of sample rate).  As an aside, because it’s a real signal being fed in, it doesn’t actually matter if you use a -57 or +57 kHz because the negative frequencies match the positive, so either way we are going to get our RDS shifted to 0 Hz.</p>
</div>
<div class="section" id="filter-to-isolate-rds">
<h2>Filter to Isolate RDS<a class="headerlink" href="#filter-to-isolate-rds" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Low-Pass Filter</span>
<span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">7.5e3</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we must filter out everything besides RDS. Since we have RDS centered at 0 Hz, that means a low-pass filter is the one we want.  We use <code class="code docutils literal notranslate"><span class="pre">firwin()</span></code> to design an FIR filter (i.e., find the taps), which just needs to know how many taps we want the filter to be, and the cutoff frequency.  The sample rate must also be provided or else the cutoff frequency doesn’t make sense to firwin.  The result is a symmetric low-pass filter, so we know the taps are going to be real numbers, and we can apply the filter to our signal using a convolution.  We choose <code class="code docutils literal notranslate"><span class="pre">'valid'</span></code> to get rid of the edge effects of doing convolution, although in this case it doesn’t really matter because we are feeding in such a long signal that a few weird samples on either edge isn’t going to throw anything off.</p>
</div>
<div class="section" id="decimate-by-10">
<h2>Decimate by 10<a class="headerlink" href="#decimate-by-10" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Decimate by 10, now that we filtered and there wont be aliasing</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="mi">10</span><span class="p">]</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">25e3</span>
</pre></div>
</div>
<p>Any time you filter down to a small fraction of your bandwidth (e.g., we started with 125 kHz of <em>real</em> bandwidth and saved only 7.5 kHz of that), it makes sense to decimate.  Recall the beginning of the <a class="reference internal" href="sampling.html#sampling-chapter"><span class="std std-ref">IQ Sampling</span></a> chapter where we learned about the Nyquist Rate and being able to fully store band-limited information as long as we sampled at twice the highest frequency. Well now that we used our low-pass filter, our highest frequency is about 7.5 kHz, so we only need a sample rate of 15 kHz.  Just to be safe we’ll add some margin and use a new sample rate of 25 kHz (this ends up working well mathematically later on).</p>
<p>We perform the decimation by simply throwing out 9 out of every 10 samples, since we previously were at a sample rate of 250 kHz and we want it to now be at 25 kHz.  This might seem confusing at first, because throwing out 90% of the samples feels like you are throwing out information, but if you review the <a class="reference internal" href="sampling.html#sampling-chapter"><span class="std std-ref">IQ Sampling</span></a> chapter you will see why we are not actually losing anything, because we filtered properly (which acted as our anti-aliasing filter) and reduced our maximum frequency and thus signal bandwidth.</p>
<p>From a code perspective this is probably the simplest step out of them all, but make sure to update your <code class="code docutils literal notranslate"><span class="pre">sample_rate</span></code> variable to reflect the new sample rate.</p>
</div>
<div class="section" id="resample-to-19-khz">
<h2>Resample to 19 kHz<a class="headerlink" href="#resample-to-19-khz" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Resample to 19kHz</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="c1"># up, down</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">19e3</span>
</pre></div>
</div>
<p>In the <a class="reference internal" href="pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a> chapter we solidified the concept of “samples per symbol”, and learned the convenience of having an integer number of samples per symbol (a fractional value is valid, just not convenient).  As mentioned earlier, RDS uses BPSK transmitting 1187.5 symbols per second.  If we continue to use our signal as-is, sampled at 25 kHz, we’ll have 21.052631579 samples per symbol (pause and think about the math if that doesn’t make sense).  So what we really want is a sample rate that is an integer multiple of 1187.5 Hz, but we can’t go too low or we won’t be able to “store” our full signal’s bandwidth.  In the previous subsection we talked about how we need a sample rate of 15 kHz or higher, and we chose 25 kHz just to give us some margin.</p>
<p>Finding the best sample rate to resample to comes down to how many samples per symbol we want, and we can work backwards.  Hypothetically, let us consider targeting 10 samples per symbol.  The RDS symbol rate of 1187.5 multiplied by 10 would give us a sample rate of 11.875 kHz, which unfortunately is not high enough for Nyquist.  How about 13 samples per symbol?  1187.5 multiplied by 13 gives us 15437.5 Hz, which is above 15 kHz, but quite the uneven number.  How about the next power of 2, so 16 samples per symbol?  1187.5 multiplied by 16 is exactly 19 kHz!  The even number is less of a coincidence and more of a protocol design choice.</p>
<p>To resample from 25 kHz to 19 kHz, we use <code class="code docutils literal notranslate"><span class="pre">resample_poly()</span></code> which upsamples by an integer value, filters, then downsamples by an integer value.  This is convenient because instead of entering in 25000 and 19000 we can use 25 and 19.  If we had used 13 samples per symbol by using a sample rate of 15437.5 Hz, we wouldn’t be able to use <code class="code docutils literal notranslate"><span class="pre">resample_poly()</span></code> and the resampling process would be much more complicated.</p>
<p>Once again, always remember to update your <code class="code docutils literal notranslate"><span class="pre">sample_rate</span></code> variable when performing an operation that changes it.</p>
</div>
<div class="section" id="band-pass-filter">
<h2>Band-Pass Filter<a class="headerlink" href="#band-pass-filter" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Bandpass filter to isolate one RDS BPSK signal</span>
<span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="mi">501</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="p">[</span><span class="mf">0.05e3</span><span class="p">,</span> <span class="mf">2e3</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Recall that RDS contains two identical BPSK signals, hence the shape we saw in the PSD at the beginning.  We have to choose one, so we will arbitrarily decide to keep the positive one with a band-pass filter.  We use <code class="code docutils literal notranslate"><span class="pre">firwin()</span></code> again, but note the <code class="code docutils literal notranslate"><span class="pre">pass_zero=False</span></code> which is how you indicate you want it to be a band-pass filter instead of low-pass, and there are two cutoff frequencies to define the band.  The signal is from roughly 0 Hz to 2 kHz but you can’t specify a 0 Hz starting frequency so we use 0.05 kHz.  Lastly, we need to increase our number of taps, to get a steeper frequency response.  We can verify that these numbers worked by looking at our filter in the time domain (by plotting taps) and frequency domain (by taking FFT of taps).  Note how in the frequency domain, we reach near-zero response at about 0 Hz.</p>
<a class="reference external image-reference" href="../_images/bandpass_filter_taps.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/bandpass_filter_taps.svg" class="align-center" src="../_images/bandpass_filter_taps.svg" /></a>
<a class="reference external image-reference" href="../_images/bandpass_filter_freq.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/bandpass_filter_freq.svg" class="align-center" src="../_images/bandpass_filter_freq.svg" /></a>
<p>Side note: At some point I will update the filter above to use a proper matched filter (root-raised cosine I believe is what RDS uses), for conceptual sake, but I got the same error rates using the firwin() approach as GNU Radio’s proper matched filter, so it’s clearly not a strict requirement.</p>
</div>
<div class="section" id="time-synchronization-symbol-level">
<h2>Time Synchronization (Symbol-Level)<a class="headerlink" href="#time-synchronization-symbol-level" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Symbol sync, using what we did in sync chapter</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># for the sake of matching the sync chapter</span>
<span class="n">samples_interpolated</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">sps</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># initial estimate of phase of sample</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">out_rail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span> <span class="c1"># stores values, each iteration we need the previous 2 values plus current value</span>
<span class="n">i_in</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># input samples index</span>
<span class="n">i_out</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># output index (let first two outputs be 0)</span>
<span class="k">while</span> <span class="n">i_out</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i_in</span><span class="o">*</span><span class="mi">16</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_interpolated</span><span class="p">[</span><span class="n">i_in</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="mi">16</span><span class="p">)]</span> <span class="c1"># grab what we think is the &quot;best&quot; sample</span>
    <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">+=</span> <span class="n">sps</span> <span class="o">+</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">mm_val</span>
    <span class="n">i_in</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="c1"># round down to nearest int since we are using it as an index</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="c1"># remove the integer part of mu</span>
    <span class="n">i_out</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># increment output index</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">i_out</span><span class="p">]</span> <span class="c1"># remove the first two, and anything after i_out (that was never filled out)</span>
</pre></div>
</div>
<p>We are finally ready for our symbol/time synchronization, here we will use the exact same Mueller and Muller clock synchronization code from the <a class="reference internal" href="sync.html#sync-chapter"><span class="std std-ref">Synchronization</span></a> chapter, reference it if you want to learn more about how it works.  We set the sample per symbol (<code class="code docutils literal notranslate"><span class="pre">sps</span></code>) to 16 as discussed earlier.  A mu gain value of 0.01 was found via experimentation to work well.  The output should now be one sample per symbol, i.e., our output is our “soft symbols”, with possible frequency offset included.  The following constellation plot animation is used to verify we are getting BPSK symbols (with a frequency offset causing rotation):</p>
<a class="reference internal image-reference" href="../_images/constellation-animated.gif"><img alt="../_images/constellation-animated.gif" class="align-center" src="../_images/constellation-animated.gif" style="width: 409.6px; height: 307.20000000000005px;" /></a>
<p>If you are using your own FM signal and are not getting two distinct clusters of complex samples at this point, it means either the symbol sync above failed to achieve sync, or there is something wrong with one of the previous steps.  You don’t need to animate the constellation, but if you plot it, make sure to avoid plotting all the samples, because it will just look like a circle.  If you plot only 100 or 200 samples at a time, you will get a better feel for whether they are in two clusters or not, even if they are spinning.</p>
</div>
<div class="section" id="fine-frequency-synchronization">
<h2>Fine Frequency Synchronization<a class="headerlink" href="#fine-frequency-synchronization" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Fine freq sync</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># for the sake of matching the sync chapter</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># These next two params is what to adjust, to make the feedback loop faster or slower (which impacts stability)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">8.0</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.002</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">freq_log</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="c1"># adjust the input sample by the inverse of the estimated phase offset</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># This is the error formula for 2nd order Costas Loop (e.g. for BPSK)</span>

    <span class="c1"># Advance the loop (recalc phase and freq offset)</span>
    <span class="n">freq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">freq_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="c1"># convert from angular velocity to Hz for logging</span>
    <span class="n">phase</span> <span class="o">+=</span> <span class="n">freq</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>

    <span class="c1"># Optional: Adjust phase so its always between 0 and 2pi, recall that phase wraps around every 2pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">out</span>
</pre></div>
</div>
<p>We will also copy the fine frequency synchronization Python code from the <a class="reference internal" href="sync.html#sync-chapter"><span class="std std-ref">Synchronization</span></a> chapter, which uses a Costas loop to remove any residual frequency offset, as well as align our BPSK to the real (I) axis, by forcing Q to be as close to zero as possible.  Anything left in Q is likely due to the noise in the signal, assuming the Costas loop was tuned properly.  Just for fun let’s view the same animation as above except after the frequency synchronization has been performed (no more spinning!):</p>
<a class="reference internal image-reference" href="../_images/constellation-animated-postcostas.gif"><img alt="../_images/constellation-animated-postcostas.gif" class="align-center" src="../_images/constellation-animated-postcostas.gif" style="width: 409.6px; height: 307.20000000000005px;" /></a>
<p>Additionally, we can look at the estimated frequency error over time to see the Costas loop working, note how we logged it in the code above.  It appears that there was about 13 Hz of frequency offset, either due to the transmitter’s oscillator/LO being off or the receiver’s LO (most likely the receiver).  If you are using your own FM signal, you may need to tweak <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="code docutils literal notranslate"><span class="pre">beta</span></code> until the curve looks similar, it should achieve synchronization fairly quickly (e.g., a few hundred symbols) and maintain it with minimal oscillation.  The pattern you see below after it finds its steady state is frequency jitter, not oscillation.</p>
<a class="reference internal image-reference" href="../_images/freq_error.png"><img alt="../_images/freq_error.png" class="align-center" src="../_images/freq_error.png" style="width: 442.0px; height: 292.40000000000003px;" /></a>
</div>
<div class="section" id="demodulate-the-bpsk">
<h2>Demodulate the BPSK<a class="headerlink" href="#demodulate-the-bpsk" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Demod BPSK</span>
<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># 1&#39;s and 0&#39;s</span>
</pre></div>
</div>
<p>Demodulating the BPSK at this point is very easy, recall that each sample represents one soft symbol, so all we have to do is check whether each sample is above or below 0.  The <code class="code docutils literal notranslate"><span class="pre">.astype(int)</span></code> is just so we can work with an array of ints instead of an array of bools.  You may wonder whether above/below zero represents a 1 or 0.  As you will see in the next step, it doesn’t matter!</p>
</div>
<div class="section" id="differential-decoding">
<h2>Differential Decoding<a class="headerlink" href="#differential-decoding" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Differential decoding, so that it doesn&#39;t matter whether our BPSK was 180 degrees rotated without us realizing it</span>
<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="c1"># for decoder</span>
</pre></div>
</div>
<p>The BPSK signal used differential coding when it was created, which means that each 1 and 0 of the original data was transformed such that a change from 1 to 0 or 0 to 1 got mapped to a 1, and no change got mapped to a 0.  The nice benefit of using differential coding is so you don’t have to worry about 180 degree rotations in receiving the BPSK, because whether we consider a 1 to be greater than zero or less than zero is no longer an impact, what matters is changing between 1 and 0.  This concept might be easier to understand by looking at example data, below shows the first 10 symbols before and after the differential decoding:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># before differential decoding</span>
<span class="p">[</span><span class="o">-</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># after differential decoding</span>
</pre></div>
</div>
</div>
<div class="section" id="rds-decoding">
<h2>RDS Decoding<a class="headerlink" href="#rds-decoding" title="Permalink to this headline">¶</a></h2>
<p>We finally have our bits of information, and we are ready to decode what they mean!  The massive block of code provided below is what we will use to decode the 1’s and 0’s into groups of bytes.  This part would make a lot more sense if we first created the transmitter portion of RDS, but for now just know that in RDS, bytes are grouped into groups of 12 bytes, where the first 8 represent the data and the last 4 act as a sync word (called “offset words”).  The last 4 bytes are not needed by the next step (the parser) so we don’t include them in the output.  This block of code takes in the 1’s and 0’s created above (in the form of a 1D array of uint8’s) and outputs a list of lists of bytes (a list of 8 bytes where those 8 bytes are in a list).  This makes it convenient for the next step, which will iterate through the list of 8 bytes, one group of 8 at a time.</p>
<p>Most of the actual decoding code below revolves around syncing (at the byte level, not symbol) and error checking.  It works in blocks of 104 bits, each block is either received correctly or in error (using CRC to check), and every 50 blocks it checks whether more than 35 of them were received with error, in which case it resets everything and attempts to sync again.  The CRC is performed using a 10-bit check, with polynomial <img class="math" src="../_images/math/721b9d55493e992ca626c983d273b567a24c1ae5.svg" alt="x^{10}+x^8+x^7+x^5+x^4+x^3+1"/>; this occurs when <code class="code docutils literal notranslate"><span class="pre">reg</span></code> is xor’ed with 0x5B9 which is the binary equivalent of that polynomial.  In Python, the bitwise operators for [and, or, not, xor] are <code class="code docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">|</span> <span class="pre">~</span> <span class="pre">^</span></code> respectively, exactly the same as C++. A left bit shift is <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">y</span></code> (same as multiplying x by 2**y), and a right bit shift is <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> (same as dividing x by 2**y), also like in C++.</p>
<p>Note, you <strong>do not</strong> need to go through all of this code, or any of it, especially if you are focusing on learning the physical (PHY) layer side of DSP and SDR, as this does <em>not</em> represent signal processing.  This code is simply an implementation of a RDS decoder, and essentially none of it can be reused for other protocols, because it’s so specific to the way RDS works.  If you are already somewhat exhausted by this chapter, feel free to just skip this enormous block of code that has one fairly simple job but does it in a complex manner.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Constants</span>
<span class="n">syndrome</span> <span class="o">=</span> <span class="p">[</span><span class="mi">383</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">303</span><span class="p">,</span> <span class="mi">663</span><span class="p">,</span> <span class="mi">748</span><span class="p">]</span>
<span class="n">offset_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">offset_word</span> <span class="o">=</span> <span class="p">[</span><span class="mi">252</span><span class="p">,</span> <span class="mi">408</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">436</span><span class="p">,</span> <span class="mi">848</span><span class="p">]</span>

<span class="c1"># see Annex B, page 64 of the standard</span>
<span class="k">def</span> <span class="nf">calc_syndrome</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
    <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">plen</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)):</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">^</span> <span class="mh">0x5B9</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)):</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">^</span> <span class="mh">0x5B9</span>
    <span class="k">return</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># select the bottom plen bits of reg</span>

<span class="c1"># Initialize all the working vars we&#39;ll need during the loop</span>
<span class="n">synced</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">group_good_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># was unsigned long in C++ (64 bits) but numpy doesn&#39;t support bitwise ops of uint64, I don&#39;t think it gets that high anyway</span>
<span class="n">lastseen_offset_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lastseen_offset</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># the synchronization process is described in Annex C, page 66 of the standard */</span>
<span class="n">bytes_out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)):</span>
    <span class="c1"># in C++ reg doesn&#39;t get init so it will be random at first, for ours its 0s</span>
    <span class="c1"># It was also an unsigned long but never seemed to get anywhere near the max value</span>
    <span class="c1"># bits are either 0 or 1</span>
    <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># reg contains the last 26 rds bits. these are both bitwise ops</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">synced</span><span class="p">:</span>
        <span class="n">reg_syndrome</span> <span class="o">=</span> <span class="n">calc_syndrome</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reg_syndrome</span> <span class="o">==</span> <span class="n">syndrome</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">presync</span><span class="p">:</span>
                    <span class="n">lastseen_offset</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">lastseen_offset_counter</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">presync</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">block_distance</span> <span class="o">=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">block_distance</span> <span class="o">=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">block_distance</span><span class="o">*</span><span class="mi">26</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">lastseen_offset_counter</span><span class="p">):</span>
                        <span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sync State Detected&#39;</span><span class="p">)</span>
                        <span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">block_bit_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">block_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
                        <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">synced</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span> <span class="c1"># syndrome found, no more cycles</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># SYNCED</span>
        <span class="c1"># wait until 26 bits enter the buffer */</span>
        <span class="k">if</span> <span class="n">block_bit_counter</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">:</span>
            <span class="n">block_bit_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dataword</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span>
            <span class="n">block_calculated_crc</span> <span class="o">=</span> <span class="n">calc_syndrome</span><span class="p">(</span><span class="n">dataword</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
            <span class="n">checkword</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span>
            <span class="k">if</span> <span class="n">block_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># manage special case of C or C&#39; offset word</span>
                <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="n">block_number</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">):</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">):</span>
                        <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">wrong_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="n">block_number</span><span class="p">]</span> <span class="c1"># bitwise xor</span>
                <span class="k">if</span> <span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">:</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wrong_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Done checking CRC</span>
            <span class="k">if</span> <span class="n">block_number</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">good_block</span><span class="p">:</span>
                <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">group_good_blocks_counter</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="nb">bytes</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># 8 bytes filled with 0s</span>
            <span class="k">if</span> <span class="n">group_assembly_started</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">good_block</span><span class="p">:</span>
                    <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># raw data bytes, as received from RDS. 8 info bytes, followed by 4 RDS offset chars: ABCD/ABcD/EEEE (in US) which we leave out here</span>
                    <span class="c1"># RDS information words</span>
                    <span class="c1"># block_number is either 0,1,2,3 so this is how we fill out the 8 bytes</span>
                    <span class="nb">bytes</span><span class="p">[</span><span class="n">block_number</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataword</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span>
                    <span class="nb">bytes</span><span class="p">[</span><span class="n">block_number</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataword</span> <span class="o">&amp;</span> <span class="mi">255</span>
                    <span class="n">group_good_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1">#print(&#39;group_good_blocks_counter:&#39;, group_good_blocks_counter)</span>
                <span class="k">if</span> <span class="n">group_good_blocks_counter</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="c1">#print(bytes)</span>
                    <span class="n">bytes_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span> <span class="c1"># list of len-8 lists of bytes</span>
            <span class="n">block_bit_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">block_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
            <span class="n">blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">blocks_counter</span> <span class="o">==</span> <span class="mi">50</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">wrong_blocks_counter</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">:</span> <span class="c1"># This many wrong blocks must mean we lost sync</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lost Sync (Got &quot;</span><span class="p">,</span> <span class="n">wrong_blocks_counter</span><span class="p">,</span> <span class="s2">&quot; bad blocks on &quot;</span><span class="p">,</span> <span class="n">blocks_counter</span><span class="p">,</span> <span class="s2">&quot; total)&quot;</span><span class="p">)</span>
                    <span class="n">synced</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Still Sync-ed (Got &quot;</span><span class="p">,</span> <span class="n">wrong_blocks_counter</span><span class="p">,</span> <span class="s2">&quot; bad blocks on &quot;</span><span class="p">,</span> <span class="n">blocks_counter</span><span class="p">,</span> <span class="s2">&quot; total)&quot;</span><span class="p">)</span>
                <span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Below shows an example output from this decoding step, note how in this example it synced fairly quickly but then loses sync a couple times for some reason, although it’s still able to parse all of the data as we’ll see.  If you are using the downloadable 1M samples file, you will only see the first few lines below.  The actual contents of these bytes just look like random numbers/characters depending on how you display them, but in the next step we will parse them into human readable information!</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Sync State Detected</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  1  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  5  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  26  bad blocks on  50  total)</span>
<span class="go">Lost Sync (Got  50  bad blocks on  50  total)</span>
<span class="go">Sync State Detected</span>
<span class="go">Still Sync-ed (Got  3  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  0  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  2  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  1  bad blocks on  50  total)</span>
<span class="go">Still Sync-ed (Got  20  bad blocks on  50  total)</span>
<span class="go">Lost Sync (Got  47  bad blocks on  50  total)</span>
<span class="go">Sync State Detected</span>
<span class="go">Still Sync-ed (Got  32  bad blocks on  50  total)</span>
</pre></div>
</div>
</div>
<div class="section" id="rds-parsing">
<h2>RDS Parsing<a class="headerlink" href="#rds-parsing" title="Permalink to this headline">¶</a></h2>
<p>Now that we have bytes, in groups of 8, we can extract the final data, i.e., the final output that is human understandable.  This is known as parsing the bytes, and just like the decoder in the previous section, it is simply an implementation of the RDS protocol, and is really not that important to understand.  Luckily it’s not a ton of code, if you don’t include the two tables defined at the start, which are simply the lookup tables for the type of FM channel and the coverage area.</p>
<p>For those who want to learn how this code works, I’ll provide some added information.  The protocol uses this concept of an A/B flag, which means some messages are marked A and others B, and the parsing changes based on which one (whether it’s A or B is stored in the third bit of the second byte).  It also uses different “group” types which are analogous to message type, and in this code we are only parsing message type 2, which is the message type that has the radio text in it, which is the interesting part, it’s the text that scrolls across the screen in your car.  We will still be able to parse the channel type and region, as they are stored in every message.  Lastly, note that <code class="code docutils literal notranslate"><span class="pre">radiotext</span></code> is a string that gets initialized to all spaces, gets filled out slowly as bytes are parsed, and then resets to all spaces if a specific set of bytes is received.  If you are curious what other message types exist, the list is: [“BASIC”, “PIN/SL”, “RT”, “AID”, “CT”, “TDC”, “IH”, “RP”, “TMC”, “EWS”, “EON”]. The message “RT” is radiotext which is the only one we decode.  The RDS GNU Radio block decodes “BASIC” as well, but for the stations I used for testing it didn’t contain much interesting information, and would have added a lot of lines to the code below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Annex F of RBDS Standard Table F.1 (North America) and Table F.2 (Europe)</span>
<span class="c1">#              Europe                   North America</span>
<span class="n">pty_table</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;Undefined&quot;</span><span class="p">,</span>             <span class="s2">&quot;Undefined&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;News&quot;</span><span class="p">,</span>                  <span class="s2">&quot;News&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Current Affairs&quot;</span><span class="p">,</span>       <span class="s2">&quot;Information&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Information&quot;</span><span class="p">,</span>           <span class="s2">&quot;Sports&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Sport&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Education&quot;</span><span class="p">,</span>             <span class="s2">&quot;Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Drama&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Classic Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Culture&quot;</span><span class="p">,</span>               <span class="s2">&quot;Adult Hits&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Science&quot;</span><span class="p">,</span>               <span class="s2">&quot;Soft Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Varied&quot;</span><span class="p">,</span>                <span class="s2">&quot;Top 40&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Pop Music&quot;</span><span class="p">,</span>             <span class="s2">&quot;Country&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Rock Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Oldies&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Easy Listening&quot;</span><span class="p">,</span>        <span class="s2">&quot;Soft&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Light Classical&quot;</span><span class="p">,</span>       <span class="s2">&quot;Nostalgia&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Serious Classical&quot;</span><span class="p">,</span>     <span class="s2">&quot;Jazz&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Other Music&quot;</span><span class="p">,</span>           <span class="s2">&quot;Classical&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Weather&quot;</span><span class="p">,</span>               <span class="s2">&quot;Rhythm &amp; Blues&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Finance&quot;</span><span class="p">,</span>               <span class="s2">&quot;Soft Rhythm &amp; Blues&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Children’s Programmes&quot;</span><span class="p">,</span> <span class="s2">&quot;Language&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Social Affairs&quot;</span><span class="p">,</span>        <span class="s2">&quot;Religious Music&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Religion&quot;</span><span class="p">,</span>              <span class="s2">&quot;Religious Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Phone-In&quot;</span><span class="p">,</span>              <span class="s2">&quot;Personality&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Travel&quot;</span><span class="p">,</span>                <span class="s2">&quot;Public&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Leisure&quot;</span><span class="p">,</span>               <span class="s2">&quot;College&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Jazz Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Spanish Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Country Music&quot;</span><span class="p">,</span>         <span class="s2">&quot;Spanish Music&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;National Music&quot;</span><span class="p">,</span>        <span class="s2">&quot;Hip Hop&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Oldies Music&quot;</span><span class="p">,</span>          <span class="s2">&quot;Unassigned&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Folk Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Unassigned&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Documentary&quot;</span><span class="p">,</span>           <span class="s2">&quot;Weather&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Alarm Test&quot;</span><span class="p">,</span>            <span class="s2">&quot;Emergency Test&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Alarm&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Emergency&quot;</span><span class="p">]]</span>
<span class="n">pty_locale</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># set to 0 for Europe which will use first column instead</span>

<span class="c1"># page 72, Annex D, table D.2 in the standard</span>
<span class="n">coverage_area_codes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Local&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;International&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;National&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Supra-regional&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 1&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 2&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 3&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 4&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 5&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 6&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 7&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 8&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 9&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 10&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 11&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 12&quot;</span><span class="p">]</span>

<span class="n">radiotext_AB_flag</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">radiotext</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">65</span>
<span class="n">first_time</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">for</span> <span class="nb">bytes</span> <span class="ow">in</span> <span class="n">bytes_out</span><span class="p">:</span>
    <span class="n">group_0</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_1</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_2</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_3</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>

    <span class="n">group_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span> <span class="c1"># here is what each one means, e.g. RT is radiotext which is the only one we decode here: [&quot;BASIC&quot;, &quot;PIN/SL&quot;, &quot;RT&quot;, &quot;AID&quot;, &quot;CT&quot;, &quot;TDC&quot;, &quot;IH&quot;, &quot;RP&quot;, &quot;TMC&quot;, &quot;EWS&quot;, &quot;___&quot;, &quot;___&quot;, &quot;___&quot;, &quot;___&quot;, &quot;EON&quot;, &quot;___&quot;]</span>
    <span class="n">AB</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="c1"># b if 1, a if 0</span>

    <span class="c1">#print(&quot;group_type:&quot;, group_type) # this is essentially message type, i only see type 0 and 2 in my recording</span>
    <span class="c1">#print(&quot;AB:&quot;, AB)</span>

    <span class="n">program_identification</span> <span class="o">=</span> <span class="n">group_0</span>     <span class="c1"># &quot;PI&quot;</span>

    <span class="n">program_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span> <span class="c1"># &quot;PTY&quot;</span>
    <span class="n">pty</span> <span class="o">=</span> <span class="n">pty_table</span><span class="p">[</span><span class="n">program_type</span><span class="p">][</span><span class="n">pty_locale</span><span class="p">]</span>

    <span class="n">pi_area_coverage</span> <span class="o">=</span> <span class="p">(</span><span class="n">program_identification</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
    <span class="n">coverage_area</span> <span class="o">=</span> <span class="n">coverage_area_codes</span><span class="p">[</span><span class="n">pi_area_coverage</span><span class="p">]</span>

    <span class="n">pi_program_reference_number</span> <span class="o">=</span> <span class="n">program_identification</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="c1"># just an int</span>

    <span class="k">if</span> <span class="n">first_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PTY:&quot;</span><span class="p">,</span> <span class="n">pty</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;program:&quot;</span><span class="p">,</span> <span class="n">pi_program_reference_number</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;coverage_area:&quot;</span><span class="p">,</span> <span class="n">coverage_area</span><span class="p">)</span>
        <span class="n">first_time</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">group_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># when the A/B flag is toggled, flush your current radiotext</span>
        <span class="k">if</span> <span class="n">radiotext_AB_flag</span> <span class="o">!=</span> <span class="p">((</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">):</span>
            <span class="n">radiotext</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">65</span>
        <span class="n">radiotext_AB_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span>
        <span class="n">text_segment_address_code</span> <span class="o">=</span> <span class="n">group_1</span> <span class="o">&amp;</span> <span class="mh">0x0f</span>
        <span class="k">if</span> <span class="n">AB</span><span class="p">:</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">2</span>    <span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_3</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span><span class="mi">4</span>     <span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_2</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_2</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_3</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">radiotext</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1">#print(&quot;unsupported group_type:&quot;, group_type)</span>
</pre></div>
</div>
<p>Below shows the output of the parsing step for an example FM station.  Note how it has to build the radiotext string over multiple messages, and then it periodically clears out the string and starts again.  If you are using the 1M sample downloaded file, you will only see the first few lines below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">PTY: Top 40</span>
<span class="go">program: 29</span>
<span class="go">coverage_area: Regional 4</span>
<span class="go">            ing.</span>
<span class="go">            ing. Upb</span>
<span class="go">            ing. Upbeat.</span>
<span class="go">            ing. Upbeat. Rea</span>

<span class="go">WAY-</span>
<span class="go">WAY-FM U</span>
<span class="go">WAY-FM Uplif</span>
<span class="go">WAY-FM Uplifting</span>
<span class="go">WAY-FM Uplifting. Up</span>
<span class="go">WAY-FM Uplifting. Upbeat</span>
<span class="go">WAY-FM Uplifting. Upbeat. Re</span>

<span class="go">WayF</span>
<span class="go">WayFM Up</span>
<span class="go">WayFM Uplift</span>
<span class="go">WayFM Uplifting.</span>
<span class="go">WayFM Uplifting. Upb</span>
<span class="go">WayFM Uplifting. Upbeat.</span>
<span class="go">WayFM Uplifting. Upbeat. Rea</span>
</pre></div>
</div>
</div>
<div class="section" id="wrap-up-and-final-code">
<h2>Wrap-Up and Final Code<a class="headerlink" href="#wrap-up-and-final-code" title="Permalink to this headline">¶</a></h2>
<p>You did it!  Below is all of the code above, concatenated, it should work with the test recording available for download.  If you find you had to make tweaks to get it to work with your own recording or live SDR, let me know what you had to do, you can submit it as a GitHub PR at <a class="reference external" href="https://github.com/777arc/textbook" rel="noopener noreferrer" target="_blank">the textbook’s GitHub page</a>.  You can also find a version of this code with dozens of debug plotting/printing included, that I originally used to make this chapter, <a class="reference external" href="https://github.com/777arc/textbook/blob/master/figure-generating-scripts/rds_demo.py" rel="noopener noreferrer" target="_blank">here</a>.</p>
<details>
<summary>Final Code</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read in signal</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;/home/marc/Downloads/fm_rds_250k_from_sdrplay.iq&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">250e3</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">99.5e6</span>

<span class="c1"># Quadrature Demod</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="c1"># see https://wiki.gnuradio.org/index.php/Quadrature_Demod</span>

<span class="c1"># Freq shift</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">f_o</span> <span class="o">=</span> <span class="o">-</span><span class="mf">57e3</span> <span class="c1"># amount we need to shift by</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># time vector</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f_o</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># down shift</span>

<span class="c1"># Low-Pass Filter</span>
<span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">7.5e3</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>

<span class="c1"># Decimate by 10, now that we filtered and there wont be aliasing</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="mi">10</span><span class="p">]</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">25e3</span>

<span class="c1"># Resample to 19kHz</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="c1"># up, down</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">19e3</span>

<span class="c1"># Bandpass filter (TODO: make it a proper matched filter with RRC, even though it&#39;s not required to function)</span>
<span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="mi">501</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="p">[</span><span class="mf">0.05e3</span><span class="p">,</span> <span class="mf">2e3</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>

<span class="c1"># Symbol sync, using what we did in sync chapter</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># for the sake of matching the sync chapter</span>
<span class="n">samples_interpolated</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">sps</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># initial estimate of phase of sample</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">out_rail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span> <span class="c1"># stores values, each iteration we need the previous 2 values plus current value</span>
<span class="n">i_in</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># input samples index</span>
<span class="n">i_out</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># output index (let first two outputs be 0)</span>
<span class="k">while</span> <span class="n">i_out</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i_in</span><span class="o">*</span><span class="mi">16</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_interpolated</span><span class="p">[</span><span class="n">i_in</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="mi">16</span><span class="p">)]</span> <span class="c1"># grab what we think is the &quot;best&quot; sample</span>
    <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">+=</span> <span class="n">sps</span> <span class="o">+</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">mm_val</span>
    <span class="n">i_in</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="c1"># round down to nearest int since we are using it as an index</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="c1"># remove the integer part of mu</span>
    <span class="n">i_out</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># increment output index</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">i_out</span><span class="p">]</span> <span class="c1"># remove the first two, and anything after i_out (that was never filled out)</span>

<span class="c1"># Fine freq sync</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># for the sake of matching the sync chapter</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># These next two params is what to adjust, to make the feedback loop faster or slower (which impacts stability)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">8.0</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.002</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">freq_log</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="c1"># adjust the input sample by the inverse of the estimated phase offset</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># This is the error formula for 2nd order Costas Loop (e.g. for BPSK)</span>

    <span class="c1"># Advance the loop (recalc phase and freq offset)</span>
    <span class="n">freq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">freq_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="c1"># convert from angular velocity to Hz for logging</span>
    <span class="n">phase</span> <span class="o">+=</span> <span class="n">freq</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>

    <span class="c1"># Optional: Adjust phase so its always between 0 and 2pi, recall that phase wraps around every 2pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">out</span>

<span class="c1"># Demod BPSK</span>
<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># 1&#39;s and 0&#39;s</span>

<span class="c1"># Differential decoding, so that it doesn&#39;t matter whether our BPSK was 180 degrees rotated without us realizing it</span>
<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="c1"># for decoder</span>

<span class="c1">###########</span>
<span class="c1"># DECODER #</span>
<span class="c1">###########</span>

<span class="c1"># Constants</span>
<span class="n">syndrome</span> <span class="o">=</span> <span class="p">[</span><span class="mi">383</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">303</span><span class="p">,</span> <span class="mi">663</span><span class="p">,</span> <span class="mi">748</span><span class="p">]</span>
<span class="n">offset_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">offset_word</span> <span class="o">=</span> <span class="p">[</span><span class="mi">252</span><span class="p">,</span> <span class="mi">408</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">436</span><span class="p">,</span> <span class="mi">848</span><span class="p">]</span>

<span class="c1"># see Annex B, page 64 of the standard</span>
<span class="k">def</span> <span class="nf">calc_syndrome</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
    <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">plen</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)):</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">^</span> <span class="mh">0x5B9</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)):</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">^</span> <span class="mh">0x5B9</span>
    <span class="k">return</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># select the bottom plen bits of reg</span>

<span class="c1"># Initialize all the working vars we&#39;ll need during the loop</span>
<span class="n">synced</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">group_good_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># was unsigned long in C++ (64 bits) but numpy doesn&#39;t support bitwise ops of uint64, I don&#39;t think it gets that high anyway</span>
<span class="n">lastseen_offset_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lastseen_offset</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># the synchronization process is described in Annex C, page 66 of the standard */</span>
<span class="n">bytes_out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)):</span>
    <span class="c1"># in C++ reg doesn&#39;t get init so it will be random at first, for ours its 0s</span>
    <span class="c1"># It was also an unsigned long but never seemed to get anywhere near the max value</span>
    <span class="c1"># bits are either 0 or 1</span>
    <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># reg contains the last 26 rds bits. these are both bitwise ops</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">synced</span><span class="p">:</span>
        <span class="n">reg_syndrome</span> <span class="o">=</span> <span class="n">calc_syndrome</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reg_syndrome</span> <span class="o">==</span> <span class="n">syndrome</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">presync</span><span class="p">:</span>
                    <span class="n">lastseen_offset</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">lastseen_offset_counter</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">presync</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">block_distance</span> <span class="o">=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">block_distance</span> <span class="o">=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">block_distance</span><span class="o">*</span><span class="mi">26</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">lastseen_offset_counter</span><span class="p">):</span>
                        <span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sync State Detected&#39;</span><span class="p">)</span>
                        <span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">block_bit_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">block_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
                        <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">synced</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span> <span class="c1"># syndrome found, no more cycles</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># SYNCED</span>
        <span class="c1"># wait until 26 bits enter the buffer */</span>
        <span class="k">if</span> <span class="n">block_bit_counter</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">:</span>
            <span class="n">block_bit_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dataword</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span>
            <span class="n">block_calculated_crc</span> <span class="o">=</span> <span class="n">calc_syndrome</span><span class="p">(</span><span class="n">dataword</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
            <span class="n">checkword</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span>
            <span class="k">if</span> <span class="n">block_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># manage special case of C or C&#39; offset word</span>
                <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="n">block_number</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">):</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">):</span>
                        <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">wrong_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="n">block_number</span><span class="p">]</span> <span class="c1"># bitwise xor</span>
                <span class="k">if</span> <span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">:</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wrong_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Done checking CRC</span>
            <span class="k">if</span> <span class="n">block_number</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">good_block</span><span class="p">:</span>
                <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">group_good_blocks_counter</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="nb">bytes</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># 8 bytes filled with 0s</span>
            <span class="k">if</span> <span class="n">group_assembly_started</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">good_block</span><span class="p">:</span>
                    <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># raw data bytes, as received from RDS. 8 info bytes, followed by 4 RDS offset chars: ABCD/ABcD/EEEE (in US) which we leave out here</span>
                    <span class="c1"># RDS information words</span>
                    <span class="c1"># block_number is either 0,1,2,3 so this is how we fill out the 8 bytes</span>
                    <span class="nb">bytes</span><span class="p">[</span><span class="n">block_number</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataword</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span>
                    <span class="nb">bytes</span><span class="p">[</span><span class="n">block_number</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataword</span> <span class="o">&amp;</span> <span class="mi">255</span>
                    <span class="n">group_good_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1">#print(&#39;group_good_blocks_counter:&#39;, group_good_blocks_counter)</span>
                <span class="k">if</span> <span class="n">group_good_blocks_counter</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="c1">#print(bytes)</span>
                    <span class="n">bytes_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span> <span class="c1"># list of len-8 lists of bytes</span>
            <span class="n">block_bit_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">block_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
            <span class="n">blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">blocks_counter</span> <span class="o">==</span> <span class="mi">50</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">wrong_blocks_counter</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">:</span> <span class="c1"># This many wrong blocks must mean we lost sync</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lost Sync (Got &quot;</span><span class="p">,</span> <span class="n">wrong_blocks_counter</span><span class="p">,</span> <span class="s2">&quot; bad blocks on &quot;</span><span class="p">,</span> <span class="n">blocks_counter</span><span class="p">,</span> <span class="s2">&quot; total)&quot;</span><span class="p">)</span>
                    <span class="n">synced</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Still Sync-ed (Got &quot;</span><span class="p">,</span> <span class="n">wrong_blocks_counter</span><span class="p">,</span> <span class="s2">&quot; bad blocks on &quot;</span><span class="p">,</span> <span class="n">blocks_counter</span><span class="p">,</span> <span class="s2">&quot; total)&quot;</span><span class="p">)</span>
                <span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">###########</span>
<span class="c1"># PARSER  #</span>
<span class="c1">###########</span>

<span class="c1"># Annex F of RBDS Standard Table F.1 (North America) and Table F.2 (Europe)</span>
<span class="c1">#              Europe                   North America</span>
<span class="n">pty_table</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;Undefined&quot;</span><span class="p">,</span>             <span class="s2">&quot;Undefined&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;News&quot;</span><span class="p">,</span>                  <span class="s2">&quot;News&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Current Affairs&quot;</span><span class="p">,</span>       <span class="s2">&quot;Information&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Information&quot;</span><span class="p">,</span>           <span class="s2">&quot;Sports&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Sport&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Education&quot;</span><span class="p">,</span>             <span class="s2">&quot;Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Drama&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Classic Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Culture&quot;</span><span class="p">,</span>               <span class="s2">&quot;Adult Hits&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Science&quot;</span><span class="p">,</span>               <span class="s2">&quot;Soft Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Varied&quot;</span><span class="p">,</span>                <span class="s2">&quot;Top 40&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Pop Music&quot;</span><span class="p">,</span>             <span class="s2">&quot;Country&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Rock Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Oldies&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Easy Listening&quot;</span><span class="p">,</span>        <span class="s2">&quot;Soft&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Light Classical&quot;</span><span class="p">,</span>       <span class="s2">&quot;Nostalgia&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Serious Classical&quot;</span><span class="p">,</span>     <span class="s2">&quot;Jazz&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Other Music&quot;</span><span class="p">,</span>           <span class="s2">&quot;Classical&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Weather&quot;</span><span class="p">,</span>               <span class="s2">&quot;Rhythm &amp; Blues&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Finance&quot;</span><span class="p">,</span>               <span class="s2">&quot;Soft Rhythm &amp; Blues&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Children’s Programmes&quot;</span><span class="p">,</span> <span class="s2">&quot;Language&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Social Affairs&quot;</span><span class="p">,</span>        <span class="s2">&quot;Religious Music&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Religion&quot;</span><span class="p">,</span>              <span class="s2">&quot;Religious Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Phone-In&quot;</span><span class="p">,</span>              <span class="s2">&quot;Personality&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Travel&quot;</span><span class="p">,</span>                <span class="s2">&quot;Public&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Leisure&quot;</span><span class="p">,</span>               <span class="s2">&quot;College&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Jazz Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Spanish Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Country Music&quot;</span><span class="p">,</span>         <span class="s2">&quot;Spanish Music&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;National Music&quot;</span><span class="p">,</span>        <span class="s2">&quot;Hip Hop&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Oldies Music&quot;</span><span class="p">,</span>          <span class="s2">&quot;Unassigned&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Folk Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Unassigned&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Documentary&quot;</span><span class="p">,</span>           <span class="s2">&quot;Weather&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Alarm Test&quot;</span><span class="p">,</span>            <span class="s2">&quot;Emergency Test&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Alarm&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Emergency&quot;</span><span class="p">]]</span>
<span class="n">pty_locale</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># set to 0 for Europe which will use first column instead</span>

<span class="c1"># page 72, Annex D, table D.2 in the standard</span>
<span class="n">coverage_area_codes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Local&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;International&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;National&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Supra-regional&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 1&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 2&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 3&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 4&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 5&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 6&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 7&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 8&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 9&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 10&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 11&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 12&quot;</span><span class="p">]</span>

<span class="n">radiotext_AB_flag</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">radiotext</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">65</span>
<span class="n">first_time</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">for</span> <span class="nb">bytes</span> <span class="ow">in</span> <span class="n">bytes_out</span><span class="p">:</span>
    <span class="n">group_0</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_1</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_2</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_3</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>

    <span class="n">group_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span> <span class="c1"># here is what each one means, e.g. RT is radiotext which is the only one we decode here: [&quot;BASIC&quot;, &quot;PIN/SL&quot;, &quot;RT&quot;, &quot;AID&quot;, &quot;CT&quot;, &quot;TDC&quot;, &quot;IH&quot;, &quot;RP&quot;, &quot;TMC&quot;, &quot;EWS&quot;, &quot;___&quot;, &quot;___&quot;, &quot;___&quot;, &quot;___&quot;, &quot;EON&quot;, &quot;___&quot;]</span>
    <span class="n">AB</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="c1"># b if 1, a if 0</span>

    <span class="c1">#print(&quot;group_type:&quot;, group_type) # this is essentially message type, i only see type 0 and 2 in my recording</span>
    <span class="c1">#print(&quot;AB:&quot;, AB)</span>

    <span class="n">program_identification</span> <span class="o">=</span> <span class="n">group_0</span>     <span class="c1"># &quot;PI&quot;</span>

    <span class="n">program_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span> <span class="c1"># &quot;PTY&quot;</span>
    <span class="n">pty</span> <span class="o">=</span> <span class="n">pty_table</span><span class="p">[</span><span class="n">program_type</span><span class="p">][</span><span class="n">pty_locale</span><span class="p">]</span>

    <span class="n">pi_area_coverage</span> <span class="o">=</span> <span class="p">(</span><span class="n">program_identification</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
    <span class="n">coverage_area</span> <span class="o">=</span> <span class="n">coverage_area_codes</span><span class="p">[</span><span class="n">pi_area_coverage</span><span class="p">]</span>

    <span class="n">pi_program_reference_number</span> <span class="o">=</span> <span class="n">program_identification</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="c1"># just an int</span>

    <span class="k">if</span> <span class="n">first_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PTY:&quot;</span><span class="p">,</span> <span class="n">pty</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;program:&quot;</span><span class="p">,</span> <span class="n">pi_program_reference_number</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;coverage_area:&quot;</span><span class="p">,</span> <span class="n">coverage_area</span><span class="p">)</span>
        <span class="n">first_time</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">group_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># when the A/B flag is toggled, flush your current radiotext</span>
        <span class="k">if</span> <span class="n">radiotext_AB_flag</span> <span class="o">!=</span> <span class="p">((</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">):</span>
            <span class="n">radiotext</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">65</span>
        <span class="n">radiotext_AB_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span>
        <span class="n">text_segment_address_code</span> <span class="o">=</span> <span class="n">group_1</span> <span class="o">&amp;</span> <span class="mh">0x0f</span>
        <span class="k">if</span> <span class="n">AB</span><span class="p">:</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">2</span>    <span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_3</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span><span class="mi">4</span>     <span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_2</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_2</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_3</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">radiotext</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1">#print(&quot;unsupported group_type:&quot;, group_type)</span>
</pre></div>
</div>
</details><p>Once again, the example FM recording known to work with this code <a class="reference external" href="https://github.com/777arc/498x/blob/master/fm_rds_250k_1Msamples.iq?raw=true" rel="noopener noreferrer" target="_blank">can be found here</a>.</p>
<p>For those interested in demodulating the actual audio signal, just add the following lines right after the “Acquiring a Signal” section (special thanks to <a class="reference external" href="http://github.com/joeugenio" rel="noopener noreferrer" target="_blank">Joel Cordeiro</a> for the code):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add the following code right after the &quot;Acquiring a Signal&quot; section</span>

<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">wavfile</span>

<span class="c1"># Demodulation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

<span class="c1"># De-emphasis filter, H(s) = 1/(RC*s + 1), implemented as IIR via bilinear transform</span>
<span class="n">bz</span><span class="p">,</span> <span class="n">az</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mf">75e-6</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">bz</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c1"># decimate filter to get mono audio</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="mi">6</span><span class="p">]</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">6</span>

<span class="c1"># normalizes volume</span>
<span class="n">x</span> <span class="o">/=</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

<span class="c1"># Save to wav file, you can open this in Audacity for example</span>
<span class="n">wavfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;fm.wav&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The most complicated part is the de-emphasis filter, <a class="reference external" href="https://wiki.gnuradio.org/index.php/FM_Preemphasis" rel="noopener noreferrer" target="_blank">which you can learn about here</a>, although it’s actually an optional step if you are OK with audio that has a poor bass/treble balance.  For those curious, here is what the frequency response of the <a class="reference external" href="https://en.wikipedia.org/wiki/Infinite_impulse_response" rel="noopener noreferrer" target="_blank">IIR</a> de-emphasis filter looks like, it doesn’t fully filter out any frequencies, it’s more of a “shaping” filter.</p>
<a class="reference external image-reference" href="../_images/fm_demph_filter_freq_response.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fm_demph_filter_freq_response.svg" class="align-center" src="../_images/fm_demph_filter_freq_response.svg" /></a>
</div>
<div class="section" id="acknowledgments">
<h2>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Permalink to this headline">¶</a></h2>
<p>Most of the steps above used to receive RDS were adapted from the GNU Radio implementation of RDS, which lives in the GNU Radio Out-of-Tree Module called <a class="reference external" href="https://github.com/bastibl/gr-rds" rel="noopener noreferrer" target="_blank">gr-rds</a>, originally created by Dimitrios Symeonidis and maintained by Bastian Bloessl, and I would like to acknowledge the work of these authors.  In order to create this chapter, I started with using gr-rds in GNU Radio, with a working FM recording, and slowly converted each of the blocks (including many built-in blocks) to Python.  It took quite a bit of time, there are some nuances to the built-in blocks that are easy to miss, and going from stream-style signal processing (i.e., using a work function that processes a few thousand samples at a time in a stateful manner) to a block of Python is not always straightforward.  GNU Radio is an amazing tool for this kind of prototyping and I would never have been able to create all of this working Python code without it.</p>
</div>
<div class="section" id="further-reading">
<h2>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Radio_Data_System" rel="noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Radio_Data_System</a></li>
<li><a class="reference external" href="https://www.sigidwiki.com/wiki/Radio_Data_System_(RDS)" rel="noopener noreferrer" target="_blank">https://www.sigidwiki.com/wiki/Radio_Data_System_(RDS)</a></li>
<li><a class="reference external" href="https://github.com/bastibl/gr-rds" rel="noopener noreferrer" target="_blank">https://github.com/bastibl/gr-rds</a></li>
<li><a class="reference external" href="https://www.gnuradio.org/" rel="noopener noreferrer" target="_blank">https://www.gnuradio.org/</a></li>
</ol>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="sync.html" title="Previous document"><span class="section-number">14. </span>Synchronization</a>
        </li>
        <li>
          <a href="about_author.html" title="Next document"><span class="section-number">16. </span>About the Author</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>