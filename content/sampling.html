
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. IQ Sampling &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Digital Modulation" href="digital_modulation.html" />
    <link rel="prev" title="2. Frequency Domain" href="frequency_domain.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Frequency Domain</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. IQ Sampling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sampling-basics">Sampling Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nyquist-sampling">Nyquist Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quadrature-sampling">Quadrature Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#complex-numbers-in-ffts">Complex Numbers in FFTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#receiver-side">Receiver Side</a></li>
<li class="toctree-l2"><a class="reference internal" href="#carrier-and-downconversion">Carrier and Downconversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#receiver-architectures">Receiver Architectures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#baseband-and-bandpass-signals">Baseband and Bandpass Signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dc-spike-and-offset-tuning">DC Spike and Offset Tuning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sampling-using-our-sdr">Sampling Using our SDR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calculating-average-power">Calculating Average Power</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calculating-power-spectral-density">Calculating Power Spectral Density</a></li>
<li class="toctree-l2"><a class="reference internal" href="#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digital Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Noise and dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Channel Coding</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronization</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. End-to-End Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="frequency_domain.html" title="previous chapter"><span class="section-number">2. </span>Frequency Domain</a></li>
      <li>Next: <a href="digital_modulation.html" title="next chapter"><span class="section-number">4. </span>Digital Modulation</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="frequency_domain.html" title="Previous document"><span class="section-number">2. </span>Frequency Domain</a>
        </li>
        <li>
          <a href="digital_modulation.html" title="Next document"><span class="section-number">4. </span>Digital Modulation</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="iq-sampling">
<span id="sampling-chapter"></span><h1><span class="section-number">3. </span>IQ Sampling<a class="headerlink" href="#iq-sampling" title="Permalink to this headline">¶</a></h1>
<p>In this chapter we introduce a concept called IQ sampling, a.k.a. complex sampling or quadrature sampling.  We also cover Nyquist sampling, complex numbers, RF carriers, downconversion, and power spectral density.  IQ sampling is the form of sampling that an SDR performs, as well as many digital receivers (and transmitters).  It’s a slightly more complex version of regular digital sampling (pun intended), so we will take it slow and with some practice the concept is sure to click!</p>
<div class="section" id="sampling-basics">
<h2>Sampling Basics<a class="headerlink" href="#sampling-basics" title="Permalink to this headline">¶</a></h2>
<p>Before jumping into IQ sampling, let’s discuss what sampling actually means. You may have encountered sampling without realizing it by recording audio with a microphone. The microphone is a transducer that converts sound waves into an electric signal (a voltage level). That electric signal is transformed by an analog-to-digital converter (ADC), producing a digital representation of the sound wave. To simplify, the microphone captures sound waves that are converted into electricity, and that electricity in turn is converted into numbers.  The ADC acts as the bridge between the analog and digital domains.  SDRs are surprisingly similar. Instead of a microphone, however, they utilize an antenna, although they also use ADCs. In both cases, the voltage level is sampled with an ADC. For SDRs, think radio waves in then numbers out.</p>
<p>Whether we are dealing with audio or radio frequencies, we must sample if we want to capture, process, or save a signal digitally.  Sampling might seem straightforward, but there is a lot to it.  A more technical way to think of sampling a signal is grabbing values at moments in time and saving them digitally. Let’s say we have some random function, <img class="math" src="../_images/math/097ad9d7221d263c5c30372cb84f502da58dc6ff.svg" alt="S(t)"/>, which could represent anything, and it’s a continuous function that we want to sample:</p>
<img alt="../_images/sampling.svg" class="align-center" src="../_images/sampling.svg" /><p>We record the value of <img class="math" src="../_images/math/097ad9d7221d263c5c30372cb84f502da58dc6ff.svg" alt="S(t)"/> at regular intervals of <img class="math" src="../_images/math/51acb7b4939189dc34f1c1f10cf8acb7aeb5218a.svg" alt="T"/> seconds, known as the <strong>sample period</strong>.  The frequency at which we sample, i.e., the number of samples taken per second, is simply <img class="math" src="../_images/math/a32df15aba09f5932ad327e03821a26c43439f98.svg" alt="\frac{1}{T}"/>.  We call this the <strong>sample rate</strong>, and its the inverse of the sample period.  For example, if we have a sample rate of 10 Hz, then the sample period is 0.1 seconds; there will be 0.1 seconds between each sample.  In practice our sample rates will be on the order of hundreds of kHz to tens of MHz or even higher.  When we sample signals, we need to be mindful of the sample rate, it’s a very important parameter.</p>
<p>For those who prefer to see the math; let <img class="math" src="../_images/math/15edb6f2acafa5e06d8997e1682d87cc39351360.svg" alt="S_n"/> represent sample <img class="math" src="../_images/math/f7a9f3c7a45b9df2dac17c2a197dd82e66e4a44a.svg" alt="n"/>, usually an integer starting at 0. Using this convention, the sampling process can be represented mathematically as <img class="math" src="../_images/math/b5116a6f84baffdd75bcbf68ab2adfbaa31357bc.svg" alt="S_n = S(nT)"/> for integer values of <img class="math" src="../_images/math/f7a9f3c7a45b9df2dac17c2a197dd82e66e4a44a.svg" alt="n"/>.  I.e., we evaluate the analog signal <img class="math" src="../_images/math/097ad9d7221d263c5c30372cb84f502da58dc6ff.svg" alt="S(t)"/> at these intervals of <img class="math" src="../_images/math/f64c1fd61d41bf096882352bc2e26a0f173e538d.svg" alt="nT"/>.</p>
</div>
<div class="section" id="nyquist-sampling">
<h2>Nyquist Sampling<a class="headerlink" href="#nyquist-sampling" title="Permalink to this headline">¶</a></h2>
<p>For a given signal, the big question often is how fast must we sample?  Let’s examine a signal that is just a sine wave, of frequency f, shown in green below.  Let’s say we sample at a rate Fs (samples shown in blue).  If we sample that signal at a rate equal to f (i.e., Fs = f), we will get something that looks like:</p>
<img alt="../_images/sampling_Fs_0.3.svg" class="align-center" src="../_images/sampling_Fs_0.3.svg" /><p>The red dashed line in the above image reconstructs a different (incorrect) function that could have lead to the same samples being recorded. It indicates that our sample rate was too low because the same samples could have come from two different functions, leading to ambiguity. If we want to accurately reconstruct the original signal, we can’t have this ambiguity.</p>
<p>Let’s try sampling a little faster, at Fs = 1.2f:</p>
<img alt="../_images/sampling_Fs_0.36.svg" class="align-center" src="../_images/sampling_Fs_0.36.svg" /><p>Once again, there is a different signal that could fit these samples. This ambiguity means that if someone gave us this list of samples, we could not distinguish which signal was the original one based on our sampling.</p>
<p>How about sampling at Fs = 1.5f:</p>
<img alt="../_images/sampling_Fs_0.45.svg" class="align-center" src="../_images/sampling_Fs_0.45.svg" /><p>Still not fast enough!  According to a piece of DSP theory we won’t dive into, you have to sample at <strong>twice</strong> the frequency of the signal in order to remove the ambiguity we are experiencing:</p>
<img alt="../_images/sampling_Fs_0.6.svg" class="align-center" src="../_images/sampling_Fs_0.6.svg" /><p>There’s no incorrect signal this time because we sampled fast enough that no signal exists that fits these samples other than the one you see (unless you go <em>higher</em> in frequency, but we will discuss that later).</p>
<p>In the above example our signal was just a simple sine wave, most actual signals will have many frequency components to them.  To accurately sample any given signal, the sample rate must be “at least twice the frequency of the maximum frequency component”.  Here’s a visualization using an example frequency domain plot, note that there will always be a noise floor so the highest frequency is usually an approximation:</p>
<img alt="../_images/max_freq.svg" class="align-center" src="../_images/max_freq.svg" /><p>We must identify the highest frequency component, then double it, and make sure we sample at that rate or faster.  The minimum rate in which we can sample is known as the Nyquist Rate.  In other words, the Nyquist Rate is the minimum rate at which a (finite bandwidth) signal needs to be sampled to retain all of its information.  It is an extremely important piece of theory within DSP and SDR that serves as a bridge between continuous and discrete signals.</p>
<a class="reference internal image-reference" href="../_images/nyquist_rate.png"><img alt="../_images/nyquist_rate.png" class="align-center" src="../_images/nyquist_rate.png" style="width: 364.7px; height: 158.2px;" /></a>
<p>If we don’t sample fast enough we get something called aliasing, which we will learn about later, but we try to avoid it at all costs.  What our SDRs do (and most receivers in general) is filter out everything above Fs/2 right before the sampling is performed. If we attempt to receive a signal with too low a sample rate, that filter will chop off part of the signal.  Our SDRs go to great lengths to provide us with samples free of aliasing and other imperfections.</p>
</div>
<div class="section" id="quadrature-sampling">
<h2>Quadrature Sampling<a class="headerlink" href="#quadrature-sampling" title="Permalink to this headline">¶</a></h2>
<p>The term “quadrature” has many meanings, but in the context of DSP and SDR it refers to two waves that are 90 degrees out of phase.  Why 90 degrees out of phase?  Consider how two waves that are 180 degrees out of phase are essentially the same wave with one multiplied by -1. By being 90 degrees out of phase they become orthogonal, and there’s a lot of cool stuff you can do with orthogonal functions.  For the sake of simplicity, we use sine and cosine as our two sine waves that are 90 degrees out of phase.</p>
<p>Next let’s assign variables to represent the <strong>amplitude</strong> of the sine and cosine.  We will use <img class="math" src="../_images/math/39034215a6dc97c339d8d966435f213b2d5f1205.svg" alt="I"/> for the cos() and <img class="math" src="../_images/math/4aefab53c6f372bea2c7ebee8743862e44376226.svg" alt="Q"/> for the sin():</p>
<div class="math">
<p><img src="../_images/math/80a7eb6646b7124039443483ffd0ac0abc437075.svg" alt="I \cos(2\pi ft)

Q \sin(2\pi ft)"/></p>
</div><p>We can see this visually by plotting I and Q equal to 1:</p>
<a class="reference internal image-reference" href="../_images/IQ_wave.png"><img alt="../_images/IQ_wave.png" class="align-center" src="../_images/IQ_wave.png" style="width: 481.59999999999997px; height: 242.2px;" /></a>
<p>We call the cos() the “in phase” component, hence the name I, and the sin() is the 90 degrees out of phase or “quadrature” component, hence Q.  Although if you accidentally mix it up and assign Q to the cos() and I to the sin(), it won’t make a difference for most situations.</p>
<p>IQ sampling is more easily understood by using the transmitter’s point of view, i.e., considering the task of transmitting a RF signal through the air.  What we do as the transmitter is add the sin() and cos().  Let’s say x(t) is our signal to transmit:</p>
<div class="math">
<p><img src="../_images/math/85952bb9ba66501bd120de475a08d40ff06ed52b.svg" alt="x(t) = I \cos(2\pi ft)  + Q \sin(2\pi ft)"/></p>
</div><p>What happens when we add a sine and cosine?  Or rather, what happens when we add two sinusoids that are 90 degrees out of phase?  In the video below, there is a slider for adjusting I and another for adjusting Q.  What is plotted are the cosine, sine, and then the sum of the two.</p>
<a class="reference internal image-reference" href="../_images/IQ3.gif"><img alt="../_images/IQ3.gif" class="align-center" src="../_images/IQ3.gif" style="width: 600.0px; height: 396.0px;" /></a>
<p>(The code used for this pyqtgraph-based Python app can be found <a class="reference external" href="https://raw.githubusercontent.com/777arc/textbook/master/figure-generating-scripts/sin_plus_cos.py" rel="noopener noreferrer" target="_blank">here</a>)</p>
<p>The important take-aways are that when we add the cos() and sin(), we get another pure sine wave with a different phase and amplitude.   Also, the phase shifts as we slowly remove or add one of the two parts.  The amplitude also changes.  This is all a result of the trig identity: <img class="math" src="../_images/math/ab3695b42f9cb6efd2d838efca3dd84c82e2f586.svg" alt="a \cos(x) + b \sin(x) = A \cos(x-\phi)"/>, which we will come back to in a bit.  The “utility” of this behavior is that we can control the phase and amplitude of a resulting sine wave by adjusting the amplitudes I and Q (we don’t have to adjust the phase of the cosine or sine).  For example, we could adjust I and Q in a way that keeps the amplitude constant and makes the phase whatever we want.  As a transmitter this ability is extremely useful because we know that we need to transmit a sinusoidal signal in order for it to fly through the air as an electromagnetic wave.  And it’s much easier to adjust two amplitudes and perform an addition operation compared to adjusting an amplitude and a phase.  The result is that our transmitter will look something like this:</p>
<a class="reference internal image-reference" href="../_images/IQ_diagram.png"><img alt="../_images/IQ_diagram.png" class="align-center" src="../_images/IQ_diagram.png" style="width: 434.40000000000003px; height: 256.8px;" /></a>
<p>We only need to generate one sine wave and shift it by 90 degrees to get the Q portion.</p>
</div>
<div class="section" id="complex-numbers">
<h2>Complex Numbers<a class="headerlink" href="#complex-numbers" title="Permalink to this headline">¶</a></h2>
<p>Ultimately, the IQ convention is an alternative way to represent magnitude and phase, which leads us to complex numbers and the ability to represent them on a complex plane.  You may have seen complex numbers before in other classes. Take the complex number 0.7-0.4j as an example:</p>
<a class="reference internal image-reference" href="../_images/complex_plane_1.png"><img alt="../_images/complex_plane_1.png" class="align-center" src="../_images/complex_plane_1.png" style="width: 258.3px; height: 251.99999999999997px;" /></a>
<p>A complex number is really just two numbers together, a real and an imaginary portion. A complex number also has a magnitude and phase, which makes more sense if you think about it as a vector instead of a point. Magnitude is the length of the line between the origin and the point (i.e., length of the vector), while phase is the angle between the vector and 0 degrees, which we define as the positive real axis:</p>
<a class="reference internal image-reference" href="../_images/complex_plane_2.png"><img alt="../_images/complex_plane_2.png" class="align-center" src="../_images/complex_plane_2.png" style="width: 246.39999999999998px; height: 240.79999999999998px;" /></a>
<p>This representation of a sinusoid is known as a “phasor diagram”.  It’s simply plotting complex numbers and treating them as vectors.  Now what is the magnitude and phase of our example complex number 0.7-0.4j?  For a given complex number where <img class="math" src="../_images/math/375383b47352eb6cd2f5c760a77a36e69e4ed098.svg" alt="a"/> is the real part and <img class="math" src="../_images/math/b9226f3d70379a250fb90320a3c57039c88e5f51.svg" alt="b"/> is the imaginary part:</p>
<div class="math">
<p><img src="../_images/math/b5a551214962cc324e2172e9b8f0227114232a90.svg" alt="\mathrm{magnitude} = \sqrt{a^2 + b^2} = 0.806

\mathrm{phase} = \tan^{-1} \left( \frac{b}{a} \right) = -29.7^{\circ} = -0.519 \quad \mathrm{radians}"/></p>
</div><p>In Python you can use np.abs(x) and np.angle(x) for the magnitude and phase. The input can be a complex number or an array of complex numbers, and the output will be a <strong>real</strong> number(s) (of the data type float).</p>
<p>You may have figured out by now how this vector or phasor diagram relates to IQ convention: I is real and Q is imaginary.  From this point on, when we draw the complex plane, we will label it with I and Q instead of real and imaginary.  They are still complex numbers!</p>
<a class="reference internal image-reference" href="../_images/complex_plane_3.png"><img alt="../_images/complex_plane_3.png" class="align-center" src="../_images/complex_plane_3.png" style="width: 221.89999999999998px; height: 230.99999999999997px;" /></a>
<p>Now let’s say we want to transmit our example point 0.7-0.4j.  We will be transmitting:</p>
<div class="math">
<p><img src="../_images/math/c01b0df5cd8a4203575a68a9140c0533158e2092.svg" alt="x(t) = I \cos(2\pi ft)  + Q \sin(2\pi ft)

\quad \quad \quad = 0.7 \cos(2\pi ft) - 0.4 \sin(2\pi ft)"/></p>
</div><p>We can use trig identity <img class="math" src="../_images/math/ab3695b42f9cb6efd2d838efca3dd84c82e2f586.svg" alt="a \cos(x) + b \sin(x) = A \cos(x-\phi)"/> where <img class="math" src="../_images/math/ac179881032d4f94f75075513db7b13aba211803.svg" alt="A"/> is our magnitude found with <img class="math" src="../_images/math/293562bb226d0886091673a318188c3719f6b8f3.svg" alt="\sqrt{I^2 + Q^2}"/> and <img class="math" src="../_images/math/f41d2a61cd1827c3e57537176609abab588ccc27.svg" alt="\phi"/> is our phase, equal to <img class="math" src="../_images/math/df5e33a7622555c99bdbd841c05645a2204f49dc.svg" alt="\tan^{-1} \left( Q/I \right)"/>.  The above equation now becomes:</p>
<div class="math">
<p><img src="../_images/math/94756445d61a3e62aa78948913becd1a7245b5a7.svg" alt="x(t) = 0.806 \cos(2\pi ft + 0.519)"/></p>
</div><p>Even though we started with a complex number, what we are transmitting is real, which is good because you can’t actually transmit something imaginary with electromagnetic waves.  We just use imaginary/complex numbers to represent <em>what</em> we are transmitting.  We will talk about the <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> shortly.</p>
</div>
<div class="section" id="complex-numbers-in-ffts">
<h2>Complex Numbers in FFTs<a class="headerlink" href="#complex-numbers-in-ffts" title="Permalink to this headline">¶</a></h2>
<p>The above complex numbers were assumed to be time domain samples, but you will also run into complex numbers when you take an FFT.  When we covered Fourier series and FFTs last chapter, we had not dived into complex numbers yet.  When you take the FFT of a series of samples, it finds the frequency domain representation.  We talked about how the FFT figures out which frequencies exist in that set of samples (the magnitude of the FFT indicates the strength of each frequency).  But what the FFT also does is figure out the delay (time shift) needed to apply to each of those frequencies, so that the set of sinusoids can be added up to reconstruct the time-domain signal.  That delay is simply the phase of the FFT.  The output of an FFT is an array of complex numbers, and each complex number gives you the magnitude and phase, and the index of that number gives you the frequency.  If you generate sinusoids at those frequencies/magnitudes/phases and sum them together, you’ll get your original time domain signal (or something very close to it, and that’s where the Nyquist sampling theorem comes into play).</p>
</div>
<div class="section" id="receiver-side">
<h2>Receiver Side<a class="headerlink" href="#receiver-side" title="Permalink to this headline">¶</a></h2>
<p>Now let’s take the perspective of a radio receiver that is trying to receive a signal (e.g., an FM radio signal).  Using IQ sampling, the diagram now looks like:</p>
<a class="reference internal image-reference" href="../_images/IQ_diagram_rx.png"><img alt="../_images/IQ_diagram_rx.png" class="align-center" src="../_images/IQ_diagram_rx.png" style="width: 409.5px; height: 225.39999999999998px;" /></a>
<p>What comes in is a real signal received by our antenna, and those are transformed into IQ values.  What we do is sample the I and Q branches individually, using two ADCs, and then we combine the pairs and store them as complex numbers.  In other words, at each time step, you will sample one I value and one Q value and combine them in the form <img class="math" src="../_images/math/d51b1ee62b9705749afbf567d0f9576f9e8588cf.svg" alt="I + jQ"/> (i.e., one complex number per IQ sample).  There will always be a “sample rate”, the rate at which sampling is performed.  Someone might say, “I have an SDR running at 2 MHz sample rate.” What they mean is that the SDR receives two million IQ samples per second.</p>
<p>If someone gives you a bunch of IQ samples, it will look like a 1D array/vector of complex numbers.  This point, complex or not, is what this entire chapter has been building to, and we finally made it.</p>
<p>Throughout this textbook you will become <strong>very</strong> familiar with how IQ samples work, how to receive and transmit them with an SDR, how to process them in Python, and how to save them to a file for later analysis.</p>
<p>One last important note: the figure above shows what’s happening <strong>inside</strong> of the SDR. We don’t actually have to generate a sine wave, shift by 90, multiply or add–the SDR does that for us.  We tell the SDR what frequency we want to sample at, or what frequency we want to transmit our samples at.  On the receiver side, the SDR will provide us the IQ samples. For the transmitting side, we have to provide the SDR the IQ samples.  In terms of data type, they will either be complex ints or floats.</p>
</div>
<div class="section" id="carrier-and-downconversion">
<h2>Carrier and Downconversion<a class="headerlink" href="#carrier-and-downconversion" title="Permalink to this headline">¶</a></h2>
<p>Until this point we have not discussed frequency, but we saw there was an <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> in the equations involving the cos() and sin().  This frequency is the frequency of the sine wave we actually send through the air (the electromagnetic wave’s frequency).  We refer to it as the “carrier” because it carries our information on a certain frequency.  When we tune to a frequency with our SDR and receive samples, our information is stored in I and Q; this carrier does not show up in I and Q, assuming we tuned to the carrier.</p>
<a class="reference internal image-reference" href="../_images/carrier.png"><img alt="../_images/carrier.png" class="align-center" src="../_images/carrier.png" style="width: 366.09999999999997px; height: 186.89999999999998px;" /></a>
<p>For reference, radio signals such as FM radio, WiFi, Bluetooth, LTE, GPS, etc., usually use a frequency (i.e., a carrier) between 100 MHz and 6 GHz.  These frequencies travel really well through the air, but they don’t require super long antennas or a ton of power to transmit or receive.  Your microwave cooks food with electromagnetic waves at 2.4 GHz. If there is a leak in the door then your microwave will jam WiFi signals and possibly also burn your skin.  Another form of electromagnetic waves is light. Visible light has a frequency of around 500 THz.  It’s so high that we don’t use traditional antennas to transmit light. We use  methods like LEDs that are semiconductor devices. They create light when electrons jump in between the atomic orbits of the semiconductor material, and the color depends on how far they jump.  Technically, radio frequency (RF) is defined as the range from roughly 20 kHz to 300 GHz. These are the frequencies at which energy from an oscillating electric current can radiate off a conductor (an antenna) and travel through space.  The 100 MHz to 6 GHz range are the more useful frequencies, at least for most modern applications.  Frequencies above 6 GHz have been used for radar and satellite communications for decades, and are now being used in 5G “mmWave” (24 - 29 GHz) to supplement the lower bands and increase speeds.</p>
<p>When we change our IQ values quickly and transmit our carrier, it’s called “modulating” the carrier (with data or whatever we want).  When we change I and Q, we change the phase and amplitude of the carrier.  Another option is to change the frequency of the carrier, i.e., shift it slightly up or down, which is what FM radio does.</p>
<p>As a simple example, let’s say we transmit the IQ sample 1+0j, and then we switch to transmitting 0+1j.  We go from sending <img class="math" src="../_images/math/500350f14f961e15e3aa1cc429df3236aba61acd.svg" alt="\cos(2\pi ft)"/> to <img class="math" src="../_images/math/9af12e10a6d9c096760b9646a4d41f6f9a0176f7.svg" alt="\sin(2\pi ft)"/>, meaning our carrier shifts phase by 90 degrees when we switch from one sample to another.</p>
<p>Now back to sampling for a second.  Instead of receiving samples by multiplying what comes off the antenna by a cos() and sin() then recording I and Q, what if we fed the signal from the antenna into a single ADC, like in the direct sampling architecture we just discussed?  Say the carrier frequency is 2.4 GHz, like WiFi or Bluetooth.  That means we would have to sample at 4.8 GHz, as we learned.  That’s extremely fast! An ADC that samples that fast costs thousands of dollars.  Instead, we “downconvert” the signal so that the signal we want to sample is centered around DC or 0 Hz. This downconversion happens before we sample.  We go from:</p>
<div class="math">
<p><img src="../_images/math/80a7eb6646b7124039443483ffd0ac0abc437075.svg" alt="I \cos(2\pi ft)

Q \sin(2\pi ft)"/></p>
</div><p>to just I and Q.</p>
<p>Let’s visualize downconversion in the frequency domain:</p>
<a class="reference internal image-reference" href="../_images/downconversion.png"><img alt="../_images/downconversion.png" class="align-center" src="../_images/downconversion.png" style="width: 703.1999999999999px; height: 116.39999999999999px;" /></a>
<p>When we are centered around 0 Hz, the maximum frequency is no longer 2.4 GHz but is based on the signal’s characteristics since we removed the carrier.  Most signals are around 100 kHz to 40 MHz wide in bandwidth, so through downconversion we can sample at a <em>much</em> lower rate. Both the B2X0 USRPs and PlutoSDR contain an RF integrated circuit (RFIC) that can sample up to 56 MHz, which is high enough for most signals we will encounter.</p>
<p>Just to reiterate, the downconversion process is performed by our SDR; as a user of the SDR we don’t have to do anything other than tell it which frequency to tune to.  Downconversion (and upconversion) is done by a component called a mixer, usually represented in diagrams as a multiplication symbol inside a circle.  The mixer takes in a signal, outputs the down/up-converted signal, and has a third port which is used to feed in an oscillator.  The frequency of the oscillator determines the frequency shift applied to the signal, and the mixer is essentially just a multiplication function (recall that multiplying by a sinusoid causes a frequency shift).</p>
<p>Lastly, you may be curious how fast signals travel through the air.  Recall from high school physics class that radio waves are just electromagnetic waves at low frequencies (between roughly 3 kHz to 80 GHz).  Visible light is also electromagnetic waves, at much higher frequencies (400 THz to 700 THz).  All electromagnetic waves travel at the speed of light, which is about 3e8 m/s, at least when traveling through air or a vacuum.  Now because they always travel at the same speed, the distance the wave travels in one full oscillation (one full cycle of the sine wave) depends on its frequency.  We call this distance the wavelength, denoted as <img class="math" src="../_images/math/5d20f71e79182adab536e881e1c524d2a073268f.svg" alt="\lambda"/>.  You have probably seen this relationship before:</p>
<div class="math">
<p><img src="../_images/math/df4ec1581556a2443c91c41eecd5bb92336ea3da.svg" alt="f = \frac{c}{\lambda}"/></p>
</div><p>where <img class="math" src="../_images/math/341ae5f7c52af1963e056b70131682274a396508.svg" alt="c"/> is the speed of light, typically set to 3e8 when <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> is in Hz and <img class="math" src="../_images/math/5d20f71e79182adab536e881e1c524d2a073268f.svg" alt="\lambda"/> is in meters.  In wireless communications this relationship becomes important when we get to antennas, because to receive a signal at a certain carrier frequency, <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/>, you need an antenna that matches its wavelength, <img class="math" src="../_images/math/5d20f71e79182adab536e881e1c524d2a073268f.svg" alt="\lambda"/>, usually the antenna is <img class="math" src="../_images/math/2fc2aecc8a1770c94019faa3ff6548fa89ac9144.svg" alt="\lambda/2"/> or <img class="math" src="../_images/math/90b1c873bdb5a2fb7b76cec5eb1d5fe1ab3872f5.svg" alt="\lambda/4"/> in length.  However, regardless of the frequency/wavelength, information carried in that signal will always travel at the speed of light, from the transmitter to the receiver.  When calculating this delay through the air, a rule of thumb is that light travels approximately one foot in one nanosecond.  Another rule of thumb: a signal traveling to a satellite in geostationary orbit and back will take roughly 0.25 seconds for the entire trip.</p>
</div>
<div class="section" id="receiver-architectures">
<h2>Receiver Architectures<a class="headerlink" href="#receiver-architectures" title="Permalink to this headline">¶</a></h2>
<p>The figure in the “Receiver Side” section demonstrates how the input signal is downconverted and split into I and Q.  This arrangement is called “direct conversion”, or “zero IF”, because the RF frequencies are being directly converted down to baseband.  Another option is to not downconvert at all and sample so fast to capture everything from 0 Hz to 1/2 the sample rate.  This strategy is called “direct sampling” or “direct RF”, and it requires an extremely expensive ADC chip.  A third architecture, one that is popular because it’s how old radios worked, is known as “superheterodyne”. It involves downconversion but not all the way to 0 Hz. It places the signal of interest at an intermediate frequency, known as “IF”.  A low-noise amplifier (LNA) is simply an amplifier designed for extremely low power signals at the input.  Here are the block diagrams of these three architectures, note that variations and hybrids of these architectures also exist:</p>
<img alt="../_images/receiver_arch_diagram.svg" class="align-center" src="../_images/receiver_arch_diagram.svg" /></div>
<div class="section" id="baseband-and-bandpass-signals">
<h2>Baseband and Bandpass Signals<a class="headerlink" href="#baseband-and-bandpass-signals" title="Permalink to this headline">¶</a></h2>
<p>We refer to a signal centered around 0 Hz as being at “baseband”.  Conversely, “bandpass” refers to when a signal exists at some RF frequency nowhere near 0 Hz, that has been shifted up for the purpose of wireless transmission.  There is no notion of a “baseband transmission”, because you can’t transmit something imaginary.  A signal at baseband may be perfectly centered at 0 Hz like the right-hand portion of the figure in the previous section. It might be <em>near</em> 0 Hz, like the two signals shown below. Those two signals are still considered baseband.   Also shown is an example bandpass signal, centered at a very high frequency denoted <img class="math" src="../_images/math/852c5d6001dcb2c5d6047cc1ee451735a4153eec.svg" alt="f_c"/>.</p>
<a class="reference internal image-reference" href="../_images/baseband_bandpass.png"><img alt="../_images/baseband_bandpass.png" class="align-center" src="../_images/baseband_bandpass.png" style="width: 712.0px; height: 186.5px;" /></a>
<p>You may also hear the term intermediate frequency (abbreviated as IF); for now, think of IF as an intermediate conversion step within a radio between baseband and bandpass/RF.</p>
<p>We tend to create, record, or analyze signals at baseband because we can work at a lower sample rate (for reasons discussed in the previous subsection).  It is important to note that baseband signals are often complex signals, while signals at bandpass (e.g., signals we actually transmit over RF) are real.  Think about it: because the signal fed through an antenna must be real, you cannot directly transmit a complex/imaginary signal.  You will know a signal is definitely a complex signal if the negative frequency and positive frequency portions of the signal are not exactly the same. Complex numbers are how we represent negative frequencies after all.  In reality there are no negative frequencies; it’s just the portion of the signal below the carrier frequency.</p>
<p>In the earlier section where we played around with the complex point 0.7 - 0.4j, that was essentially one sample in a baseband signal.  Most of the time you see complex samples (IQ samples), you are at baseband.  Signals are rarely represented or stored digitally at RF, because of the amount of data it would take, and the fact we are usually only interested in a small portion of the RF spectrum.</p>
</div>
<div class="section" id="dc-spike-and-offset-tuning">
<h2>DC Spike and Offset Tuning<a class="headerlink" href="#dc-spike-and-offset-tuning" title="Permalink to this headline">¶</a></h2>
<p>Once you start working with SDRs, you will often find a large spike in the center of the FFT.
It is called a “DC offset” or “DC spike” or sometimes “LO leakage”, where LO stands for local oscillator.</p>
<p>Here’s an example of a DC spike:</p>
<a class="reference internal image-reference" href="../_images/dc_spike.png"><img alt="../_images/dc_spike.png" class="align-center" src="../_images/dc_spike.png" style="width: 257.5px; height: 244.0px;" /></a>
<p>Because the SDR tunes to a center frequency, the 0 Hz portion of the FFT corresponds to the center frequency.
That being said, a DC spike doesn’t necessarily mean there is energy at the center frequency.
If there is only a DC spike, and the rest of the FFT looks like noise, there is most likely not actually a signal present where it is showing you one.</p>
<p>A DC offset is a common artifact in direct conversion receivers, which is the architecture used for SDRs like the PlutoSDR, RTL-SDR, LimeSDR, and many Ettus USRPs. In direct conversion receivers, an oscillator, the LO, downconverts the signal from its actual frequency to baseband. As a result, leakage from this LO appears in the center of the observed bandwidth. LO leakage is additional energy created through the combination of frequencies. Removing this extra noise is difficult because it is close to the desired output signal. Many RF integrated circuits (RFICs) have built-in automatic DC offset removal, but it typically requires a signal to be present to work. That is why the DC spike will be very apparent when no signals are present.</p>
<p>A quick way to handle the DC offset is to oversample the signal and off-tune it.
As an example, let’s say we want to view 5 MHz of spectrum at 100 MHz.
Instead what we can do is sample at 20 MHz at a center frequency of 95 MHz.</p>
<a class="reference internal image-reference" href="../_images/offtuning.png"><img alt="../_images/offtuning.png" class="align-center" src="../_images/offtuning.png" style="width: 422.40000000000003px; height: 134.4px;" /></a>
<p>The blue box above shows what is actually sampled by the SDR, and the green box displays the portion of the spectrum we want.  Our LO will be set to 95 MHz because that is the frequency to which we ask the SDR to tune. Since 95 MHz is outside of the green box, we won’t get any DC spike.</p>
<p>There is one problem: if we want our signal to be centered at 100 MHz and only contain 5 MHz, we will have to perform a frequency shift, filter, and downsample the signal ourselves (something we will learn how to do later). Fortunately, this process of offtuning, a.k.a applying an LO offset, is often built into the SDRs, where they will automatically perform offtuning and then shift the frequency to your desired center frequency.  We benefit when the SDR can do it internally: we don’t have to send a higher sample rate over our USB or ethernet connection, which bottleneck how high a sample rate we can use.</p>
<p>This subsection regarding DC offsets is a good example of where this textbook differs from others. Your average DSP textbook will discuss sampling, but it tends not to include implementation hurdles such as DC offsets despite their prevalence in practice.</p>
</div>
<div class="section" id="sampling-using-our-sdr">
<h2>Sampling Using our SDR<a class="headerlink" href="#sampling-using-our-sdr" title="Permalink to this headline">¶</a></h2>
<p>For SDR-specific information about performing sampling, see one of the following chapters:</p>
<ul class="simple">
<li><a class="reference internal" href="pluto.html#pluto-chapter"><span class="std std-ref">PlutoSDR in Python</span></a> Chapter</li>
<li><a class="reference internal" href="usrp.html#usrp-chapter"><span class="std std-ref">USRP in Python</span></a> Chapter</li>
</ul>
</div>
<div class="section" id="calculating-average-power">
<h2>Calculating Average Power<a class="headerlink" href="#calculating-average-power" title="Permalink to this headline">¶</a></h2>
<p>For a discrete complex signal, i.e., one we have sampled, we can find the average power by taking the magnitude of each sample, squaring it, and then finding the mean:</p>
<div class="math">
<p><img src="../_images/math/5ce37305be13d8e76bc41fea570f7b3041d860c2.svg" alt="P = \frac{1}{N} \sum_{n=1}^{N} |x[n]|^2"/></p>
</div><p>Remember that the absolute value of a complex number is just the magnitude, i.e., <img class="math" src="../_images/math/a2cfebc8da1e2453e86d1fdf34c5af28729b7ea9.svg" alt="\sqrt{I^2+Q^2}"/></p>
<p>In Python, calculating the average power will look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">avg_pwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is a very useful trick for calculating the average power of a sampled signal.
If your signal has roughly zero mean–which is usually the case in SDR (we will see why later)–then the signal power can be found by taking the variance of the samples. In these circumstances, you can calculate the power this way in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">avg_pwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># (signal should have roughly zero mean)</span>
</pre></div>
</div>
<p>The reason why the variance of the samples calculates average power is quite simple: the equation for variance is <img class="math" src="../_images/math/399bf68509fdd516e4e2437f32dba2c8c9635ff7.svg" alt="\frac{1}{N}\sum^N_{n=1} |x[n]-\mu|^2"/> where <img class="math" src="../_images/math/c859a8f80a5b73b97ecb9d3c15842e979a0f6fe2.svg" alt="\mu"/> is the signal’s mean. That equation looks familiar! If <img class="math" src="../_images/math/c859a8f80a5b73b97ecb9d3c15842e979a0f6fe2.svg" alt="\mu"/> is zero then the equation to determine variance of the samples becomes equivalent to the equation for power.  You can also subtract out the mean from the samples in your window of observation, then take variance.  Just know that if the mean value is not zero, the variance and the power are not equal.</p>
</div>
<div class="section" id="calculating-power-spectral-density">
<h2>Calculating Power Spectral Density<a class="headerlink" href="#calculating-power-spectral-density" title="Permalink to this headline">¶</a></h2>
<p>Last chapter we learned that we can convert a signal to the frequency domain using an FFT, and the result is called the Power Spectral Density (PSD).
But to actually find the PSD of a batch of samples and plot it, we do more than just take an FFT.
We must do the following six operations to calculate PSD:</p>
<ol class="arabic simple">
<li>Take the FFT of our samples.  If we have x samples, the FFT size will be the length of x by default. Let’s use the first 1,024 samples as an example to create a 1,024-size FFT.  The output will be 1,024 complex floats.</li>
<li>Take the magnitude of the FFT output, which provides us 1,024 real floats.</li>
<li>Normalize: divide by the FFT size (<img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/>, or 1,024 in this case).</li>
<li>Square the resulting magnitude to get power.</li>
<li>Convert to dB using <img class="math" src="../_images/math/f4455b0aaee830c84338328975fa7b9956463d04.svg" alt="10 \log_{10}()"/>; we always view PSDs in log scale.</li>
<li>Perform an FFT shift, covered in the previous chapter, to move “0 Hz” in the center and negative frequencies to the left of center.</li>
</ol>
<p>Those six steps in Python are:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Fs</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># lets say we sampled at 1 MHz</span>
<span class="c1"># assume x contains your array of IQ samples</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="c1"># we will only take the FFT of the first 1024 samples, see text below</span>
<span class="n">PSD</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">PSD_log</span> <span class="o">=</span> <span class="mf">10.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">PSD</span><span class="p">)</span>
<span class="n">PSD_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">PSD_log</span><span class="p">)</span>
</pre></div>
</div>
<p>Optionally we can apply a window, like we learned about in the <a class="reference internal" href="frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Frequency Domain</span></a> chapter. Windowing would occur right before the line of code with fft().</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># add the following line after doing x = x[0:1024]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># apply a Hamming window</span>
</pre></div>
</div>
<p>To plot this PSD we need to know the values of the x-axis.
As we learned last chapter, when we sample a signal, we only “see” the spectrum between -Fs/2 and Fs/2 where Fs is our sample rate.
The resolution we achieve in the frequency domain depends on the size of our FFT, which by default is equal to the number of samples on which we perform the FFT operation.
In this case our x-axis is 1,024 equally spaced points between -0.5 MHz and 0.5 MHz.
If we had tuned our SDR to 2.4 GHz, our observation window would be between 2.3995 GHz and 2.4005 GHz.
In Python, shifting the observation window will look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">center_freq</span> <span class="o">=</span> <span class="mf">2.4e9</span> <span class="c1"># frequency we tuned our SDR to</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Fs</span><span class="o">/-</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="c1"># start, stop, step.  centered around 0 Hz</span>
<span class="n">f</span> <span class="o">+=</span> <span class="n">center_freq</span> <span class="c1"># now add center frequency</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">PSD_shifted</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>We should be left with a beautiful PSD!</p>
<p>If you want to find the PSD of millions of samples, don’t do a million-point FFT because it will probably take forever. It will give you an output of a million “frequency bins”, after all, which is too much to show in a plot.
Instead I suggest doing multiple smaller PSDs and averaging them together or displaying them using a spectrogram plot.
Alternatively, if you know your signal is not changing fast, it’s adequate to use a few thousand samples and find the PSD of those; within that time-frame of a few thousand samples you will likely capture enough of the signal to get a nice representation.</p>
<p>Here is a full code example that includes generating a signal (complex exponential at 50 Hz) and noise.  Note that N, the number of samples to simulate, becomes the FFT length because we take the FFT of the entire simulated signal.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">Fs</span> <span class="o">=</span> <span class="mi">300</span> <span class="c1"># sample rate</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span> <span class="c1"># sample period</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2048</span> <span class="c1"># number of samples to simulate</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Ts</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">50</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># simulates sinusoid at 50 Hz</span>

<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># complex noise with unity power</span>
<span class="n">noise_power</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">)</span>

<span class="n">PSD</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">PSD_log</span> <span class="o">=</span> <span class="mf">10.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">PSD</span><span class="p">)</span>
<span class="n">PSD_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">PSD_log</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Fs</span><span class="o">/-</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="c1"># start, stop, step</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">PSD_shifted</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [Hz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Output:</p>
<img alt="../_images/fft_example1.svg" class="align-center" src="../_images/fft_example1.svg" /></div>
<div class="section" id="further-reading">
<h2>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><a class="reference external" href="http://rfic.eecs.berkeley.edu/~niknejad/ee242/pdf/eecs242_lect3_rxarch.pdf" rel="noopener noreferrer" target="_blank">http://rfic.eecs.berkeley.edu/~niknejad/ee242/pdf/eecs242_lect3_rxarch.pdf</a></li>
</ol>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="frequency_domain.html" title="Previous document"><span class="section-number">2. </span>Frequency Domain</a>
        </li>
        <li>
          <a href="digital_modulation.html" title="Next document"><span class="section-number">4. </span>Digital Modulation</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>