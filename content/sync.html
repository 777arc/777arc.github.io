
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>14. Synchronization &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="15. End-to-End Example" href="rds.html" />
    <link rel="prev" title="13. Pulse Shaping" href="pulse_shaping.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Frequency Domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digital Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Noise and dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Channel Coding</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">14. Synchronization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulating-wireless-channel">Simulating Wireless Channel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-synchronization">Time Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-synchronization-with-interpolation">Time Synchronization with Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coarse-frequency-synchronization">Coarse Frequency Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fine-frequency-synchronization">Fine Frequency Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#frame-synchronization">Frame Synchronization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. End-to-End Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="doa.html">16. DOA &amp; Beamforming</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">17. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="pulse_shaping.html" title="previous chapter"><span class="section-number">13. </span>Pulse Shaping</a></li>
      <li>Next: <a href="rds.html" title="next chapter"><span class="section-number">15. </span>End-to-End Example</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pulse_shaping.html" title="Previous document"><span class="section-number">13. </span>Pulse Shaping</a>
        </li>
        <li>
          <a href="rds.html" title="Next document"><span class="section-number">15. </span>End-to-End Example</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="synchronization">
<span id="sync-chapter"></span><h1><span class="section-number">14. </span>Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline">¶</a></h1>
<p>This chapter covers wireless signal synchronization in both time and frequency, to correct for carrier frequency offsets and perform timing alignment at the symbol and frame level.  We will utilize the Mueller and Muller clock recovery technique, and the Costas Loop, in Python.</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>We have discussed how to transmit digitally over the air, utilizing a digital modulation scheme like QPSK and by applying pulse shaping to limit the signal bandwidth.  Channel coding can be used to deal with noisy channels, such as when you have low SNR at the receiver.  Filtering out as much as possible before digitally processing the signal always helps.  In this chapter we will investigate how synchronization is performed on the receiving end.  Synchronization is a set of processing that occurs <em>before</em> demodulation and channel decoding.  The overall tx-channel-rx chain is shown below, with the blocks discussed in this chapter highlighted in yellow.  (This diagram is not all-encompassing–most systems also include equalization and multiplexing).</p>
<a class="reference external image-reference" href="../_images/sync-diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/sync-diagram.svg" class="align-center" src="../_images/sync-diagram.svg" /></a>
</div>
<div class="section" id="simulating-wireless-channel">
<h2>Simulating Wireless Channel<a class="headerlink" href="#simulating-wireless-channel" title="Permalink to this headline">¶</a></h2>
<p>Before we learn how to implement time and frequency synchronization, we need to make our simulated signals more realistic.  Without adding some random time delay, the act of synchronizing in time is trivial.  In fact, you only need to take into account the sample delay of any filters you use.  We also want to simulate a frequency offset because, as we will discuss, oscillators are not perfect; there will always be some offset between the transmitter and receiver’s center frequency.</p>
<p>Let’s examine Python code for simulating a non-integer delay and a frequency offset.  The Python code in this chapter will start from the code we wrote during the pulse shaping Python exercise (click below if you need it); you can consider it the starting point of the code in this chapter, and all new code will come after.</p>
<details>
<summary>Python Code from Pulse Shaping</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># this part came from pulse shaping exercise</span>
<span class="n">num_symbols</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">sps</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_symbols</span><span class="p">)</span> <span class="c1"># Our data to be transmitted, 1&#39;s and 0&#39;s</span>
<span class="n">pulse_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
<span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">:</span>
    <span class="n">pulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sps</span><span class="p">)</span>
    <span class="n">pulse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bit</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># set the first value to either a 1 or -1</span>
    <span class="n">pulse_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pulse_train</span><span class="p">,</span> <span class="n">pulse</span><span class="p">))</span> <span class="c1"># add the 8 samples to the signal</span>

<span class="c1"># Create our raised-cosine filter</span>
<span class="n">num_taps</span> <span class="o">=</span> <span class="mi">101</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.35</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">sps</span> <span class="c1"># Assume sample rate is 1 Hz, so sample period is 1, so *symbol* period is 8</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">51</span><span class="p">,</span> <span class="mi">52</span><span class="p">)</span> <span class="c1"># remember it&#39;s not inclusive of final number</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Filter our signal, in order to apply the pulse shaping</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">pulse_train</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
</details><p>We will leave out the plotting-related code because by now you have probably learned how to plot any signal you want.  Making the plots look pretty, as they often do in this textbook, requires a lot of extra code that is not necessary to understand.</p>
<div class="section" id="adding-a-delay">
<h3>Adding a Delay<a class="headerlink" href="#adding-a-delay" title="Permalink to this headline">¶</a></h3>
<p>We can easily simulate a delay by shifting samples, but it only simulates a delay that is an integer multiple of our sample period.  In the real world the delay will be some fraction of a sample period.  We can simulate the delay of a fraction of a sample by making a “fractional delay” filter, which passes all frequencies but delays the samples by some amount that isn’t limited to the sample interval.  You can think of it as an all-pass filter that applies the same phase shift to all frequencies.  (Recall that a time delay and phase shift are equivalent.)  The Python code to create this filter is shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create and apply fractional delay filter</span>
<span class="n">delay</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1"># fractional delay, in samples</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">21</span> <span class="c1"># number of taps</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># ...-3,-2,-1,0,1,2,3...</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">delay</span><span class="p">)</span> <span class="c1"># calc filter taps</span>
<span class="n">h</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># window the filter to make sure it decays to 0 on both sides</span>
<span class="n">h</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="c1"># normalize to get unity gain, we don&#39;t want to change the amplitude/power</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="c1"># apply filter</span>
</pre></div>
</div>
<p>As you can see, we are calculating the filter taps using a sinc() function.  A sinc in the time domain is a rectangle in the frequency domain, and our rectangle for this filter spans the entire frequency range of our signal.  This filter does not reshape the signal, it just delays it in time.  In our example we are delaying by 0.4 of a sample.  Keep in mind that applying <em>any</em> filter delays a signal by half of the filter taps minus one, due to the act of convolving the signal through the filter.</p>
<p>If we plot the “before” and “after” of filtering a signal, we can observe the fractional delay.  In our plot we zoom into only a couple of symbols.  Otherwise, the fractional delay is not viewable.</p>
<a class="reference external image-reference" href="../_images/fractional-delay-filter.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fractional-delay-filter.svg" class="align-center" src="../_images/fractional-delay-filter.svg" /></a>
</div>
<div class="section" id="adding-a-frequency-offset">
<h3>Adding a Frequency Offset<a class="headerlink" href="#adding-a-frequency-offset" title="Permalink to this headline">¶</a></h3>
<p>To make our simulated signal more realistic, we will apply a frequency offset.  Let’s say that our sample rate in this simulation is 1 MHz (it doesn’t actually matter what it is, but you’ll see why it makes it easier to choose a number).  If we want to simulate a frequency offset of 13 kHz (some arbitrary number), we can do it via the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># apply a freq offset</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># assume our sample rate is 1 MHz</span>
<span class="n">fo</span> <span class="o">=</span> <span class="mi">13000</span> <span class="c1"># simulate freq offset</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span> <span class="c1"># calc sample period</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ts</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="n">Ts</span><span class="p">)</span> <span class="c1"># create time vector</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">fo</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># perform freq shift</span>
</pre></div>
</div>
<p>Below demonstrates the signal before and after the frequency offset is applied.</p>
<a class="reference external image-reference" href="../_images/sync-freq-offset.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/sync-freq-offset.svg" class="align-center" src="../_images/sync-freq-offset.svg" /></a>
<p>We have not been graphing the Q portion since we were transmitting BPSK, making the Q portion always zero.  Now that we’re adding a frequency shift to simulate wireless channels, the energy spreads across I and Q.  From this point on we should be plotting both I and Q.  Feel free to substitute a different frequency offset for your code.  If you lower the offset to around 1 kHz, you will be able to see the sinusoid in the envelope of the signal because it’s oscillating slow enough to span several symbols.</p>
<p>As far as picking an arbitrary sample rate, if you scrutinize the code you will notice what matters is the ratio of <code class="code docutils literal notranslate"><span class="pre">fo</span></code> to <code class="code docutils literal notranslate"><span class="pre">fs</span></code>.</p>
<p>You can pretend that the two code blocks presented earlier simulate a the wireless channel.  The code should come after the transmit-side code (what we did in the pulse shaping chapter) and before the receive-side code, which is what we will explore the rest of this chapter.</p>
</div>
</div>
<div class="section" id="time-synchronization">
<h2>Time Synchronization<a class="headerlink" href="#time-synchronization" title="Permalink to this headline">¶</a></h2>
<p>When we transmit a signal wirelessly, it arrives at the receiver with a random phase shift due to time traveled.  We cannot just start sampling the symbols at our symbol rate because we are unlikely to sample it at the right spot in the pulse, as discussed at the end of the <a class="reference internal" href="pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a> chapter.  Review the three figures at the end of that chapter if you are not following.</p>
<p>Most timing synchronization techniques take the form of a phase lock loop (PLL); we won’t study PLLs here but it’s important to know the term, and you can read about them on your own if you are interested.  PLLs are closed-loop systems that use feedback to continuously adjust something; in our case, a time shift permits us to sample at the peak of the digital symbols.</p>
<p>You can picture timing recovery as a block in the receiver, which accepts a stream of samples and outputs another stream of samples (similar to a filter).  We program this timing recovery block with information about our signal, the most important being the number of samples per symbol (or our best guess at it, if we are not 100% sure what was transmitted).  This block acts as a “decimator”, i.e., our sample output will be a fraction of the number of samples in.  We want one sample per digital symbol, so the decimation rate is simply the samples per symbol.  If the transmitter transmits at 1M symbols per second, and we sample at 16 Msps, we will receive 16 samples per symbol.  That will be the sample rate going into the timing sync block.  The sample rate coming out of the block will be 1 Msps because we want one sample per digital symbol.</p>
<p>Most timing recovery methods rely on the fact that our digital symbols rise and then fall, and the crest is the point at which we want to sample the symbol. To put it another way, we sample the maximum point after taking the absolute value:</p>
<a class="reference internal image-reference" href="../_images/symbol_sync2.png"><img alt="../_images/symbol_sync2.png" class="align-center" src="../_images/symbol_sync2.png" style="width: 667.6px; height: 194.8px;" /></a>
<p>There are many timing recovery methods, most resembling a PLL.  Generally the difference between them is the equation used to perform “correction” on the timing offset, which we denote as <img class="math" src="../_images/math/c859a8f80a5b73b97ecb9d3c15842e979a0f6fe2.svg" alt="\mu"/> or <code class="code docutils literal notranslate"><span class="pre">mu</span></code> in code.  The value of <code class="code docutils literal notranslate"><span class="pre">mu</span></code> gets updated every loop iteration.  It is in units of samples, and you can think of it as how much we have to shift by to be able to sample at the “perfect” time.  So if <code class="code docutils literal notranslate"><span class="pre">mu</span> <span class="pre">=</span> <span class="pre">3.61</span></code> then that means we have to shift the input by 3.61 samples to sample at the right spot.  Because we have 8 samples per symbol, if <code class="code docutils literal notranslate"><span class="pre">mu</span></code> goes over 8 it will just wrap back around to zero.</p>
<p>The following Python code implements the Mueller and Muller clock recovery technique.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># initial estimate of phase of sample</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
<span class="n">out_rail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span> <span class="c1"># stores values, each iteration we need the previous 2 values plus current value</span>
<span class="n">i_in</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># input samples index</span>
<span class="n">i_out</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># output index (let first two outputs be 0)</span>
<span class="k">while</span> <span class="n">i_out</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i_in</span><span class="o">+</span><span class="mi">16</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i_in</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="p">)]</span> <span class="c1"># grab what we think is the &quot;best&quot; sample</span>
    <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">+=</span> <span class="n">sps</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">mm_val</span>
    <span class="n">i_in</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="c1"># round down to nearest int since we are using it as an index</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="c1"># remove the integer part of mu</span>
    <span class="n">i_out</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># increment output index</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">i_out</span><span class="p">]</span> <span class="c1"># remove the first two, and anything after i_out (that was never filled out)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">out</span> <span class="c1"># only include this line if you want to connect this code snippet with the Costas Loop later on</span>
</pre></div>
</div>
<p>The timing recovery block is fed “received” samples, and it produces an output sample one at a time (note the <code class="code docutils literal notranslate"><span class="pre">i_out</span></code> being incremented by 1 each iteration of the loop).  The recovery block doesn’t just use the “received” samples one after another because of the way the loop adjusts <code class="code docutils literal notranslate"><span class="pre">i_in</span></code>.  It will skip some samples in an attempt to pull the “correct” sample, which would be the one at the peak of the pulse.  As the loop processes samples it slowly synchronizes to the symbol, or at least it attempts to by adjusting <code class="code docutils literal notranslate"><span class="pre">mu</span></code>.  Given the code’s structure, the integer part of <code class="code docutils literal notranslate"><span class="pre">mu</span></code> gets added to <code class="code docutils literal notranslate"><span class="pre">i_in</span></code>, and then removed from <code class="code docutils literal notranslate"><span class="pre">mu</span></code> (keep in mind that <code class="code docutils literal notranslate"><span class="pre">mm_val</span></code> can be negative or positive each loop).  Once it is fully synchronized, the loop should only pull the center sample from each symbol/pulse.  You can adjust the constant 0.3, which will change how fast the feedback loop reacts; a higher value will make it react faster, but with higher risk of stability issues.</p>
<p>The next plot shows an example output where we have <em>disabled</em> the fractional time delay as well as the frequency offset.  We only show I because Q is all zeroes with the frequency offset disabled.  The three plots are stacked on top of each other to show how the bits align vertically.</p>
<dl class="docutils">
<dt><strong>Top Plot</strong></dt><dd>Original BPSK symbols, i.e., 1’s and -1’s.  Recall that there are zeroes in between because we want 8 samples per symbol.</dd>
<dt><strong>Middle Plot</strong></dt><dd>Samples after pulse shaping but before the synchronizer.</dd>
<dt><strong>Bottom plot</strong></dt><dd>Output of the symbol synchronizer, which provides just 1 sample per symbol.  That is these samples can be fed directly into a demodulator, which for BPSK is checking whether the value is greater than or less than 0.</dd>
</dl>
<a class="reference external image-reference" href="../_images/time-sync-output.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-output.svg" class="align-center" src="../_images/time-sync-output.svg" /></a>
<p>Let’s focus on the bottom plot, which is the output of the synchronizer.  It took nearly 30 symbols for the synchronization to lock into the right delay.  Due inevitably to the time it takes for synchronizers to lock in, many communications protocols use a preamble that contains a synchronization sequence: it acts as a way to announce that a new packet has arrived, and it gives the receiver time to sync to it.  But after these ~30 samples the synchronizer works perfectly.  We are left with perfect 1’s and -1’s that match the input data.  It helps that this example didn’t have any noise added.  Feel free to add noise or time shifts and see how the synchronizer behaves.  If we were using QPSK then we would be dealing with complex numbers, but the approach would be the same.</p>
</div>
<div class="section" id="time-synchronization-with-interpolation">
<h2>Time Synchronization with Interpolation<a class="headerlink" href="#time-synchronization-with-interpolation" title="Permalink to this headline">¶</a></h2>
<p>Symbol synchronizers tend to interpolate the input samples by some number, e.g., 16, so that it’s able to shift by a <em>fraction</em> of a sample.  The random delay caused by the wireless channel will unlikely be an exact multiple of a sample, so the peak of the symbol may not actually happen on a sample.  It is especially true in a case where there might only be 2 or 4 samples per symbol being received.  By interpolating the samples, it gives us the ability to sample “in between” actual samples, in order to hit the very peak of each symbol.  The output of the synchronizer is still only 1 sample per symbol. The input samples themselves are interpolated.</p>
<p>Our time synchronization Python code we have implemented above did not include any interpolation.  To expand our code, enable the fractional time delay that we implemented at the beginning of this chapter so our received signal has a more realistic delay.  Leave the frequency offset disabled for now.  If you re-run the simulation, you’ll find that the synchronizer fails to fully synchronize to the signal.  That’s because we aren’t interpolating, so the code has no way to “sample between samples” to compensate for the fractional delay.  Let’s add in the interpolation.</p>
<p>A quick way to interpolate a signal in Python is to use scipy’s <code class="code docutils literal notranslate"><span class="pre">signal.resample</span></code> or <code class="code docutils literal notranslate"><span class="pre">signal.resample_poly</span></code>.  These functions both do the same thing but work differently under the hood.  We will use the latter function because it tends to be faster.  Let’s interpolate by 16 (this is arbitrarily chose, you can try different values), i.e., we will be inserting 15 extra samples between each sample.  It can be done in one line of code, and it should happen <em>before</em> we go to perform time synchronization (prior to the large code snippet above).  Let’s also plot the before and after to see the difference:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples_interpolated</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Plot the old vs new</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;before interp&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;after interp&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples_interpolated</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>If we zoom <em>way</em> in, we see that it’s the same signal, just with 16x as many points:</p>
<a class="reference external image-reference" href="../_images/time-sync-interpolated-samples.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-interpolated-samples.svg" class="align-center" src="../_images/time-sync-interpolated-samples.svg" /></a>
<p>Hopefully the reason we need to interpolate inside of the time-sync block is becoming clear.  These extra samples will let us take into account a fraction of a sample delay.  In addition to calculating <code class="code docutils literal notranslate"><span class="pre">samples_interpolated</span></code>, we also have to modify one line of code in our time synchronizer.  We will change the first line inside the while loop to become:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_interpolated</span><span class="p">[</span><span class="n">i_in</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="mi">16</span><span class="p">)]</span>
</pre></div>
</div>
<p>We did a couple things here.  First, we can’t just use <code class="code docutils literal notranslate"><span class="pre">i_in</span></code> as the input sample index anymore.  We have to multiply it by 16 because we interpolated our input samples by 16.  Recall that the feedback loop adjusts the <code class="code docutils literal notranslate"><span class="pre">mu</span></code> variable.  It represents the delay that leads to us sampling at the right moment.  Also recall that after we calculated the new value of <code class="code docutils literal notranslate"><span class="pre">mu</span></code>, we added the integer part to <code class="code docutils literal notranslate"><span class="pre">i_in</span></code>.  Now we will use the remainder part, which is a float from 0 to 1, and it represents the fraction of a sample we need to delay by.  Before we weren’t able to delay by a fraction of a sample, but now we are, at least in increments of 16ths of a sample.  What we do is multiply <code class="code docutils literal notranslate"><span class="pre">mu</span></code> by 16 to figure out how many samples of our interpolated signal we need to delay by.  And then we have to round that number, since the value in the brackets ultimately is an index and must be an integer.  If this paragraph didn’t make sense, try to go back to the initial Mueller and Muller clock recovery code, and also read the comments next to each line of code.</p>
<p>The actual plot output of this new code should look roughly the same as before.  All we really did was make our simulation more realistic by adding a fractional-sample delay, and then we added the interpolator to the synchronizer in order to compensate for that fractional sample delay.</p>
<p>Feel free to play around with different interpolation factors, i.e., change all the 16s to some other value.  You can also try enabling the frequency offset, or adding in white Gaussian noise to the signal before it gets received, to see how that impacts synchronization performance (hint: you might have to adjust that 0.3 multiplier).</p>
<p>If we enable only the frequency offset using a frequency of 1 kHz, we get the following time sync performance.  We have to show both I and Q now that we added a frequency offset:</p>
<a class="reference external image-reference" href="../_images/time-sync-output2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-output2.svg" class="align-center" src="../_images/time-sync-output2.svg" /></a>
<p>It might be hard to see, but the time sync is still working just fine.  It takes about 20 to 30 symbols before it’s locked in.  However, there’s a sinusoid pattern because we still have a frequency offset, and we will learn how to deal with it in the next section.</p>
<p>Below shows the IQ plot (a.k.a. constellation plot) of the signal before and after synchronization.  Remember you can plot samples on an IQ plot using a scatter plot: <code class="code docutils literal notranslate"><span class="pre">plt.plot(np.real(samples),</span> <span class="pre">np.imag(samples),</span> <span class="pre">'.')</span></code>.  In the animation below we have specifically left out the first 30 symbols.  They occurred before the time sync had finished.  The symbols left are all roughly on the unit circle due to the frequency offset.</p>
<a class="reference external image-reference" href="../_images/time-sync-constellation.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-constellation.svg" class="align-center" src="../_images/time-sync-constellation.svg" /></a>
<p>To gain even more insight, we can look at the constellation over time to discern what’s actually happening to the symbols.  At the very beginning, for a short period of time, the symbols are not 0 or on the unit circle.  That is the period in which time sync is finding the right delay.  It’s very quick, watch closely!  The spinning is just the frequency offset.  Frequency is a constant change in phase, so a frequency offset causes spinning of the BPSK (creating a circle in the static/persistent plot above).</p>
<img alt="../_images/time-sync-constellation-animated.gif" class="align-center" src="../_images/time-sync-constellation-animated.gif" />
<p>Hopefully by seeing an example of time sync actually happening, you have a feel for what it does and a general idea of how it works.  In practice, the while loop we created would only work on a small number of samples at a time (e.g., 1000).  You have to remember the value of <code class="code docutils literal notranslate"><span class="pre">mu</span></code> in between calls to the sync function, as well as the last couple values of <code class="code docutils literal notranslate"><span class="pre">out</span></code> and <code class="code docutils literal notranslate"><span class="pre">out_rail</span></code>.</p>
<p>Next we will survey frequency synchronization, which we split up into coarse and fine frequency sync.  Coarse usually comes before time sync, while fine comes after.</p>
</div>
<div class="section" id="coarse-frequency-synchronization">
<h2>Coarse Frequency Synchronization<a class="headerlink" href="#coarse-frequency-synchronization" title="Permalink to this headline">¶</a></h2>
<p>Even though we tell the transmitter and receiver to operate on the same center frequency, there is going to be a slight frequency offset between the two due to either imperfections in hardware (e.g., the oscillator) or a Doppler shift from movement.  This frequency offset will be tiny relative to the carrier frequency, but even a small offset can throw off a digital signal.  The offset will likely change over time, necessitating an always-running feedback loop to correct the offset.  As an example, the oscillator inside the Pluto has a max offset spec of 25 PPM.  That is 25 parts per million relative to the center frequency.  If you are tuned to 2.4 GHz, it would be +/- 60 kHz max offset.  The samples our SDR provides us are at baseband, making any frequency offset manifest in that baseband signal.  A BPSK signal with a small carrier offset will look something like the below time plot, which is obviously not great for demodulating bits.  We must remove any frequency offsets before demodulation.</p>
<a class="reference internal image-reference" href="../_images/carrier-offset.png"><img alt="../_images/carrier-offset.png" class="align-center" src="../_images/carrier-offset.png" style="width: 744.6px; height: 147.6px;" /></a>
<p>Frequency synchronization is usually broken down into coarse sync and fine sync, where coarse corrects large offsets on the order of kHz or more, while the fine sync corrects whatever is left.  Coarse happens before time sync, while fine happens after.</p>
<p>Mathematically, if we have a baseband signal <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> and it is experiencing a frequency (a.k.a. carrier) offset of <img class="math" src="../_images/math/0c8e13216427d3fcc928d732f6a1b2ead245a9f7.svg" alt="f_o"/> Hz, we can represent what is received as:</p>
<div class="math">
<p><img src="../_images/math/a9cd4948a8e460934c220cb41203d2346e1d6a12.svg" alt="r(t) = s(t) e^{j2\pi f_o t} + n(t)"/></p>
</div><p>where <img class="math" src="../_images/math/9a5bb2f9fe74aa0a2242ca907f54bb133b0ca3f7.svg" alt="n(t)"/> is the noise.</p>
<p>The first trick we will learn, in order to perform coarse frequency offset estimation (if we can estimate the offset frequency, then we can undo it), is to take the square of our signal.  Let’s ignore noise for now, to keep the math simpler:</p>
<div class="math">
<p><img src="../_images/math/9ec5450b2123e5d0e20fd6f35232f3310e662e5f.svg" alt="r^2(t) = s^2(t) e^{j4\pi f_o t}"/></p>
</div><p>Let’s see what happens when we take the square of our signal <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> by considering what QPSK would do.  Squaring complex numbers leads to interesting behavior, especially when we are talking about constellations like BPSK and QPSK.  The following animation shows what happens when you square QPSK, then square it again.  I specifically used QPSK instead of BPSK because you can see that when you square QPSK once, you essentially get BPSK.  And then after one more square it becomes one cluster.  (Thank you to <a class="reference external" href="http://ventrella.com/ComplexSquaring/" rel="noopener noreferrer" target="_blank">http://ventrella.com/ComplexSquaring/</a> who created this neat webapp.)</p>
<a class="reference internal image-reference" href="../_images/squaring-qpsk.gif"><img alt="../_images/squaring-qpsk.gif" class="align-center" src="../_images/squaring-qpsk.gif" style="width: 480.0px; height: 468.0px;" /></a>
<p>Let’s watch what happens when our QPSK signal has a small phase rotation and magnitude scaling applied to it, which is more realistic:</p>
<a class="reference internal image-reference" href="../_images/squaring-qpsk2.gif"><img alt="../_images/squaring-qpsk2.gif" class="align-center" src="../_images/squaring-qpsk2.gif" style="width: 480.0px; height: 468.0px;" /></a>
<p>It still becomes one cluster, just with a phase shift.  The main take-away here is that if you square QPSK twice (and BPSK once), it will merge all four clusters of points into one cluster.  Why is that useful?  Well by merging the clusters we are essentially removing the modulation!  If all points are now in the same cluster, that’s like having a bunch of constants in a row.  It’s as if there is no modulation anymore, and the only thing left is the sinusoid caused by the frequency offset (we also have noise but let’s keep ignoring it for now).  It turns out that you have to square the signal N times, where N is the order of the modulation scheme used, which means that this trick only works if you know the modulation scheme ahead of time.  The equation is really:</p>
<div class="math">
<p><img src="../_images/math/d5846eced1c768d7a0703bb7168e341a9b0cb475.svg" alt="r^N(t) = s^N(t) e^{j2N\pi f_o t}"/></p>
</div><p>For our case of BPSK we have an order 2 modulation scheme, so we will use the following equation for our coarse frequency sync:</p>
<div class="math">
<p><img src="../_images/math/9ec5450b2123e5d0e20fd6f35232f3310e662e5f.svg" alt="r^2(t) = s^2(t) e^{j4\pi f_o t}"/></p>
</div><p>We discovered what happens to the <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> portion of the equation, but what about the sinusoid part (a.k.a. complex exponential)?  As we can see, it is adding the <img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/> term, which makes it equivalent to a sinusoid at a frequency of <img class="math" src="../_images/math/04194ee8a94a5914d95f7166a63d9eeef0a33a45.svg" alt="Nf_o"/> instead of just <img class="math" src="../_images/math/0c8e13216427d3fcc928d732f6a1b2ead245a9f7.svg" alt="f_o"/>.  A simple method for figuring out <img class="math" src="../_images/math/0c8e13216427d3fcc928d732f6a1b2ead245a9f7.svg" alt="f_o"/> is to take the FFT of the signal after we square it N times and seeing where the spike occurs.  Let’s simulate it in Python.  We will return to generating our BPSK signal, and instead of applying a fractional-delay to it, we will apply a frequency offset by multiplying the signal by <img class="math" src="../_images/math/226b304dd210bb038b11265f241851a89755b42b.svg" alt="e^{j2\pi f_o t}"/> just like we did in chapter <a class="reference internal" href="filters.html#filters-chapter"><span class="std std-ref">Filters</span></a> to convert a low-pass filter to a high-pass filter.</p>
<p>Using the code from the beginning of this chapter, apply a +13 kHz frequency offset to your digital signal.  It could happen right before or right after the fractional-delay is added; it doesn’t matter which. Regardless, it must happen <em>after</em> pulse shaping but before we do any receive-side functions such as time sync.</p>
<p>Now that we have a signal with a 13 kHz frequency offset, let’s plot the FFT before and after doing the squaring, to see what happens.  By now you should know how to do an FFT, including the abs() and fftshift() operation.  For this exercise it doesn’t matter whether or not you take the log or whether you square it after taking the abs().</p>
<p>First look at the signal before squaring (just a normal FFT):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">samples</span><span class="p">)))</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">psd</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/coarse-freq-sync-before.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/coarse-freq-sync-before.svg" class="align-center" src="../_images/coarse-freq-sync-before.svg" /></a>
<p>We don’t actually see any peak associated with the carrier offset.  It’s covered up by our signal.</p>
<p>Now with the squaring added (just a power of 2 because it’s BPSK):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add this before the FFT line</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>We have to zoom way in to see which frequency the spike is on:</p>
<a class="reference external image-reference" href="../_images/coarse-freq-sync.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/coarse-freq-sync.svg" class="align-center" src="../_images/coarse-freq-sync.svg" /></a>
<p>You can try increasing the number of symbols simulated (e.g., 1000 symbols) so that we have enough samples to work with.  The more samples that go into our FFT, the more accurate our estimation of the frequency offset will be.  Just as a reminder, the code above should come <em>before</em> the timing synchronizer.</p>
<p>The offset frequency spike shows up at <img class="math" src="../_images/math/04194ee8a94a5914d95f7166a63d9eeef0a33a45.svg" alt="Nf_o"/>.  We need to divide this bin (26.6 kHz) by 2 to find our final answer, which is very close to the 13 kHz frequency offset we applied at the beginning of the chapter!  If you had played with that number and it’s no longer 13 kHz, that’s fine.  Just make sure you are aware of what you set it to.</p>
<p>Because our sample rate is 1 MHz, the maximum frequencies we can see are -500 kHz to 500 kHz.  If we take our signal to the power of N, that means we can only “see” frequency offsets up to <img class="math" src="../_images/math/9f8fbbfae43237084e6408414562f2680f1d1700.svg" alt="500e3/N"/>, or in the case of BPSK +/- 250 kHz.  If we were receiving a QPSK signal then it would only be +/- 125 kHz, and carrier offset higher or lower than that would be out of our range using this technique.  To give you a feel for Doppler shift, if you were transmitting in the 2.4 GHz band and either the transmitter or receiver was traveling at 60 mph (it’s the relative speed that matters), it would cause a frequency shift of 214 Hz.  The offset due to a low quality oscillator will probably be the main culprit in this situation.</p>
<p>Actually correcting this frequency offset is done exactly how we simulated the offset in the first place: multiplying by a complex exponential, except with a negative sign since we want to remove the offset.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">max_freq</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">psd</span><span class="p">)]</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span> <span class="c1"># calc sample period</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ts</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="n">Ts</span><span class="p">)</span> <span class="c1"># create time vector</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">max_freq</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>It’s up to you if you want to correct it or change the initial frequency offset we applied at the start to a smaller number (like 500 Hz) to test out the fine frequency sync we will now learn how to do.</p>
</div>
<div class="section" id="fine-frequency-synchronization">
<h2>Fine Frequency Synchronization<a class="headerlink" href="#fine-frequency-synchronization" title="Permalink to this headline">¶</a></h2>
<p>Next we will switch gears to fine frequency sync.  The previous trick is more for coarse sink, and it’s not a closed-loop (feedback type) operation.  But for fine frequency sync we will want a feedback loop that we stream samples through, which once again will be a form of PLL.  Our goal is to get the frequency offset to zero and maintain it there, even if the offset changes over time.  We have to continuously track the offset.  Fine frequency sync techniques work best with a signal that already has been synchronized in time at the symbol level, so the code we discuss in this section will come <em>after</em> timing sync.</p>
<p>We will use a technique called a Costas Loop.  It is a form of PLL that is specifically designed for carrier frequency offset correction for digital signals like BPSK and QPSK.  It was invented by John P. Costas at General Electric in the 1950’s, and it had a major impact on modern digital communications.  The Costas Loop will remove the frequency offset while also fixing any phase offset.  The energy is aligned with the I axis.  Frequency is just a change in phase so they can be tracked as one.  The Costas Loop is summarized using the following diagram (note that 1/2s have been left out of the equations because they don’t functionally matter).</p>
<a class="reference external image-reference" href="../_images/costas-loop.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop.svg" class="align-center" src="../_images/costas-loop.svg" /></a>
<p>The voltage controlled oscillator (VCO) is simply a sin/cos wave generator that uses a frequency based on the input.  In our case, since we are simulating a wireless channel, it isn’t a voltage, but rather a level represented by a variable.  It determines the frequency and phase of the generated sine and cosine waves.  What it’s doing is multiplying the received signal by an internally-generated sinusoid, in an attempt to undo the frequency and phase offset.  This behavior is similar to how an SDR downconverts and creates the I and Q branches.</p>
<p>Below is the Python code that is our Costas Loop:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># These next two params is what to adjust, to make the feedback loop faster or slower (which impacts stability)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.132</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.00932</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
<span class="n">freq_log</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="c1"># adjust the input sample by the inverse of the estimated phase offset</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># This is the error formula for 2nd order Costas Loop (e.g. for BPSK)</span>

    <span class="c1"># Advance the loop (recalc phase and freq offset)</span>
    <span class="n">freq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">freq_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="c1"># convert from angular velocity to Hz for logging</span>
    <span class="n">phase</span> <span class="o">+=</span> <span class="n">freq</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>

    <span class="c1"># Optional: Adjust phase so its always between 0 and 2pi, recall that phase wraps around every 2pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="c1"># Plot freq over time to see how long it takes to hit the right offset</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq_log</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>There is a lot here so let’s step through it.  Some lines are simple and others are super complicated.  <code class="code docutils literal notranslate"><span class="pre">samples</span></code> is our input, and <code class="code docutils literal notranslate"><span class="pre">out</span></code> is the output samples.  <code class="code docutils literal notranslate"><span class="pre">phase</span></code> and <code class="code docutils literal notranslate"><span class="pre">frequency</span></code> are like the <code class="code docutils literal notranslate"><span class="pre">mu</span></code> from the time sync code.  They contain the current offset estimates, and each loop iteration we create the output samples by multiplying the input samples by <code class="code docutils literal notranslate"><span class="pre">np.exp(-1j*phase)</span></code>.  The <code class="code docutils literal notranslate"><span class="pre">error</span></code> variable holds the “error” metric, and for a 2nd order Costas Loop it’s a very simple equation.  We multiply the real part of the sample (I) by the imaginary part (Q), and because Q should be equal to zero for BPSK, the error function is minimized when there is no phase or frequency offset that causes energy to shift from I to Q.  For a 4th order Costas Loop, it’s still relatively simple but not quite one line, as both I and Q will have energy even when there is no phase or frequency offset, for QPSK.  If you are curious what it looks like click below, but we won’t be using it in our code for now.  The reason this works for QPSK is because when you take the absolute value of I and Q, you will get +1+1j, and if there is no phase or frequency offset then the difference between the absolute value of I and Q should be close to zero.</p>
<details>
<summary>Order 4 Costas Loop Error Equation (for those curious)</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For QPSK</span>
<span class="k">def</span> <span class="nf">phase_detector_4</span><span class="p">(</span><span class="n">sample</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">real</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sample</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sample</span><span class="o">.</span><span class="n">real</span>
</pre></div>
</div>
</details><p>The <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="code docutils literal notranslate"><span class="pre">beta</span></code> variables define how fast the phase and frequency update, respectively.  There is some theory behind why I chose those two values; however, we won’t address it here.  If you are curious you can try tweaking <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> and/or <code class="code docutils literal notranslate"><span class="pre">beta</span></code> to see what happens.</p>
<p>We log the value of <code class="code docutils literal notranslate"><span class="pre">freq</span></code> each iteration so we can plot it at the end, to see how the Costas Loop converges on the correct frequency offset.  We have to multiply <code class="code docutils literal notranslate"><span class="pre">freq</span></code> by the sample rate and convert from angular frequency to Hz, by dividing by <img class="math" src="../_images/math/bf50b56b21d67ede45fc1ec5b8213871824fe365.svg" alt="2\pi"/>.  Note that if you performed time sync prior to the Costas Loop, you will have to also divide by your <code class="code docutils literal notranslate"><span class="pre">sps</span></code> (e.g., 8), because the samples coming out of the time sync are at a rate equal to your original sample rate divided by <code class="code docutils literal notranslate"><span class="pre">sps</span></code>.</p>
<p>Lastly, after recalculating phase, we add or remove enough <img class="math" src="../_images/math/adbf740b3ae712140edad99b950ffd8c9ec2919b.svg" alt="2 \pi"/>’s to keep phase between 0 and <img class="math" src="../_images/math/adbf740b3ae712140edad99b950ffd8c9ec2919b.svg" alt="2 \pi"/>,  which wraps phase around.</p>
<p>Our signal before and after the Costas Loop looks like this:</p>
<a class="reference external image-reference" href="../_images/costas-loop-output.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop-output.svg" class="align-center" src="../_images/costas-loop-output.svg" /></a>
<p>And the frequency offset estimation over time, settling on the correct offset (a -300 Hz offset was used in this example signal):</p>
<a class="reference external image-reference" href="../_images/costas-loop-freq-tracking.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop-freq-tracking.svg" class="align-center" src="../_images/costas-loop-freq-tracking.svg" /></a>
<p>It takes nearly 70 samples for the algorithm to fully lock it on the frequency offset.  You can see that in my simulated example there were about -300 Hz left over after the coarse frequency sync.  Yours may vary.  Like I mentioned before, you can disable the coarse frequency sync and set the initial frequency offset to whatever value you want and see if the Costas Loop figures it out.</p>
<p>The Costas Loop, in addition to removing the frequency offset, aligned our BPSK signal to be on the I portion, making Q zero again.  It is a convenient side-effect from the Costas Loop, and it lets the Costas Loop essentially act as our demodulator.  Now all we have to do is take I and see if it’s greater or less than zero.  We won’t actually know how to make negative and positive to 0 and 1 because there may or may not be an inversion; there’s no way for the Costas Loop (or our time sync) to know.  That is where differential coding comes into play.  It removes the ambiguity because 1’s and 0’s are based on whether or not the symbol changed, not whether it was +1 or -1.  If we added differential coding, we would still be using BPSK.  We would be adding a differential coding block right before modulation on the tx side and right after demodulation on the rx side.</p>
<p>Below is an animation of the time sync plus frequency sync running, the time sync actually happens almost immediately but the frequency sync takes nearly the entire animation to fully settle, and this was because <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="code docutils literal notranslate"><span class="pre">beta</span></code> were set too low, to 0.005 and 0.001 respectively.  The code used to generate this animation can be found <a class="reference external" href="https://github.com/777arc/textbook/blob/master/figure-generating-scripts/costas_loop_animation.py" rel="noopener noreferrer" target="_blank">here</a>.</p>
<img alt="../_images/costas_animation.gif" class="align-center" src="../_images/costas_animation.gif" />
</div>
<div class="section" id="frame-synchronization">
<h2>Frame Synchronization<a class="headerlink" href="#frame-synchronization" title="Permalink to this headline">¶</a></h2>
<p>We have discussed how to correct any time, frequency, and phase offsets in our received signal.  But most modern communications protocols are not simply streaming bits at 100% duty cycle.  Instead, they use packets/frames.  At the receiver we need to be able to identify when a new frame begins.  Customarily the frame header (at the MAC layer) contains how many bytes are in the frame.  We can use that information to know how long the frame is, e.g., in units samples or symbols.  Nonetheless, detecting the start of frame is a whole separate task.  Below shows an example WiFi frame structure.  Note how the very first thing transmitted is a PHY-layer header, and the first half of that header is a “preamble”.  This preamble contains a synchronization sequence that the receiver uses to detect start of frames, and it is a sequence known by the receiver beforehand.</p>
<a class="reference internal image-reference" href="../_images/wifi-frame.png"><img alt="../_images/wifi-frame.png" class="align-center" src="../_images/wifi-frame.png" style="width: 772.1999999999999px; height: 147.0px;" /></a>
<p>A common and straightforward method of detecting these sequences at the receiver is to cross-correlate the received samples with the known sequence.  When the sequence occurs, this cross-correlation resembles an autocorrelation (with noise added).  Typically the sequences chosen for preambles will have nice autocorrelation properties, such as the autocorrelation of the sequence creates a single strong spike at 0 and no other spikes.  One example is Barker codes, in 802.11/WiFi a length-11 Barker sequence is used for the 1 and 2 Mbit/sec rates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>+1 +1 +1 −1 −1 −1 +1 −1 −1 +1 −1
</pre></div>
</div>
<p>You can think of it as 11 BPSK symbols.  We can look at the autocorrelation of this sequence very easily in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;same&#39;</span><span class="p">),</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/barker-code.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/barker-code.svg" class="align-center" src="../_images/barker-code.svg" /></a>
<p>You can see it’s 11 (length of the sequence) in the center, and -1 or 0 for all other delays.  It works well for finding the start of a frame because it essentially integrates 11 symbols worth of energy in an attempt to create a 1 bit spike in the output of the cross-correlation.  In fact, the hardest part of performing start-of-frame detection is figuring out a good threshold.  You don’t want frames that aren’t actually part of your protocol to trigger it.  That means in addition to cross-correlation you also have to do some sort of power normalizing, which we won’t consider here.  In deciding a threshold, you have to make a trade-off between probability of detection and probability of false alarms.  Remember that the frame header itself will have information, so some false alarms are OK; you will quickly find it is not actually a frame when you go to decode the header and the CRC inevitably fails (because it wasn’t actually a frame).  Yet while some false alarms are OK, missing a frame detection altogether is bad.</p>
<p>Another sequence with great autocorrelation properties is Zadoff-Chu sequences, which are used in LTE.  They have the benefit of being in sets; you can have multiple different sequences that all have good autocorrelation properties, but they won’t trigger each other (i.e., also good cross-correlation properties, when you cross-correlate different sequences in the set).  Thanks to that feature, different cell towers will be assigned different sequences so that a phone can not only find the start of the frame but also know which tower it is receiving from.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pulse_shaping.html" title="Previous document"><span class="section-number">13. </span>Pulse Shaping</a>
        </li>
        <li>
          <a href="rds.html" title="Next document"><span class="section-number">15. </span>End-to-End Example</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>