
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frequency Domain &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. IQ Sampling" href="sampling.html" />
    <link rel="prev" title="1. Introduction" href="intro.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script> 

<div id="topBanner" class="modal">
  <div class="modal-content">
    <div class="modal-header" style="background-color: rgb(255, 240, 129); text-align:center;">
      <i>-- Announcement from Marc --</i><br>I'm leading a new education-oriented open-source project called <a target="_blank" href="https://iqengine.org">IQEngine</a>!<br>It's a web-based SDR toolkit for analyzing, processing, and sharing RF recordings.  Checkout out our <a target="_blank" href="https://github.com/IQEngine/IQEngine">GitHub</a> and <a target="_blank" href="https://discord.gg/k7C8kp3b76">Discord</a>
      <div class="closeButton">
        <span style="font-size:30px; position:absolute; top:0px; right:5px; cursor:pointer; ">&times;</span>
      </div>
    </div>
  </div>
</div>

<script>
  var banner = document.getElementById("topBanner");
  var closeButton = document.getElementsByClassName("closeButton")[0];
  // Close banner if they have already clicked the close button in the past
  if (localStorage.getItem('pysdrvisited')){
    banner.style.display = "none";
  }
  // When they click the close button
  closeButton.onclick = function() {
    banner.style.display = "none";
    localStorage.setItem('pysdrvisited', true);
  }
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Frequency Domain</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#fourier-series">Fourier Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-frequency-pairs">Time-Frequency Pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fourier-transform">Fourier Transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-frequency-properties">Time-Frequency Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fast-fourier-transform-fft">Fast Fourier Transform (FFT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#negative-frequencies">Negative Frequencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#order-in-time-doesn-t-matter">Order in Time Doesn’t Matter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fft-in-python">FFT in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="#windowing">Windowing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fft-sizing">FFT Sizing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spectrogram-waterfall">Spectrogram/Waterfall</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fft-implementation">FFT Implementation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digital Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Noise and dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Channel Coding</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronization</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. End-to-End Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="doa.html">16. DOA &amp; Beamforming</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">17. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://www.paypal.com/donate/?business=AHW8EDXSCNMKC&no_recurring=0&item_name=Thank+you+for+supporting+PySDR%21++Your+contribution+helps+keep+it+ad-free%2C+and+promotes+future+content+creation+and+refinement.+&currency_code=USD">Donate through PayPal</a></li>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="intro.html" title="previous chapter"><span class="section-number">1. </span>Introduction</a></li>
      <li>Next: <a href="sampling.html" title="next chapter"><span class="section-number">3. </span>IQ Sampling</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Search" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="intro.html" title="Previous document"><span class="section-number">1. </span>Introduction</a>
        </li>
        <li>
          <a href="sampling.html" title="Next document"><span class="section-number">3. </span>IQ Sampling</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="frequency-domain">
<span id="freq-domain-chapter"></span><h1><span class="section-number">2. </span>Frequency Domain<a class="headerlink" href="#frequency-domain" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduces the frequency domain and covers Fourier series, Fourier transform, Fourier properties, FFT, windowing, and spectrograms, using Python examples.</p>
<p>One of the coolest side effects of learning about DSP and wireless communications is that you will also learn to think in the frequency domain.  Most people’s experience with <em>working</em> in the frequency domain is limited to adjusting the bass/mid/treble knobs on a car’s audio system.  Most people’s experience with <em>viewing</em> something in the frequency domain is limited to seeing an audio equalizer, such as this clip:</p>
<img alt="../_images/audio_equalizer.webp" class="align-center" src="../_images/audio_equalizer.webp" />
<p>By the end of this chapter you will understand what the frequency domain really means, how to convert between time and frequency (plus what happens when we do so), and some interesting principles we will use throughout our studies of DSP and SDR.  By the end of this textbook, you will be a master at working in the frequency domain, guaranteed!</p>
<p>First, why do we like to look at signals in the frequency domain?  Well here are two example signals, shown in both the time and frequency domain.</p>
<a class="reference internal image-reference" href="../_images/time_and_freq_domain_example_signals.png"><img alt="Two signals in the time domain may look like noise, but in the frequency domain we see additional features" class="align-center" src="../_images/time_and_freq_domain_example_signals.png" style="width: 576.0px; height: 238.8px;" /></a>
<p>As you can see, in the time domain they both just kind of look like noise, but in the frequency domain we can see different features.  Everything is in the time domain in its natural form; when we sample signals we will be sampling them in the time domain, because you can’t <em>directly</em> sample a signal in the frequency domain.  But the interesting stuff usually happens in the frequency domain.</p>
<div class="section" id="fourier-series">
<h2>Fourier Series<a class="headerlink" href="#fourier-series" title="Permalink to this headline">¶</a></h2>
<p>The basics of the frequency domain start with understanding that any signal can be represented by sine waves summed together.  When we break a signal down into its composite sine waves, we call it a Fourier series.  Here is an example of a signal that is made up of only two sine waves:</p>
<a class="reference external image-reference" href="../_images/summing_sinusoids.svg" rel="noopener noreferrer" target="_blank"><img alt="Simple example of how a signal can be made up of multiple sinusoids, demonstrating the Fourier Series" class="align-center" src="../_images/summing_sinusoids.svg" /></a>
<p>Here is another example; the red curve in the below approximates a sawtooth wave by summing up to 10 sine waves.  We can see that it’s not a perfect reconstruction–it would take an infinite number of sine waves to reproduce this sawtooth wave due to the sharp transitions:</p>
<a class="reference internal image-reference" href="../_images/fourier_series_triangle.gif"><img alt="Animation of the Fourier series decomposition of a triangle wave (a.k.a. sawtooth)" class="align-center" src="../_images/fourier_series_triangle.gif" style="width: 561.4px; height: 180.6px;" /></a>
<p>Some signals require more sine waves than others, and some require an infinite amount, although they can always be approximated with a limited number.  Here is another example of a signal being broken down into a series of sine waves:</p>
<a class="reference internal image-reference" href="../_images/fourier_series_arbitrary_function.gif"><img alt="Animation of the Fourier series decomposition of an arbitrary function made up of square pulses" class="align-center" src="../_images/fourier_series_arbitrary_function.gif" style="width: 561.4px; height: 180.6px;" /></a>
<p>To understand how we can break down a signal into sine waves, or sinusoids, we need to first review the three attributes of a sine wave:</p>
<ol class="arabic simple">
<li>Amplitude</li>
<li>Frequency</li>
<li>Phase</li>
</ol>
<p><strong>Amplitude</strong> indicates the “strength” of the wave, while <strong>frequency</strong> is the number of waves per second.  <strong>Phase</strong> is used to represent how the sine wave is shifted in time, anywhere from 0 to 360 degrees (or 0 to <img class="math" src="../_images/math/bf50b56b21d67ede45fc1ec5b8213871824fe365.svg" alt="2\pi"/>), but it must be relative to something to have any meaning, such as two signals with the same frequency being 30 degrees out of phase with each other.</p>
<a class="reference external image-reference" href="../_images/amplitude_phase_period.svg" rel="noopener noreferrer" target="_blank"><img alt="Reference diagram of amplitude, phase, and frequency of a sine wave (a.k.a. sinusoid)" class="align-center" src="../_images/amplitude_phase_period.svg" /></a>
<p>At this point you may have realized that a “signal” is essentially just a function, usually represented “over time” (i.e., the x-axis). Another attribute that is easy to remember is <strong>period</strong>, which is the inverse of <strong>frequency</strong>. The <strong>period</strong> of a sinusoid is the amount of time, in seconds, for the wave to finish one cycle.  Thus, the unit of frequency is 1/seconds, or Hz.</p>
<p>When we decompose a signal into a summation of sine waves, each one will have a certain <strong>amplitude</strong>, <strong>phase</strong>, and <strong>frequency</strong>.  Each sine wave’s <strong>amplitude</strong> will tell us how strong the <strong>frequency</strong> existed in the original signal.  Don’t worry too much about <strong>phase</strong> for now, other than realizing that the only difference between sin() and cos() is a phase shift (time shift).</p>
<p>It’s more important to understand the underlying concept than the actual equations to solve for a Fourier series, but for those who are interested in the equations I refer you to Wolfram’s concise explanation: <a class="reference external" href="https://mathworld.wolfram.com/FourierSeries.html" rel="noopener noreferrer" target="_blank">https://mathworld.wolfram.com/FourierSeries.html</a>.</p>
</div>
<div class="section" id="time-frequency-pairs">
<h2>Time-Frequency Pairs<a class="headerlink" href="#time-frequency-pairs" title="Permalink to this headline">¶</a></h2>
<p>We have established that signals can be represented as sine waves, which have several attributes. Now, let’s learn to plot signals in the frequency domain. While the time domain demonstrates how a signal changes over time, the frequency domain displays how much of a signal rests in which frequencies. Instead of the x-axis being time it will be frequency.  We can plot a given signal in both time <em>and</em> frequency.  Let’s look at some simple examples to start.</p>
<p>Here is what a sine wave, with frequency f, looks like in the time and frequency domain:</p>
<a class="reference internal image-reference" href="../_images/sine-wave.png"><img alt="The time-frequency Fourier pair of a sine wave, which is an impulse in the frequency domain" class="align-center" src="../_images/sine-wave.png" style="width: 407.4px; height: 171.5px;" /></a>
<p>The time domain should look very familiar. It’s an oscillating function. Don’t worry about at what point in the cycle it starts or how long it lasts.  The take-away is that the signal has a <strong>single frequency</strong>, which is why we see a single spike/peak in the frequency domain.  Whichever frequency that sine wave oscillates at will be where we see the spike in the frequency domain.  The mathematical name for a spike like this is called an “impulse”.</p>
<p>Now what if we had an impulse in the time domain?  Imagine a sound recording of someone clapping their hands or hitting a nail with a hammer.  This time-frequency pair is a little less intuitive.</p>
<a class="reference internal image-reference" href="../_images/impulse.png"><img alt="The time-frequency Fourier pair of an impulse in the time domain, which is a horizontal line (all frequencies) in the frequency domain" class="align-center" src="../_images/impulse.png" style="width: 409.5px; height: 161.0px;" /></a>
<p>As we can see, a spike/impulse in the time domain is flat in the frequency domain, and theoretically it contains every frequency. There is no theoretically perfect impulse because it would have to be infinitely short in the time domain.  Like the sine wave, it doesn’t matter where in the time domain the impulse happens.  The important take-away here is that quick changes in time domain result in many frequencies occurring.</p>
<p>Next let’s look at the time and frequency domain plots of a square wave:</p>
<a class="reference external image-reference" href="../_images/square-wave.svg" rel="noopener noreferrer" target="_blank"><img alt="The time-frequency Fourier pair of a square wave, which is a sinc (sin(x)/x function) in the frequency domain" class="align-center" src="../_images/square-wave.svg" /></a>
<p>This one is also less intuitive, but we can see that the frequency domain has a strong spike, which happens to be at the frequency of the square wave, but there are more spikes as we go higher in frequency.  It is due to the quick change in time domain, just like in the previous example.  But it’s not flat in frequency. It has spikes at intervals, and the level slowly decays (although it will continue forever).  A square wave in time domain has a sin(x)/x pattern in the frequency domain (a.k.a. the sinc function).</p>
<p>Now what if we have a constant signal in the time domain?  A constant signal has no “frequency”.   Let’s see:</p>
<a class="reference internal image-reference" href="../_images/dc-signal.png"><img alt="The time-frequency Fourier pair of a DC signal, which is an impulse at 0 Hz in the frequency domain" class="align-center" src="../_images/dc-signal.png" style="width: 506.40000000000003px; height: 173.60000000000002px;" /></a>
<p>Because there is no frequency, in the frequency domain we have a spike at 0 Hz. It makes sense if you think about it.  The frequency domain is not going to be “empty” because that only happens when there is no signal present (i.e., time domain of 0’s).  We call 0 Hz in the frequency domain “DC”, because it’s caused by a DC signal in time (a constant signal that doesn’t change).  Note that if we increase the amplitude of our DC signal in the time domain, the spike at 0 Hz in the frequency domain will also increase.</p>
<p>Later on we will learn about what exactly the y-axis in the frequency domain plot means, but for now you can think of it as a sort of amplitude that tells you how much of that frequency was present in the time domain signal.</p>
</div>
<div class="section" id="fourier-transform">
<h2>Fourier Transform<a class="headerlink" href="#fourier-transform" title="Permalink to this headline">¶</a></h2>
<p>Mathematically, the “transform” we use to go from the time domain to the frequency domain and back is called the Fourier Transform.  It is defined as follows:</p>
<div class="math">
<p><img src="../_images/math/6ec9b03637d9f36f1f21065d0ea5f51a02de4423.svg" alt="X(f) = \int x(t) e^{-j2\pi ft} dt"/></p>
</div><p>For a signal x(t) we can get the frequency domain version, X(f), using this formula.  We will represent the time domain version of a function with x(t) or y(t), and the corresponding frequency domain version with X(f) and Y(f).  Note the “t” for time, and “f” for frequency. The “j” is simply the imaginary unit. You may have seen it as “i” in high school math class.  We use “j” in engineering and computer science because “i” is often referring to current, and in programming it’s often used as an iterator.</p>
<p>To return to the time domain from frequency is almost the same, aside from a scaling factor and negative sign:</p>
<div class="math">
<p><img src="../_images/math/5be5072ccaf0978ad48c208cd73799c36aef51cd.svg" alt="x(t) = \frac{1}{2 \pi} \int X(f) e^{j2\pi ft} df"/></p>
</div><p>Note that a lot of textbooks and other resources use <img class="math" src="../_images/math/c37cd8faff2fe4e2b7d74bb3d54411948d081962.svg" alt="w"/> in place of the <img class="math" src="../_images/math/f2db2fc8f3c55a36937062e1797243b47a90f001.svg" alt="2\pi f"/>.  <img class="math" src="../_images/math/c37cd8faff2fe4e2b7d74bb3d54411948d081962.svg" alt="w"/> is angular frequency in radians per second, while <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> is in Hz.  All you have to know is that</p>
<div class="math">
<p><img src="../_images/math/198ad5c1c03eb34cf94aa5de5ecc4e89624a2964.svg" alt="\omega = 2 \pi f"/></p>
</div><p>Even though it adds a <img class="math" src="../_images/math/adbf740b3ae712140edad99b950ffd8c9ec2919b.svg" alt="2 \pi"/> term to many equations, it’s easier to stick with frequency in Hz. Ultimately you will work with Hz in your SDR application.</p>
<p>The above equation for the Fourier Transform is the continuous form, which you will only see in math problems.  The discrete form is much closer to what is implemented in code:</p>
<div class="math">
<p><img src="../_images/math/d94eb6f124e7e929c0420fd6d6a19eb14903b593.svg" alt="X_k = \sum_{n=0}^{N-1} x_n e^{-\frac{j2\pi}{N}kn}"/></p>
</div><p>Note that the main difference is we replaced the integral with a summation.  The index <img class="math" src="../_images/math/30d4f39194cc2ced00937a2642c0345222fed6cd.svg" alt="k"/> goes from 0 to N-1.</p>
<p>It’s OK if none of these equations mean much to you. We actually don’t need to use them directly to do cool stuff with DSP and SDRs!</p>
</div>
<div class="section" id="time-frequency-properties">
<h2>Time-Frequency Properties<a class="headerlink" href="#time-frequency-properties" title="Permalink to this headline">¶</a></h2>
<p>Earlier we examined examples of how signals appear in the time domain and the frequency domain.  Now, we will cover five important “Fourier properties”.  These are properties that tell us if we do ____ to our time domain signal, then ____ happens to our frequency domain signal.  It will give us an important insight into the type of Digital Signal Processing (DSP) we will perform on time domain signals in practice.</p>
<ol class="arabic simple">
<li>Linearity Property:</li>
</ol>
<div class="math">
<p><img src="../_images/math/746a7887541f0ad9d3847793bc3a342014dc4d6d.svg" alt="a x(t) + b y(t) \leftrightarrow a X(f) + b Y(f)"/></p>
</div><p>This property is probably the easiest to understand.  If we add two signals in time, then the frequency domain version will also be the two frequency domain signals added together.  It also tells us that if we multiply either one by a scaling factor, the frequency domain will also scale by the same amount.  The utility of this property will become more apparent when we add together multiple signals.</p>
<ol class="arabic simple" start="2">
<li>Frequency Shift Property:</li>
</ol>
<div class="math">
<p><img src="../_images/math/be894b85227c716548c31342eccabe9c1b515b57.svg" alt="e^{2 \pi j f_0 t}x(t) \leftrightarrow X(f-f_0)"/></p>
</div><p>The term to the left of x(t) is what we call a “complex sinusoid” or “complex exponential”. For now, all we need to know is that it’s essentially just a sine wave at frequency <img class="math" src="../_images/math/da647bd66569f61d6a3f16c3c2e09085c351a343.svg" alt="f_0"/>.  This property tells us that if we take a signal <img class="math" src="../_images/math/b52a14c3452fbd1a467b640bb6269127e997a8e3.svg" alt="x(t)"/> and multiply it by a sine wave, then in the frequency domain we get <img class="math" src="../_images/math/8107fe72abc774dcc596c9fa4ee452bf8f6748af.svg" alt="X(f)"/> except shifted by a certain frequency, <img class="math" src="../_images/math/da647bd66569f61d6a3f16c3c2e09085c351a343.svg" alt="f_0"/>.  This shift in frequency may be easier to visualize:</p>
<a class="reference external image-reference" href="../_images/freq-shift.svg" rel="noopener noreferrer" target="_blank"><img alt="Depiction of a frequency shift of a signal in the frequency domain" class="align-center" src="../_images/freq-shift.svg" /></a>
<p>Frequency shift is integral to DSP because we will want to shift signals up and down in frequency for many reasons. This property tells us how to do that (multiply by a sine wave).  Here’s another way to visualize this property:</p>
<a class="reference external image-reference" href="../_images/freq-shift-diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="Visualization of a frequency shift by multiplying by a sine wave or sinusoid" class="align-center" src="../_images/freq-shift-diagram.svg" /></a>
<ol class="arabic simple" start="3">
<li>Scaling in Time Property:</li>
</ol>
<div class="math">
<p><img src="../_images/math/0a4a9d25a8969bb46059aa8e6ae6672fce599b17.svg" alt="x(at) \leftrightarrow X\left(\frac{f}{a}\right)"/></p>
</div><p>On the left hand side of the equation, we can see that we are scaling our signal x(t) in the time domain. Here is an example of a signal being scaled in time, and then what happens to the frequency domain versions of each one.</p>
<a class="reference external image-reference" href="../_images/time-scaling.svg" rel="noopener noreferrer" target="_blank"><img alt="Depiction of the time scaling Fourier transform property in both time and frequency domain" class="align-center" src="../_images/time-scaling.svg" /></a>
<p>Scaling in time essentially shrinks or expands the signal in the x-axis.  What this property tells us is that scaling in the time domain causes inverse scaling in the frequency domain.  For example, when we transmit bits faster we have to use more bandwidth.  The property helps to explain why higher data rate signals take up more bandwidth/spectrum.  If time-frequency scaling was proportional instead of inversely proportional, cellular carriers would be able to transmit all the bits per second they wanted without paying billions for spectrum!  Unfortunately that’s not the case.</p>
<p>Those already familiar with this property may notice a scaling factor missing; it is left out for the sake of simplicity. For practical purposes it doesn’t make a difference.</p>
<ol class="arabic simple" start="4">
<li>Convolution in Time Property:</li>
</ol>
<div class="math">
<p><img src="../_images/math/866b024f252bc95ed034ab893af1cb799453d7d0.svg" alt="\int x(\tau) y(t-\tau) d\tau  \leftrightarrow X(f)Y(f)"/></p>
</div><p>It is called the convolution property because in the time domain we are convolving x(t) and y(t).  You may not know about the convolution operation yet, so for now imagine it like a cross-correlation, although we will be diving deeper into convolutions in <a class="reference internal" href="filters.html#convolution-section"><span class="std std-ref">this section</span></a>. When we convolve time domain signals, it’s equivalent to multiplying the frequency domain versions of those two signals.  It is very different from adding together two signals.  When you add two signals, as we saw, nothing really happens, you just add together the frequency domain version.  But when you convolve two signals, it’s like creating a new third signal from them.  Convolution is the single most important technique in DSP, though we must understand how filters work first to fully grasp it.</p>
<p>Before we move on, to briefly explain why this property is so important, consider this situation: you have one signal you want to receive, and there is an interfering signal next to it.</p>
<a class="reference external image-reference" href="../_images/two-signals.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/two-signals.svg" class="align-center" src="../_images/two-signals.svg" /></a>
<p>The concept of masking is heavily used in programming, so let’s use it here.  What if we could create the mask below, and multiply it by the signal above in order to mask out the one we don’t want?</p>
<a class="reference external image-reference" href="../_images/masking.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/masking.svg" class="align-center" src="../_images/masking.svg" /></a>
<p>We usually perform DSP operations in the time domain, so let’s utilize the convolution property to see how we can do this masking in the time domain.  Let’s say that x(t) is our received signal.  Let Y(f) be the mask we want to apply in the frequency domain.  Well that means y(t) is the time domain representation of our mask, and if we convolve it with x(t), we can “filter out” the signal we don’t want.</p>
<div class="figure" style="text-align: center"><p><img width="70%" src="../_images/tikz-649a79a4e38a50b56f209ae74eca2e3aef3f17e4.svg" alt="Figure made with TikZ" /></p>
</div><p>When we discuss filtering, the convolution property will make more sense.</p>
<ol class="arabic simple" start="5">
<li>Convolution in Frequency Property:</li>
</ol>
<p>Lastly, I want to point out that the convolution property works in reverse, although we won’t be using it as much as the time domain convolution:</p>
<div class="math">
<p><img src="../_images/math/4d0228bed6205664ca7c69fc28ff975676f0e932.svg" alt="x(t)y(t)  \leftrightarrow  \int X(g) Y(f-g) dg"/></p>
</div><p>There are other properties, but the above five are the most crucial to understand in my opinion.  Even though we didn’t step through the proof for each property, the point is we use the mathematical properties to gain insight into what happens to real signals when we do analysis and processing.  Don’t get caught up on the equations. Make sure you understand the description of each property.</p>
</div>
<div class="section" id="fast-fourier-transform-fft">
<h2>Fast Fourier Transform (FFT)<a class="headerlink" href="#fast-fourier-transform-fft" title="Permalink to this headline">¶</a></h2>
<p>Now back to the Fourier Transform. I showed you the equation for the discrete Fourier Transform, but what you will be using while coding 99.9% of the time will be the FFT function, fft().  The Fast Fourier Transform (FFT) is simply an algorithm to compute the discrete Fourier Transform.  It was developed decades ago, and even though there are variations on the implementation, it’s still the reigning leader for computing a discrete Fourier transform. Lucky, considering they used “Fast” in the name.</p>
<p>The FFT is a function with one input and one output.  It converts a signal from time to frequency:</p>
<a class="reference external image-reference" href="../_images/fft-block-diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="FFT is a function with one input (time domain) and one output (frequency domain)" class="align-center" src="../_images/fft-block-diagram.svg" /></a>
<p>We will only be dealing with 1 dimension FFTs in this textbook (2D is used for image processing and other applications). For our purposes, think of the FFT function as having one input: a vector of samples, and one output: the frequency domain version of that vector of samples.  The size of the output is always the same as the size of the input. If I feed 1,024 samples into the FFT, I will get 1,024 out.  The confusing part is that the output will always be in the frequency domain, and thus the “span” of the x-axis if we were to plot it doesn’t change based on the number of samples in the time domain input.  Let’s visualize that by looking at the input and output arrays, along with the units of their indices:</p>
<a class="reference external image-reference" href="../_images/fft-io.svg" rel="noopener noreferrer" target="_blank"><img alt="Reference diagram for the input (seconds) and output (bandwidth) format of the FFT function showing frequency bins and delta-t and delta-f" class="align-center" src="../_images/fft-io.svg" /></a>
<p>Because the output is in the frequency domain, the span of the x-axis is based on the sample rate, which we will cover next chapter.  When we use more samples for the input vector, we get a better resolution in the frequency domain (in addition to processing more samples at once).  We don’t actually “see” more frequencies by having a larger input. The only way would be to increase the sample rate (decrease the sample period <img class="math" src="../_images/math/39bb0cf165301516f1e7396af7393a5b3f6c733e.svg" alt="\Delta t"/>).</p>
<p>How do we actually plot this output?  As an example let’s say that our sample rate was 1 million samples per second (1 MHz).  As we will learn next chapter, that means we can only see signals up to 0.5 MHz, regardless of how many samples we feed into the FFT.  The way the output of the FFT gets represented is as follows:</p>
<a class="reference external image-reference" href="../_images/negative-frequencies.svg" rel="noopener noreferrer" target="_blank"><img alt="Introducing negative frequencies" class="align-center" src="../_images/negative-frequencies.svg" /></a>
<p>It is always the case; the output of the FFT will always show <img class="math" src="../_images/math/cb05020c98608fb3c62ed9132b03cb70bfeac2d4.svg" alt="\text{-} f_s/2"/> to <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/> where <img class="math" src="../_images/math/7daaccc7c28018a253e53d5cde99a13764df9a8d.svg" alt="f_s"/> is the sample rate.  I.e., the output will always have a negative portion and positive portion.  If the input is complex, the negative and positive portions will be different, but if it’s real then they will be identical.</p>
<p>Regarding the frequency interval, each bin corresponds to <img class="math" src="../_images/math/da39ae114c94fb9dc38f7c6bbe66183011c21dc3.svg" alt="f_s/N"/> Hz, i.e., feeding in more samples to each FFT will lead to more granular resolution in your output.  A very minor detail that can be ignored if you are new: mathematically, the very last index does not correspond to <em>exactly</em> <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/>, rather it’s <img class="math" src="../_images/math/85b4914ed3d51eb47935368044def8b2299898e1.svg" alt="f_s/2 - f_s/N"/> which for a large <img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/> will be approximately <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/>.</p>
</div>
<div class="section" id="negative-frequencies">
<h2>Negative Frequencies<a class="headerlink" href="#negative-frequencies" title="Permalink to this headline">¶</a></h2>
<p>What in the world is a negative frequency?  For now, just know that they have to do with using complex numbers (imaginary numbers)–there isn’t really such thing as a “negative frequency” when it comes to transmitting/receiving RF signals, it’s just a representation we use.  Here’s an intuitive way to think about it.  Consider we tell our SDR to tune to 100 MHz (the FM radio band) and sample at a rate of 10 MHz.  In other words, we will view the spectrum from 95 MHz to 105 MHz.  Perhaps there are three signals present:</p>
<a class="reference external image-reference" href="../_images/negative-frequencies2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/negative-frequencies2.svg" class="align-center" src="../_images/negative-frequencies2.svg" /></a>
<p>Now, when the SDR gives us the samples, it will appear like this:</p>
<a class="reference external image-reference" href="../_images/negative-frequencies3.svg" rel="noopener noreferrer" target="_blank"><img alt="Negative frequencies are simply the frequencies below the center (a.k.a. carrier) frequency that the radio tuned to" class="align-center" src="../_images/negative-frequencies3.svg" /></a>
<p>Remember that we tuned the SDR to 100 MHz.  So the signal that was at about 97.5 MHz shows up at -2.5 MHz when we represent it digitally, which is technically a negative frequency.  In reality it’s just a frequency lower than the center frequency.  This will make more sense when we learn more about sampling and obtain experience using our SDRs.</p>
</div>
<div class="section" id="order-in-time-doesn-t-matter">
<h2>Order in Time Doesn’t Matter<a class="headerlink" href="#order-in-time-doesn-t-matter" title="Permalink to this headline">¶</a></h2>
<p>One last property before we jump into FFTs.  The FFT function sort of “mixes around” the input signal to form the output, which has a different scale and units. We are no longer in the time domain after all.  A good way to internalize this difference between domains is realizing that changing the order things happen in the time domain doesn’t change the frequency components in the signal.  I.e., the FFT of the following two signals will both have the same two spikes because the signal is just two sine waves at different frequencies.  Changing the order the sine waves occur doesn’t change the fact that they are two sine waves at different frequencies.</p>
<a class="reference internal image-reference" href="../_images/fft_signal_order.png"><img alt="When performing an FFT on a set of samples, the order in time that different frequencies occurred within those samples doesn't change the resulting FFT output" class="align-center" src="../_images/fft_signal_order.png" style="width: 634.0px; height: 224.0px;" /></a>
<p>Technically, the phase of the FFT values will change because of the time-shift of the sinusoids.  However, for the first several chapters of this textbook we will mostly be concerned with the magnitude of the FFT.</p>
</div>
<div class="section" id="fft-in-python">
<h2>FFT in Python<a class="headerlink" href="#fft-in-python" title="Permalink to this headline">¶</a></h2>
<p>Now that we have learned about what an FFT is and how the output is represented, let’s actually look at some Python code and use Numpy’s FFT function, np.fft.fft().  It is recommended that you use a full Python console/IDE on your computer, but in a pinch you can use the online web-based Python console linked at the bottom of the navigation bar on the left.</p>
<p>First we need to create a signal in the time domain.  Feel free to follow along with your own Python console. To keep things simple, we will make a simple sine wave at 0.15 Hz.  We will also use a sample rate of 1 Hz, meaning in time we sample at 0, 1, 2, 3 seconds, etc.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.15</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>If we plot <code class="code docutils literal notranslate"><span class="pre">s</span></code> it looks like:</p>
<a class="reference internal image-reference" href="../_images/fft-python1.png"><img alt="../_images/fft-python1.png" class="align-center" src="../_images/fft-python1.png" style="width: 477.4px; height: 282.79999999999995px;" /></a>
<p>Next let’s use Numpy’s FFT function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>If we look at <code class="code docutils literal notranslate"><span class="pre">S</span></code> we see it’s an array of complex numbers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span>  <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.01865008</span> <span class="o">+</span><span class="mf">0.00000000e+00</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01171553</span> <span class="o">-</span><span class="mf">2.79073782e-01</span><span class="n">j</span><span class="p">,</span><span class="mf">0.02526446</span> <span class="o">-</span><span class="mf">8.82681208e-01</span><span class="n">j</span><span class="p">,</span>  <span class="mf">3.50536075</span> <span class="o">-</span><span class="mf">4.71354150e+01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.15045671</span> <span class="o">+</span><span class="mf">1.31884375e+00</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.10769903</span> <span class="o">+</span><span class="mf">7.10452463e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.09435855</span> <span class="o">+</span><span class="mf">5.01303240e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08808671</span> <span class="o">+</span><span class="mf">3.92187956e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08454414</span> <span class="o">+</span><span class="mf">3.23828386e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08231753</span> <span class="o">+</span><span class="mf">2.76337148e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08081535</span> <span class="o">+</span><span class="mf">2.41078885e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.07974909</span> <span class="o">+</span><span class="mf">2.13663710e-01</span><span class="n">j</span><span class="p">,</span><span class="o">...</span>
</pre></div>
</div>
<p>Hint: regardless of what you’re doing, if you ever run into complex numbers, try calculating the magnitude and the phase and see if they make more sense.  Let’s do exactly that, and plot the magnitude and phase.  In most languages, abs() is a function for magnitude of a complex number.  The function for phase varies, but in Python it’s <code class="code docutils literal notranslate"><span class="pre">np.angle()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">S_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">S_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S_mag</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S_phase</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/fft-python2.png"><img alt="../_images/fft-python2.png" class="align-center" src="../_images/fft-python2.png" style="width: 526.4px; height: 465.6px;" /></a>
<p>Right now we aren’t providing any x-axis to the plots, it’s just the index of the array (counting up from 0).  Due to mathematical reasons, the output of the FFT has the following format:</p>
<a class="reference external image-reference" href="../_images/fft-python3.svg" rel="noopener noreferrer" target="_blank"><img alt="Arrangement of the output of an FFT before doing an FFT shift" class="align-center" src="../_images/fft-python3.svg" /></a>
<p>But we want 0 Hz (DC) in the center and negative freqs to the left (that’s just how we like to visualize things).  So any time we do an FFT we need to perform an “FFT shift”, which is just a simple array rearrangement operation, kind of like a circular shift but more of a “put this here and that there”.  The diagram below fully defines what the FFT shift operation does:</p>
<a class="reference external image-reference" href="../_images/fft-python4.svg" rel="noopener noreferrer" target="_blank"><img alt="Reference diagram of the FFT shift function, showing positive and negative frequencies and DC" class="align-center" src="../_images/fft-python4.svg" /></a>
<p>For our convenience, Numpy has an FFT shift function, <code class="code docutils literal notranslate"><span class="pre">np.fft.fftshift()</span></code>.  Replace the np.fft.fft() line with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<p>We also need to figure out the x-axis values/label.  Recall that we used a sample rate of 1 Hz to keep things simple.  That means the left edge of the frequency domain plot will be -0.5 Hz and the right edge will be 0.5 Hz.  If that doesn’t make sense, it will after you get through the chapter on <a class="reference internal" href="sampling.html#sampling-chapter"><span class="std std-ref">IQ Sampling</span></a>.  Let’s stick to that assumption that our sample rate was 1 Hz, and plot the FFT output’s magnitude and phase with a proper x-axis label.  Here is the final version of this Python example and the output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">Fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Hz</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># number of points to simulate, and our FFT size</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># because our sample rate is 1 Hz</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.15</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="n">S_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">S_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Fs</span><span class="o">/-</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">S_mag</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">S_phase</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/fft-python5.png"><img alt="../_images/fft-python5.png" class="align-center" src="../_images/fft-python5.png" style="width: 518.4px; height: 442.40000000000003px;" /></a>
<p>Note that we see our spike at 0.15 Hz, which is the frequency we used when creating the sine wave. So that means our FFT worked!  If we did not know the code used to generate that sine wave, but we were just given the list of samples, we could use the FFT to determine the frequency. The reason why we see a spike also at -0.15 Hz has to do with the fact it was a real signal, not complex, and we will get deeper into that later.</p>
</div>
<div class="section" id="windowing">
<h2>Windowing<a class="headerlink" href="#windowing" title="Permalink to this headline">¶</a></h2>
<p>When we use an FFT to measure the frequency components of our signal, the FFT assumes that it’s being given a piece of a <em>periodic</em> signal.  It behaves as if the piece of signal we provided continues to repeat indefinitely. It’s as if the last sample of the slice connects back to the first sample.  It stems from the theory behind the Fourier Transform.  It means that we want to avoid sudden transitions between the first and last sample because sudden transitions in the time domain look like many frequencies, and in reality our last sample doesn’t actually connect back to our first sample.  To put it simply: if we are doing an FFT of 100 samples, using <code class="code docutils literal notranslate"><span class="pre">np.fft.fft(x)</span></code>, we want <code class="code docutils literal notranslate"><span class="pre">x[0]</span></code> and <code class="code docutils literal notranslate"><span class="pre">x[99]</span></code> to be equal or close in value.</p>
<p>The way we make up for this cyclic property is through “windowing”.  Right before the FFT, we multiply the slice of signal by a window function, which is just any function that tapers to zero on both ends.  That ensures the slice of signal will begin and end at zero and connect.  Common window functions include Hamming, Hanning, Blackman, and Kaiser.  When you don’t apply any windowing, it’s called using a “rectangular” window because it’s like multiplying by an array of ones.   Here is what several window functions look like:</p>
<a class="reference external image-reference" href="../_images/windows.svg" rel="noopener noreferrer" target="_blank"><img alt="Windowing function in time and frequency domain of rectangular, hamming, hanning, bartlet, blackman, and kaiser windows" class="align-center" src="../_images/windows.svg" /></a>
<p>A simple approach for beginners is to just stick with a Hamming window, which can be created in Python with <code class="code docutils literal notranslate"><span class="pre">np.hamming(N)</span></code> where N is the number of elements in the array, which is your FFT size.  In the above exercise, we would apply the window right before the FFT. After the 2nd line of code we would insert:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>If you are afraid of choosing the wrong window, don’t be.  The difference between Hamming, Hanning, Blackman, and Kaiser is very minimal compared to not using a window at all since they all taper to zero on both sides and solve the underlying problem.</p>
</div>
<div class="section" id="fft-sizing">
<h2>FFT Sizing<a class="headerlink" href="#fft-sizing" title="Permalink to this headline">¶</a></h2>
<p>The last thing to note is FFT sizing.  The best FFT size is always an order of 2 because of the way the FFT is implemented.  You can use a size that is not an order of 2, but it will be slower. Common sizes are between 128 and 4,096, although you can certainly go larger.  In practice we may have to process signals that are millions or billions of samples long, so we need to break up the signal and do many FFTs.  That means we will get many outputs. We can either average them up or plot them over time (especially when our signal is changing over time).  You don’t have to put <em>every</em> sample of a signal through an FFT to get a good frequency domain representation of that signal. For example you could only FFT 1,024 out of every 100k samples in a signal and it will still probably look fine, as long as the signal is always on.</p>
</div>
<div class="section" id="spectrogram-waterfall">
<h2>Spectrogram/Waterfall<a class="headerlink" href="#spectrogram-waterfall" title="Permalink to this headline">¶</a></h2>
<p>A spectrogram is the plot that shows frequency over time.  It is simply a bunch of FFTs stacked together (vertically, if you want frequency on the horizontal axis).  We can also show it in real-time, often referred to as a waterfall.  A spectrum analyzer is the piece of equipment that shows this spectrogram/waterfall.  The diagram below shows how an array of IQ samples can be sliced up to form a spectrogram:</p>
<a class="reference external image-reference" href="../_images/spectrogram_diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="Spectrogram (a.k.a. waterfall) diagram showing how FFT slices are arrange/stacked to form a time-frequency plot" class="align-center" src="../_images/spectrogram_diagram.svg" /></a>
<p>Because a spectrogram involves plotting 2D data, it’s effectively a 3D plot, so we have to use a colormap to represent the FFT magntiudes, which are the “values” we want to plot.  Here is an example of a spectrogram, with frequency on the horizontal/x-axis and time on the vertical/y-axis.  Blue represents the lowest energy and red is the highest. We can see that there is a strong spike at DC (0 Hz) in the center with a varying signal around it.  Blue represents our noise floor.</p>
<a class="reference internal image-reference" href="../_images/waterfall.png"><img alt="../_images/waterfall.png" class="align-center" src="../_images/waterfall.png" style="width: 463.2px; height: 297.59999999999997px;" /></a>
<p>Remember, it’s just rows of FFTs stacked on top of each other, each row is 1 FFT (technically, the magnitude of 1 FFT).  Be sure to time-slice your input signal in slices of your FFT size (e.g., 1024 samples per slice).   Before jumping into the code to produce a spectrogram, here is an example signal we will use, it is simply a tone in white noise:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span>

<span class="c1"># Generate tone plus noise</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># time vector</span>
<span class="n">f</span> <span class="o">=</span> <span class="mf">50e3</span> <span class="c1"># freq of tone</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>Here is what it looks like in the time domain (first 200 samples):</p>
<a class="reference external image-reference" href="../_images/spectrogram_time.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/spectrogram_time.svg" class="align-center" src="../_images/spectrogram_time.svg" /></a>
<p>In Python we can generate a spectrogram as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># simulate the signal above, or use your own signal</span>

<span class="n">fft_size</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">num_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="n">fft_size</span> <span class="c1"># // is an integer division which rounds down</span>
<span class="n">spectrogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">fft_size</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rows</span><span class="p">):</span>
    <span class="n">spectrogram</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">fft_size</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">fft_size</span><span class="p">])))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">spectrogram</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_rate</span><span class="o">/-</span><span class="mi">2</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [MHz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Time [s]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Which should produce the following, which is not the most interesting spectrogram because there is no time-varying behavior.  There are two tones because we simulated a real signal, and real signals always have a negative PSD that matches the positive side.  For more interesting examples of spectrograms, checkout <a class="reference external" href="https://www.IQEngine.org" rel="noopener noreferrer" target="_blank">https://www.IQEngine.org</a>!</p>
<a class="reference external image-reference" href="../_images/spectrogram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/spectrogram.svg" class="align-center" src="../_images/spectrogram.svg" /></a>
</div>
<div class="section" id="fft-implementation">
<h2>FFT Implementation<a class="headerlink" href="#fft-implementation" title="Permalink to this headline">¶</a></h2>
<p>Even though NumPy has already implemented the FFT for us, it’s nice to know the basics of how it works under the hood.  The most popular FFT algorithm is the Cooley-Tukey FFT algorithm, first invented around 1805 by Carl Friedrich Gauss and then later rediscovered and popularized by James Cooley and John Tukey in 1965.</p>
<p>The basic version of this algorithm works on power-of-two size FFTs, and is intended for complex inputs but can also work on real inputs.   The building block of this algorithm is known as the butterfly, which is essentially a N = 2 size FFT, consisting of two multiplies and two summations:</p>
<a class="reference external image-reference" href="../_images/butterfly.svg" rel="noopener noreferrer" target="_blank"><img alt="Cooley-Tukey FFT algorithm butterfly radix-2" class="align-center" src="../_images/butterfly.svg" /></a>
<p>or</p>
<div class="math">
<p><img src="../_images/math/ee02b6e199980917a03a4cd85286ef229302baaf.svg" alt="y_0 = x_0 + x_1 w^k_N

y_1 = x_0 - x_1 w^k_N"/></p>
</div><p>where <img class="math" src="../_images/math/6263399236c5a56bde126a7379b21695d1d387b5.svg" alt="w^k_N = e^{j2\pi k/N}"/> are known as twiddle factors (<img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/> is the size of the sub-FFT and <img class="math" src="../_images/math/30d4f39194cc2ced00937a2642c0345222fed6cd.svg" alt="k"/> is the index).  Note that the input and output is intended to be complex, e.g., <img class="math" src="../_images/math/3b19f90fb8d3bf3eec8b88e878bc1c8eb2b9587e.svg" alt="x_0"/> might be 0.6123 - 0.5213j, and the sums/multiplies are complex.</p>
<p>The algorithm is recursive and breaks itself in half until all that is left is a series of butterflies, this is depicted below using a size 8 FFT:</p>
<a class="reference external image-reference" href="../_images/butterfly2.svg" rel="noopener noreferrer" target="_blank"><img alt="Cooley-Tukey FFT algorithm size 8" class="align-center" src="../_images/butterfly2.svg" /></a>
<p>Each column in this pattern is a set of operations that can be done in parallel, and <img class="math" src="../_images/math/7eac0d148af16eec5464a069fe4fa5b4d47ee944.svg" alt="log_2(N)"/> steps are performed, which is why the computational complexity of the FFT is O(<img class="math" src="../_images/math/5fabb828b2deaaf79caebf224a58406797a44b87.svg" alt="N\log N"/>) while a DFT is O(<img class="math" src="../_images/math/f564f3173652e9963cb1e0399c08db8d295548bb.svg" alt="N^2"/>).</p>
<p>For those who prefer to think in code rather than equations, the following shows a simple Python implementation of the FFT, along with an example signal consisting of a tone plus noise, to try the FFT out with.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">twiddle_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">x_even</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># yay recursion!</span>
    <span class="n">x_odd</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_even</span> <span class="o">+</span> <span class="n">twiddle_factors</span> <span class="o">*</span> <span class="n">x_odd</span><span class="p">,</span>
                           <span class="n">x_even</span> <span class="o">-</span> <span class="n">twiddle_factors</span> <span class="o">*</span> <span class="n">x_odd</span><span class="p">])</span>

<span class="c1"># Simulate a tone + noise</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="n">f_offset</span> <span class="o">=</span> <span class="mf">0.2e6</span> <span class="c1"># 200 kHz offset from carrier</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f_offset</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># unity complex noise</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">n</span> <span class="c1"># 0 dB SNR</span>

<span class="c1"># Perform fft, fftshift, convert to dB</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">X_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># equivalent to np.fft.fftshift</span>
<span class="n">X_mag</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X_shifted</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">/-</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="mf">1e6</span> <span class="c1"># plt in MHz</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">X_mag</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">X_mag</span><span class="p">)],</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X_mag</span><span class="p">),</span> <span class="s1">&#39;rx&#39;</span><span class="p">)</span> <span class="c1"># show max</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [MHz]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude [dB]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/fft_in_python.svg" rel="noopener noreferrer" target="_blank"><img alt="python implementation of fft example" class="align-center" src="../_images/fft_in_python.svg" /></a>
<p>For those interested in JavaScript and/or WebAssembly based implementations, check out the <a class="reference external" href="https://github.com/IQEngine/WebFFT" rel="noopener noreferrer" target="_blank">WebFFT</a> library for performing FFTs in web or NodeJS applications, it includes several implementations under the hood, and there is a <a class="reference external" href="https://webfft.com" rel="noopener noreferrer" target="_blank">benchmarking tool</a> used to compare the performance of each implementation.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="intro.html" title="Previous document"><span class="section-number">1. </span>Introduction</a>
        </li>
        <li>
          <a href="sampling.html" title="Next document"><span class="section-number">3. </span>IQ Sampling</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>