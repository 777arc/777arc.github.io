
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>11. IQ Files and SigMF &#8212; PySDR: A Guide to SDR and DSP using Python 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="12. Multipath Fading" href="multipath_fading.html" />
    <link rel="prev" title="10. Channel Coding" href="channel_coding.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Frequency Domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digital Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Noise and dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Channel Coding</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. IQ Files and SigMF</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#binary-files">Binary Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#python-examples">Python Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#visually-analyzing-an-rf-file">Visually Analyzing an RF File</a></li>
<li class="toctree-l2"><a class="reference internal" href="#max-values-and-saturation">Max Values and Saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sigmf-and-annotating-iq-files">SigMF and Annotating IQ Files</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronization</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">15. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="channel_coding.html" title="previous chapter"><span class="section-number">10. </span>Channel Coding</a></li>
      <li>Next: <a href="multipath_fading.html" title="next chapter"><span class="section-number">12. </span>Multipath Fading</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="channel_coding.html" title="Previous document"><span class="section-number">10. </span>Channel Coding</a>
        </li>
        <li>
          <a href="multipath_fading.html" title="Next document"><span class="section-number">12. </span>Multipath Fading</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="iq-files-and-sigmf">
<span id="iq-files-chapter"></span><h1><span class="section-number">11. </span>IQ Files and SigMF<a class="headerlink" href="#iq-files-and-sigmf" title="Permalink to this headline">¶</a></h1>
<p>In all our previous Python examples we stored signals as 1D NumPy arrays of type “complex float”.  In this chapter we learn how signals can be stored to a file and then read back into Python, as well as introduce the SigMF standard.  Storing signal data in a file is extremeley useful; you may want to record a signal to a file in order to manually analyze it offline, or share it with a colleague, or build a whole dataset.</p>
<div class="section" id="binary-files">
<h2>Binary Files<a class="headerlink" href="#binary-files" title="Permalink to this headline">¶</a></h2>
<p>Recall that a digital signal at baseband is a sequence of complex numbers.</p>
<p>Example: [0.123 + j0.512,    0.0312 + j0.4123,    0.1423 + j0.06512, …]</p>
<p>These numbers correspond to [I+jQ, I+jQ, I+jQ, I+jQ, I+jQ, I+jQ, I+jQ, …]</p>
<p>When we want to save complex numbers to a file, we save them in the format IQIQIQIQIQIQIQIQ.  I.e., we store a bunch of floats in a row, and when we read them back we must separate them back into [I+jQ, I+jQ, …].</p>
<p>While it’s possible to store the complex numbers in a text file or csv file, we prefer to save them in what’s called a “binary file” to save space.  At high sample rates your signal recordings could easily be multiple GB, and we want to be as memory efficient as possible.  If you have ever opened a file in a text editor and it looked incomprehensible like the screenshot below, it was probably binary.  Binary files contain a series of bytes, and you have to keep track of the format yourself.  Binary files are the most efficient way to store data, assuming all possible compression has been performed.  Because our signals usually appear like a random sequence of floats, we typically do not attempt to compress the data.  Binary files are used for plenty of other things, e.g., compiled programs (called “binaries”).  When used to save signals, we call them binary “IQ files”, utilizing the file extension .iq.</p>
<a class="reference internal image-reference" href="../_images/binary_file.png"><img alt="../_images/binary_file.png" class="align-center" src="../_images/binary_file.png" style="width: 840.0px; height: 301.7px;" /></a>
<p>In Python, the default complex type is np.complex128, which uses two 64-bit floats per sample.  But in DSP/SDR, we tend to use 32-bit floats instead because the ADCs on our SDRs don’t have <strong>that</strong> much precision to warrant 64-bit floats.  In Python we will use <strong>np.complex64</strong>, which uses two 32-bit floats.  When you are simply processing a signal in Python it doesn’t really matter, but when you go to save the 1d array to a file, you want to make sure it’s an array of np.complex64 first.</p>
</div>
<div class="section" id="python-examples">
<h2>Python Examples<a class="headerlink" href="#python-examples" title="Permalink to this headline">¶</a></h2>
<p>In Python, and numpy specifically, we use the <code class="code docutils literal notranslate"><span class="pre">tofile()</span></code> function to store a numpy array to a file.  Here is a short example of creating a simple BPSK signal plus noise and saving it to a file in the same directory we ran our script from:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">num_symbols</span> <span class="o">=</span> <span class="mi">10000</span>

<span class="n">x_symbols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_symbols</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># -1 and 1&#39;s</span>
<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_symbols</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_symbols</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># AWGN with unity power</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">x_symbols</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span> <span class="c1"># noise power of 0.01</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Now save to an IQ file</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># Check data type.  Oops it&#39;s 128 not 64!</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span> <span class="c1"># Convert to 64</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># Verify it&#39;s 64</span>
<span class="n">r</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s1">&#39;bpsk_in_noise.iq&#39;</span><span class="p">)</span> <span class="c1"># Save to file</span>
</pre></div>
</div>
<p>Now examine the details of the file produced and check how many bytes it is.  It should be num_symbols * 8 because we used np.complex64, which is 8 bytes per sample, 4 bytes per float (2 floats per sample).</p>
<p>Using a new Python script, we can read in this file using <code class="code docutils literal notranslate"><span class="pre">np.fromfile()</span></code>, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;bpsk_in_noise.iq&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span> <span class="c1"># Read in file.  We have to tell it what format it is</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

<span class="c1"># Plot constellation to make sure it looks right</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>A big mistake is to forget to tell np.fromfile() the file format. Binary files don’t include any information about their format.  By default, np.fromfile() assumes it is reading in an array of float64s.</p>
<p>Most other languages have methods to read in binary files, e.g., in MATLAB you can use fread().  For visually analyzing an RF file see the section below.</p>
<p>If you ever find yourself dealing with int16’s (a.k.a. short ints), or any other datatype that numpy doesn’t have a complex equivalent for, you will be forced to read the samples in as real, even if they are actually complex.  The trick is to read them as real, but then interleave them back into the IQIQIQ… format yourself, a couple different ways of doing this are shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;iq_samples_as_int16.iq&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;iq_samples_as_int16.iq&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">/=</span> <span class="mi">32768</span> <span class="c1"># convert to -1 to +1 (optional)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># convert to IQIQIQ...</span>
</pre></div>
</div>
</div>
<div class="section" id="visually-analyzing-an-rf-file">
<h2>Visually Analyzing an RF File<a class="headerlink" href="#visually-analyzing-an-rf-file" title="Permalink to this headline">¶</a></h2>
<p>Although we learned how to create our own spectrogram plot in the <a class="reference internal" href="frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Frequency Domain</span></a> Chapter, nothing beats using an already created piece of software, and when it comes to analyzing a long RF recording, I recommend using <a class="reference external" href="https://github.com/miek/inspectrum" rel="noopener noreferrer" target="_blank">inspectrum</a>.  Inspectrum is a fairly simple but powerful graphical tool for scanning through an RF file visually, with fine control over the colormap range and FFT size (zoom amount).  You can hold alt and use the scrollwheel to shift through time.  It has optional cursors to measure the delta-time between two bursts of energy, and the ability to export a slice of the RF file into a new file.  For installation on Debian-based platforms such as Ubuntu, use the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo apt-get install qt5-default libfftw3-dev cmake pkg-config libliquid-dev
git clone https://github.com/miek/inspectrum.git
<span class="nb">cd</span> inspectrum
mkdir build
<span class="nb">cd</span> build
cmake ..
make
sudo make install
inspectrum
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/inspectrum.jpg"><img alt="../_images/inspectrum.jpg" class="align-center" src="../_images/inspectrum.jpg" style="width: 671.4px; height: 321.9px;" /></a>
</div>
<div class="section" id="max-values-and-saturation">
<h2>Max Values and Saturation<a class="headerlink" href="#max-values-and-saturation" title="Permalink to this headline">¶</a></h2>
<p>When receiving samples off a SDR it’s important to know the maximum sample value.  Many SDRs will output the samples as floats using a maximum value of 1.0 and minimum value of -1.0.  Other SDRs will give you samples as integers, usually 16-bit, in which case the max and min values will be +32767 and -32768 (unless otherwise specified), and you can choose to divide by 32,768 to convert them to floats from -1.0 to 1.0.  The reason to be aware of the maximum value for your SDR is due to saturation: when receiving an extremely loud signal (or if the gain is set too high), the receiver will “saturate” and it will truncate the high values to whatever the maximum sample value is.  The ADCs on our SDRs have a limited number of bits.  When making an SDR app it’s wise to always be checking for saturation, and when it happens you should indicate it somehow.</p>
<p>A signal that is saturated will look choppy in the time domain, like this:</p>
<a class="reference internal image-reference" href="../_images/saturated_time.png"><img alt="../_images/saturated_time.png" class="align-center" src="../_images/saturated_time.png" style="width: 715.1999999999999px; height: 505.2px;" /></a>
<p>Because of the sudden changes in time domain, due to the truncation, the frequency domain might look smeared.  In other words, the frequency domain will include false features; features that resulted from the saturation and are not actually part of the signal, which can throw people off when analyzing a signal.</p>
</div>
<div class="section" id="sigmf-and-annotating-iq-files">
<h2>SigMF and Annotating IQ Files<a class="headerlink" href="#sigmf-and-annotating-iq-files" title="Permalink to this headline">¶</a></h2>
<p>Since the IQ file itself doesn’t have any metadata associated with it, it’s common to have a 2nd file, containing information about the signal, with the same filename but a .txt or other file extension.  This should at a minimum include the sample rate used to collect the signal, and the frequency to which the SDR was tuned.  After analyzing the signal, the metadata file could include information about sample ranges of interesting features, such as bursts of energy.  The sample index is simply an integer that starts at 0 and increments every complex sample.  If you knew that there was energy from sample 492342 to 528492, then you could read in the file and pull out that portion of the array: <code class="code docutils literal notranslate"><span class="pre">samples[492342:528493]</span></code>.</p>
<p>Luckily, there is now an open standard that specifies a metadata format used to describe signal recordings, known as <a class="reference external" href="https://github.com/gnuradio/SigMF" rel="noopener noreferrer" target="_blank">SigMF</a>.  By using an open standard like SigMF, multiple parties can share RF recordings more easily, and use different tools to operate on the same datasets.  It also prevents “bitrot” of RF datasets where details of the capture are lost over time due to details of the recording not being collocated with the recording itself.</p>
<p>The most simple (and minimal) way to use the SigMF standard to describe an IQ file you have created is to rename the .iq file to .sigmf-data and create a new file with the same name but .sigmf-meta extension.  This meta file is a plaintext file filled with json, so you can simply open it with a text editor and fill it out manually (later we will discuss doing this programmatically).  Here is an example .sigmf-meta file you can use as a template:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;global&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;core:datatype&quot;</span><span class="p">:</span> <span class="s2">&quot;cf32_le&quot;</span><span class="p">,</span>
        <span class="s2">&quot;core:sample_rate&quot;</span><span class="p">:</span> <span class="mi">1000000</span><span class="p">,</span>
        <span class="s2">&quot;core:hw&quot;</span><span class="p">:</span> <span class="s2">&quot;PlutoSDR with 915 MHz whip antenna&quot;</span><span class="p">,</span>
        <span class="s2">&quot;core:author&quot;</span><span class="p">:</span> <span class="s2">&quot;Art Vandelay&quot;</span><span class="p">,</span>
        <span class="s2">&quot;core:version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;captures&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">&quot;core:sample_start&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;core:frequency&quot;</span><span class="p">:</span> <span class="mi">915000000</span>
        <span class="p">}</span>
    <span class="p">],</span>
    <span class="s2">&quot;annotations&quot;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the <code class="code docutils literal notranslate"><span class="pre">core:cf32_le</span></code> indicates your .sigmf-data is of type IQIQIQIQ… with 32-bit floats, i.e., np.complex64 like we used previously.  Reference the specifications for other available datatypes, such as if you have real data instead of complex, or are using 16-bit integers instead of floats to save space.</p>
<p>Aside from datatype, the most important lines to fill out are <code class="code docutils literal notranslate"><span class="pre">core:sample_rate</span></code> and <code class="code docutils literal notranslate"><span class="pre">core:frequency</span></code>.  It is good practice to also enter information about the hardware (<code class="code docutils literal notranslate"><span class="pre">core:hw</span></code>) used to capture the recording, such as the SDR type and antenna, as well as a description of what is known about the signal(s) in the recording in <code class="code docutils literal notranslate"><span class="pre">core:description</span></code>.  The <code class="code docutils literal notranslate"><span class="pre">core:version</span></code> is simply the version of the SigMF standard being used at the time the metadata file was created.</p>
<p>If you are capturing your RF recording from within Python, e.g., using the Python API for your SDR, then you can avoid having to manually create these metadata files by using the SigMF Python package.  This can be installed on an Ubuntu/Debian based OS as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> ~
git clone https://github.com/gnuradio/SigMF.git
<span class="nb">cd</span> SigMF
sudo pip install .
</pre></div>
</div>
<p>The Python code to write the .sigmf-meta file for the example towards the beginning of this chapter, where we saved bpsk_in_noise.iq, is shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">from</span> <span class="nn">sigmf</span> <span class="kn">import</span> <span class="n">SigMFFile</span>

<span class="c1"># &lt;code from example&gt;</span>

<span class="c1"># r.tofile(&#39;bpsk_in_noise.iq&#39;)</span>
<span class="n">r</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s1">&#39;bpsk_in_noise.sigmf-data&#39;</span><span class="p">)</span> <span class="c1"># replace line above with this one</span>

<span class="c1"># create the metadata</span>
<span class="n">meta</span> <span class="o">=</span> <span class="n">SigMFFile</span><span class="p">(</span>
    <span class="n">data_file</span><span class="o">=</span><span class="s1">&#39;example.sigmf-data&#39;</span><span class="p">,</span> <span class="c1"># extension is optional</span>
    <span class="n">global_info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">DATATYPE_KEY</span><span class="p">:</span> <span class="s1">&#39;cf32_le&#39;</span><span class="p">,</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">SAMPLE_RATE_KEY</span><span class="p">:</span> <span class="mi">8000000</span><span class="p">,</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">AUTHOR_KEY</span><span class="p">:</span> <span class="s1">&#39;Your name and/or email&#39;</span><span class="p">,</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">DESCRIPTION_KEY</span><span class="p">:</span> <span class="s1">&#39;Simulation of BPSK with noise&#39;</span><span class="p">,</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">VERSION_KEY</span><span class="p">:</span> <span class="n">sigmf</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1"># create a capture key at time index 0</span>
<span class="n">meta</span><span class="o">.</span><span class="n">add_capture</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="p">{</span>
    <span class="n">SigMFFile</span><span class="o">.</span><span class="n">FREQUENCY_KEY</span><span class="p">:</span> <span class="mi">915000000</span><span class="p">,</span>
    <span class="n">SigMFFile</span><span class="o">.</span><span class="n">DATETIME_KEY</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span>
<span class="p">})</span>

<span class="c1"># check for mistakes and write to disk</span>
<span class="k">assert</span> <span class="n">meta</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>
<span class="n">meta</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s1">&#39;bpsk_in_noise.sigmf-meta&#39;</span><span class="p">)</span> <span class="c1"># extension is optional</span>
</pre></div>
</div>
<p>Simply replace <code class="code docutils literal notranslate"><span class="pre">8000000</span></code> and <code class="code docutils literal notranslate"><span class="pre">915000000</span></code> with the variables you used to store sample rate and center frequency respectively.</p>
<p>To read in a SigMF recording into Python, use the following code.  In this example the two SigMF files should be named <code class="code docutils literal notranslate"><span class="pre">bpsk_in_noise.sigmf-meta</span></code> and <code class="code docutils literal notranslate"><span class="pre">bpsk_in_noise.sigmf-data</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sigmf</span> <span class="kn">import</span> <span class="n">SigMFFile</span><span class="p">,</span> <span class="n">sigmffile</span>

<span class="c1"># Load a dataset</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;bpsk_in_noise&#39;</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">sigmffile</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">read_samples</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span> <span class="c1"># lets look at the first 10 samples</span>

<span class="c1"># Get some metadata and all annotations</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">get_global_field</span><span class="p">(</span><span class="n">SigMFFile</span><span class="o">.</span><span class="n">SAMPLE_RATE_KEY</span><span class="p">)</span>
<span class="n">sample_count</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">sample_count</span>
<span class="n">signal_duration</span> <span class="o">=</span> <span class="n">sample_count</span> <span class="o">/</span> <span class="n">sample_rate</span>
</pre></div>
</div>
<p>For more details reference <a class="reference external" href="https://github.com/gnuradio/SigMF" rel="noopener noreferrer" target="_blank">the SigMF documentation</a>.</p>
<p>A little bonus for those who read this far; the SigMF logo is actually stored as a SigMF recording itself, and when the signal is plotted as a constellation (IQ plot) over time, it produces the following animation:</p>
<a class="reference internal image-reference" href="../_images/sigmf_logo.gif"><img alt="../_images/sigmf_logo.gif" class="align-center" src="../_images/sigmf_logo.gif" style="width: 450.0px; height: 428.0px;" /></a>
<p>The Python code used to read in the logo file (located <a class="reference external" href="https://github.com/gnuradio/SigMF/tree/master/logo" rel="noopener noreferrer" target="_blank">here</a>) and produce the animated gif above is shown below, for those curious:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">imageio</span>
<span class="kn">from</span> <span class="nn">sigmf</span> <span class="kn">import</span> <span class="n">SigMFFile</span><span class="p">,</span> <span class="n">sigmffile</span>

<span class="c1"># Load a dataset</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;sigmf_logo&#39;</span> <span class="c1"># assume its in the same directory as this script</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">sigmffile</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">read_samples</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="c1"># Add zeros to the end so its clear when the animation repeats</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">50000</span><span class="p">)))</span>

<span class="n">sample_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">samples_per_frame</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">num_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_count</span><span class="o">/</span><span class="n">samples_per_frame</span><span class="p">)</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_frames</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;out of&quot;</span><span class="p">,</span> <span class="n">num_frames</span><span class="p">)</span>
    <span class="c1"># Plot the frame</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">samples_frame</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">samples_per_frame</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">samples_per_frame</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">samples_frame</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">samples_frame</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;cyan&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.35</span><span class="p">,</span><span class="o">-</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.35</span><span class="p">])</span> <span class="c1"># keep axis constant</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;black&#39;</span><span class="p">)</span> <span class="c1"># background color</span>

    <span class="c1"># Save the plot to a file</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;/tmp/sigmf_logo_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">filenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="c1"># Create animated gif</span>
<span class="n">images</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
    <span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imageio</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
<span class="n">imageio</span><span class="o">.</span><span class="n">mimsave</span><span class="p">(</span><span class="s1">&#39;/tmp/sigmf_logo.gif&#39;</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="channel_coding.html" title="Previous document"><span class="section-number">10. </span>Channel Coding</a>
        </li>
        <li>
          <a href="multipath_fading.html" title="Next document"><span class="section-number">12. </span>Multipath Fading</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>