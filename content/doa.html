
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>16. DOA &amp; Beamforming &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="17. About the Author" href="about_author.html" />
    <link rel="prev" title="15. End-to-End Example" href="rds.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script> 

<div id="topBanner" class="modal">
  <div class="modal-content">
    <div class="modal-header" style="background-color: rgb(255, 240, 129); text-align:center;">
      <i>-- Announcement from Marc --</i><br>I'm leading a new education-oriented open-source project called <a target="_blank" href="https://iqengine.org">IQEngine</a>!<br>It's a web-based SDR toolkit for analyzing, processing, and sharing RF recordings.  Checkout out our <a target="_blank" href="https://github.com/IQEngine/IQEngine">GitHub</a> and <a target="_blank" href="https://discord.gg/k7C8kp3b76">Discord</a>
      <div class="closeButton">
        <span style="font-size:30px; position:absolute; top:0px; right:5px; cursor:pointer; ">&times;</span>
      </div>
    </div>
  </div>
</div>

<script>
  var banner = document.getElementById("topBanner");
  var closeButton = document.getElementsByClassName("closeButton")[0];
  // Close banner if they have already clicked the close button in the past
  if (localStorage.getItem('pysdrvisited')){
    banner.style.display = "none";
  }
  // When they click the close button
  closeButton.onclick = function() {
    banner.style.display = "none";
    localStorage.setItem('pysdrvisited', true);
  }
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Frequency Domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. IQ Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Digital Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. Noise and dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Link Budgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Channel Coding</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. IQ Files and SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Multipath Fading</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Pulse Shaping</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronization</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. End-to-End Example</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">16. DOA &amp; Beamforming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#common-applications">Common Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sdr-requirements">SDR Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#array-factor-math">Array Factor Math</a></li>
<li class="toctree-l2"><a class="reference internal" href="#receiving-a-signal">Receiving a Signal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-doa">Basic DOA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#degree-ambiguity">180 Degree Ambiguity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#broadside-of-the-array">Broadside of the Array</a></li>
<li class="toctree-l2"><a class="reference internal" href="#when-d-is-not-2">When d is not λ/2</a></li>
<li class="toctree-l2"><a class="reference internal" href="#antennas">Antennas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#number-of-elements">Number of Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capon-s-beamformer">Capon’s Beamformer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#music">MUSIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#esprit">ESPRIT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#d-doa">2D DOA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#steering-nulls">Steering Nulls</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion-and-references">Conclusion and References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">17. About the Author</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="rds.html" title="previous chapter"><span class="section-number">15. </span>End-to-End Example</a></li>
      <li>Next: <a href="about_author.html" title="next chapter"><span class="section-number">17. </span>About the Author</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="rds.html" title="Previous document"><span class="section-number">15. </span>End-to-End Example</a>
        </li>
        <li>
          <a href="about_author.html" title="Next document"><span class="section-number">17. </span>About the Author</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="doa-beamforming">
<span id="doa-chapter"></span><h1><span class="section-number">16. </span>DOA &amp; Beamforming<a class="headerlink" href="#doa-beamforming" title="Permalink to this headline">¶</a></h1>
<p>Direction-of-Arrival (DOA) within DSP/SDR refers to the process of using an array of antennas to estimate the DOA of one or more signals received by that array.  Once we know the direction a signal of interest is arriving from, we can isolate it from other signals/interference/jamming.  It is just like isolating a signal in the frequency domain by filtering it, except we are now working in the spatial domain (you can certainly combine both!).  We typically refer to the antennas that make up an array as elements, and sometimes the array is called a “sensor” instead.  These array elements are most often omnidirectional antennas, equally spaced in either a line or across two dimensions.  DOA is a subset of beamforming techniques, where as the receiver, we are trying to steer a beam (our receiver’s antenna beam) towards the direction of an emitter.  We may also steer a beam blindly across a wide range (e.g., 0 to 360 degrees) to figure out what signals are being received and from what direction.</p>
<div class="section" id="common-applications">
<h2>Common Applications<a class="headerlink" href="#common-applications" title="Permalink to this headline">¶</a></h2>
<p>Coming soon!</p>
<ul class="simple">
<li>cellular</li>
<li>satellites</li>
<li>satellite ground stations</li>
</ul>
</div>
<div class="section" id="sdr-requirements">
<h2>SDR Requirements<a class="headerlink" href="#sdr-requirements" title="Permalink to this headline">¶</a></h2>
<p>Coming soon!</p>
<ul class="simple">
<li>explain phase coherent receive channels and give some examples of whats available</li>
</ul>
</div>
<div class="section" id="array-factor-math">
<h2>Array Factor Math<a class="headerlink" href="#array-factor-math" title="Permalink to this headline">¶</a></h2>
<p>To get to the fun part we have to get through a little bit of math, but the following section has been written so that the math is extremely simple and has diagrams to go along with it, only the most basic trig and exponential properties are used.  It’s important to understand the basic math behind what we’ll do in Python to perform DOA.</p>
<p>Consider a 1D three-element uniformly spaced array:</p>
<a class="reference external image-reference" href="../_images/doa.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa.svg" class="align-center" src="../_images/doa.svg" /></a>
<p>In this example a signal is coming in from the right side, so it’s hitting the right-most element first.  Let’s calculate the delay between when the signal hits that first element and when it reaches the next element.  We can do this by forming the following trig problem, try to visualize how this triangle was formed from the diagram above.  The segment highlighted in red represents the distance the signal has to travel <em>after</em> it has reached the first element, before it hits the next one.</p>
<a class="reference external image-reference" href="../_images/doa_trig.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_trig.svg" class="align-center" src="../_images/doa_trig.svg" /></a>
<p>If you recall SOH CAH TOA, in this case we are interested in the “adjacent” side and we have the length of the hypotenuse (<img class="math" src="../_images/math/0519e4b809e812b547bede7396ba7366643b7910.svg" alt="d"/>), so we need to use a cosine:</p>
<div class="math">
<p><img src="../_images/math/8923d90e4906e3fcff2b4f7333a0b5434f9068c9.svg" alt="\cos(90 - \theta) = \frac{\mathrm{adjacent}}{\mathrm{hypotenuse}}"/></p>
</div><p>We must solve for adjacent, as that is what will tell us how far the signal must travel between hitting the first and second element, so it becomes adjacent <img class="math" src="../_images/math/91208046c0e554104e6900f89f21513cf9ad7270.svg" alt="= d \cos(90 - \theta)"/>.  Now there is a trig identity that lets us convert this to adjacent <img class="math" src="../_images/math/2c6daa65df86ac524926bbeca71bfeb2928ca057.svg" alt="= d \sin(\theta)"/>.  This is just a distance though, we need to convert this to a time, using the speed of light: time elapsed <img class="math" src="../_images/math/dbeb3493aec7fa697601f0b59bf894e469aba695.svg" alt="= d \sin(\theta) / c"/> [seconds].  This equation applies between any adjacent elements of our array, although we can multiply the whole thing by an integer to calculate between non-adjacent elements since they are uniformly spaced (we’ll do this later).</p>
<p>Now to connect this trig and speed of light math to the signal processing world.  Let’s denote our transmit signal at baseband <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> and it’s being transmitting at some carrier, <img class="math" src="../_images/math/852c5d6001dcb2c5d6047cc1ee451735a4153eec.svg" alt="f_c"/> , so the transmit signal is <img class="math" src="../_images/math/bf16cbd65651add960488d7fc1d018b2b375160e.svg" alt="s(t) e^{2j \pi f_c t}"/>.  Lets say this signal hits the first element at time <img class="math" src="../_images/math/157f019efdbf153e93ae062a1f16393654897fd0.svg" alt="t = 0"/>, which means it hits the next element after <img class="math" src="../_images/math/6c8679f0daa9a17f1918403971d3c7ce9e341d88.svg" alt="d \sin(\theta) / c"/> [seconds] like we calculated above.  This means the 2nd element receives:</p>
<div class="math">
<p><img src="../_images/math/7b3a977eca13e287d99102afd51003bc8d066d8f.svg" alt="s(t - \Delta t) e^{2j \pi f_c (t - \Delta t)}"/></p>
</div><div class="math">
<p><img src="../_images/math/653446739da9a6cb3a152d81b1739442fdf81346.svg" alt="\mathrm{where} \quad \Delta t = d \sin(\theta) / c"/></p>
</div><p>recall that when you have a time shift, it is subtracted from the time argument.</p>
<p>When the receiver or SDR does the downconversion process to receive the signal, its essentially multiplying it by the carrier but in the reverse direction, so after doing downconversion the receiver sees:</p>
<div class="math">
<p><img src="../_images/math/85c788a1480301edff1971fe7a119d9897e2760f.svg" alt="s(t - \Delta t) e^{2j \pi f_c (t - \Delta t)} e^{-2j \pi f_c t}"/></p>
</div><div class="math">
<p><img src="../_images/math/4c5779767c4847ce0b32a45c05937330e4452a97.svg" alt="= s(t - \Delta t) e^{-2j \pi f_c \Delta t}"/></p>
</div><p>Now we can do a little trick to simplify this even further; consider how when we sample a signal it can be modeled by substituting <img class="math" src="../_images/math/de24e9d9b4f685051e7f51c8931d4f7f53a37457.svg" alt="t"/> for <img class="math" src="../_images/math/f64c1fd61d41bf096882352bc2e26a0f173e538d.svg" alt="nT"/> where <img class="math" src="../_images/math/51acb7b4939189dc34f1c1f10cf8acb7aeb5218a.svg" alt="T"/> is sample period and <img class="math" src="../_images/math/f7a9f3c7a45b9df2dac17c2a197dd82e66e4a44a.svg" alt="n"/> is just 0, 1, 2, 3…  Substituting this in we get <img class="math" src="../_images/math/b5862b6807a19c91e35a6831d93310b3f2da78ab.svg" alt="s(nT - \Delta t) e^{-2j \pi f_c \Delta t}"/>. Well, <img class="math" src="../_images/math/f64c1fd61d41bf096882352bc2e26a0f173e538d.svg" alt="nT"/> is so much greater than <img class="math" src="../_images/math/39bb0cf165301516f1e7396af7393a5b3f6c733e.svg" alt="\Delta t"/> that we can get rid of the first <img class="math" src="../_images/math/39bb0cf165301516f1e7396af7393a5b3f6c733e.svg" alt="\Delta t"/> term and we are left with <img class="math" src="../_images/math/a42082fbbf7c8549b4b8d005c2c3beb3ed6b94d0.svg" alt="s(nT) e^{-2j \pi f_c \Delta t}"/>.  If the sample rate ever gets fast enough to approach the speed of light over a tiny distance, we can revisit this, but remember that our sample rate only needs to be a bit larger than the signal of interest’s bandwidth.</p>
<p>Let’s keep going with this math but we’ll start representing things in discrete terms so that it will better resemble our Python code.  The last equation can be represented as the following, let’s plug back in <img class="math" src="../_images/math/39bb0cf165301516f1e7396af7393a5b3f6c733e.svg" alt="\Delta t"/>:</p>
<div class="math">
<p><img src="../_images/math/c69ccdd78a5acd92f2be6b32007f2c6fa0345d91.svg" alt="s[n] e^{-2j \pi f_c \Delta t}"/></p>
</div><div class="math">
<p><img src="../_images/math/7c9635301594c19922fc680832ab966ac9710f7e.svg" alt="= s[n] e^{-2j \pi f_c d \sin(\theta) / c}"/></p>
</div><p>We’re almost done, but luckily there’s one more simplification we can make.  Recall the relationship between center frequency and wavelength: <img class="math" src="../_images/math/14d7a0718bee21802f1c2614ee6dfe1d836ec4cc.svg" alt="\lambda = \frac{c}{f_c}"/> or the form we’ll use: <img class="math" src="../_images/math/430eec2fb397599aaf7cb52a5a38f275ab7b57d6.svg" alt="f_c = \frac{c}{\lambda}"/>.  Plugging this in we get:</p>
<div class="math">
<p><img src="../_images/math/9b1ee44cd7a36b880d6225d90d5229a4c1bbd6d4.svg" alt="s[n] e^{-2j \pi \frac{c}{\lambda} d \sin(\theta) / c}"/></p>
</div><div class="math">
<p><img src="../_images/math/d655fa4935dd0cbce52a630c7a2612ff27d4f34e.svg" alt="= s[n] e^{-2j \pi d \sin(\theta) / \lambda}"/></p>
</div><p>In DOA what we like to do is represent <img class="math" src="../_images/math/0519e4b809e812b547bede7396ba7366643b7910.svg" alt="d"/>, the distance between adjacent elements, as a fraction of wavelength (instead of meters), the most common value chosen for <img class="math" src="../_images/math/0519e4b809e812b547bede7396ba7366643b7910.svg" alt="d"/> during the array design process is to use one half the wavelength. Regardless of what <img class="math" src="../_images/math/0519e4b809e812b547bede7396ba7366643b7910.svg" alt="d"/> is, from this point on we’re going to represent <img class="math" src="../_images/math/0519e4b809e812b547bede7396ba7366643b7910.svg" alt="d"/> as a fraction of wavelength instead of meters, making the equation and all our code simpler:</p>
<div class="math">
<p><img src="../_images/math/6af4a4dab230925b5ce8f415d2c18cbcc12166b2.svg" alt="s[n] e^{-2j \pi d \sin(\theta)}"/></p>
</div><p>This is for adjacent elements, for the <img class="math" src="../_images/math/30d4f39194cc2ced00937a2642c0345222fed6cd.svg" alt="k"/>’th element we just need to multiply <img class="math" src="../_images/math/0519e4b809e812b547bede7396ba7366643b7910.svg" alt="d"/> times <img class="math" src="../_images/math/30d4f39194cc2ced00937a2642c0345222fed6cd.svg" alt="k"/>:</p>
<div class="math">
<p><img src="../_images/math/d4c7a068adcae678b2a7425a5bb312db0ff84005.svg" alt="s[n] e^{-2j \pi d k \sin(\theta)}"/></p>
</div><p>And we’re done! This equation above is what you’ll see in DOA papers and implementations everywhere! We typically call that exponential term the “array factor” (often denoted as <img class="math" src="../_images/math/375383b47352eb6cd2f5c760a77a36e69e4ed098.svg" alt="a"/>) and represent it as an array, a 1D array for a 1D antenna array, etc.  In python <img class="math" src="../_images/math/375383b47352eb6cd2f5c760a77a36e69e4ed098.svg" alt="a"/> is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="mi">0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span> <span class="o">...</span><span class="p">]</span> <span class="c1"># note the increasing k</span>
<span class="c1"># or</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nr</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="c1"># where Nr is the number of receive antenna elements</span>
</pre></div>
</div>
<p>Note how element 0 results in a 1+0j (because <img class="math" src="../_images/math/a97aa36d28fc32010e9967bebdaf247831812ece.svg" alt="e^{0}=1"/>); this makes sense because everything above was relative to that first element, so it’s receiving the signal as-is without any relative phase shifts.  This is purely how the math works out, in reality any element could be thought of as the reference, but as you’ll see in our math/code later on, what matters is the difference in phase/amplitude received between elements.  It’s all relative.</p>
</div>
<div class="section" id="receiving-a-signal">
<h2>Receiving a Signal<a class="headerlink" href="#receiving-a-signal" title="Permalink to this headline">¶</a></h2>
<p>Let’s use the array factor concept to simulate a signal arriving at an array.  For a transmit signal we’ll just use a tone for now:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10000</span> <span class="c1"># number of samples to simulate</span>

<span class="c1"># Create a tone to act as the transmitter signal</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># time vector</span>
<span class="n">f_tone</span> <span class="o">=</span> <span class="mf">0.02e6</span>
<span class="n">tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f_tone</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let’s simulate an array consisting of three omnidirectional antennas in a line, with 1/2 wavelength between adjacent ones (a.k.a. “half-wavelength spacing”).  We will simulate the transmitter’s signal arriving at this array at a certain angle, theta.  Understanding the array factor <code class="code docutils literal notranslate"><span class="pre">a</span></code> below is why we went through all that math above.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># half wavelength spacing</span>
<span class="n">Nr</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">theta_degrees</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1"># direction of arrival (feel free to change this, it&#39;s arbitrary)</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">theta_degrees</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="c1"># convert to radians</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nr</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="c1"># array factor</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># note that it&#39;s a 1x3, it&#39;s complex, and the first element is 1+0j</span>
</pre></div>
</div>
<p>To apply the array factor we have to do a matrix multiplication of <code class="code docutils literal notranslate"><span class="pre">a</span></code> and <code class="code docutils literal notranslate"><span class="pre">tx</span></code>, so first let’s convert both to matrices, as NumPy arrays which don’t let us do 1D matrix math that we need for beamforming/DOA.  We then perform the matrix multiply, note that the &#64; symbol in Python means matrix multiply (it’s a NumPy thing).  We also have to convert <code class="code docutils literal notranslate"><span class="pre">a</span></code> from a row vector to a column vector (picture it rotating 90 degrees) so that the matrix multiply inner dimensions match.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">tx</span>  <span class="c1"># dont get too caught up by the transpose a, the important thing is we&#39;re multiplying the array factor by the tx signal</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># r is now going to be a 2D array, 1D is time and 1D is the spatial dimension</span>
</pre></div>
</div>
<p>At this point <code class="code docutils literal notranslate"><span class="pre">r</span></code> is a 2D array, size 3 x 10000 because we have three array elements and 10000 samples simulated.  We can pull out each individual signal and plot the first 200 samples, below we’ll plot the real part only, but there’s also an imaginary part, like any baseband signal.  One annoying part of Python is having to switch to matrix type for matrix math, then having to switch back to normal NumPy arrays, we need to add the .squeeze() to get it back to a normal 1D NumPy array.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">200</span><span class="p">])</span> <span class="c1"># the asarray and squeeze are just annoyances we have to do because we came from a matrix</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,:])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">200</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">200</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/doa_time_domain.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_time_domain.svg" class="align-center" src="../_images/doa_time_domain.svg" /></a>
<p>Note the phase shifts between elements like we expect to happen (unless the signal arrives at boresight in which case it will reach all elements at the same time and there wont be a shift, set theta to 0 to see).  Element 0 appears to arrive first, with the others slightly delayed.  Try adjusting the angle and see what happens.</p>
<p>One thing we didn’t bother doing yet- let’s add noise to this received signal.  AWGN with a phase shift applied is still AWGN, and we want to apply the noise after the array factor is applied, because each element experiences an independent noise signal.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">Nr</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">Nr</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">n</span> <span class="c1"># r and n are both 3x10000</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/doa_time_domain_with_noise.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_time_domain_with_noise.svg" class="align-center" src="../_images/doa_time_domain_with_noise.svg" /></a>
</div>
<div class="section" id="basic-doa">
<h2>Basic DOA<a class="headerlink" href="#basic-doa" title="Permalink to this headline">¶</a></h2>
<p>So far this has been simulating the receiving of a signal from a certain angle of arrival.  In your typical DOA problem you are given samples and have to estimate the angle of arrival(s).  There are also problems where you have multiple received signals from different directions and one is the signal-of-interest (SOI) while another might be a jammer or interferer you have to null out to extract the SOI with at as high SNR as possible.</p>
<p>Next let’s use this signal <code class="code docutils literal notranslate"><span class="pre">r</span></code> but pretend we don’t know which direction the signal is coming in from, let’s try to figure it out with DSP and some Python code!  We’ll start with the “conventional” beamforming approach, which involves scanning through (sampling) all directions of arrival from -pi to +pi (-180 to +180 degrees).  At each direction we point the array towards that angle by applying the weights associated with pointing in that direction; applying the weights will give us a 1D array of samples, as if we received it with 1 directional antenna.  You’re probably starting to realize where the term electrically steered array comes in.  This conventional beamforming method involves calculating the mean of the magnitude squared, as if we were making an energy detector.  We’ll apply the beamforming weights and do this calculation at a ton of different angles, so that we can check which angle gave us the max energy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">theta_scan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1"># 1000 different thetas between -180 and +180 degrees</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">theta_i</span> <span class="ow">in</span> <span class="n">theta_scan</span><span class="p">:</span>
    <span class="c1">#print(theta_i)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nr</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_i</span><span class="p">)))</span> <span class="c1"># look familiar?</span>
    <span class="n">r_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">@</span> <span class="n">r</span> <span class="c1"># apply our weights corresponding to the direction theta_i</span>
    <span class="n">r_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r_weighted</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="c1"># get it back to a normal 1d numpy array</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r_weighted</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># energy detector</span>

<span class="c1"># print angle that gave us the max value</span>
<span class="nb">print</span><span class="p">(</span><span class="n">theta_scan</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">results</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="c1"># 19.99999999999998</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theta_scan</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span> <span class="c1"># lets plot angle in degrees</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Theta [Degrees]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;DOA Metric&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/doa_conventional_beamformer.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_conventional_beamformer.svg" class="align-center" src="../_images/doa_conventional_beamformer.svg" /></a>
<p>We found our signal!  Try increasing the amount of noise to push it to its limit, you might need to simulate more samples being received for low SNRs.  Also try changing the direction of arrival.</p>
<p>If you prefer viewing angle on a polar plot, use the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;projection&#39;</span><span class="p">:</span> <span class="s1">&#39;polar&#39;</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theta_scan</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span> <span class="c1"># MAKE SURE TO USE RADIAN FOR POLAR</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_theta_zero_location</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span> <span class="c1"># make 0 degrees point up</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_theta_direction</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># increase clockwise</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_rgrids</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_rlabel_position</span><span class="p">(</span><span class="mf">22.5</span><span class="p">)</span>  <span class="c1"># Move grid labels away from other labels</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/doa_conventional_beamformer_polar.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_conventional_beamformer_polar.svg" class="align-center" src="../_images/doa_conventional_beamformer_polar.svg" /></a>
</div>
<div class="section" id="degree-ambiguity">
<h2>180 Degree Ambiguity<a class="headerlink" href="#degree-ambiguity" title="Permalink to this headline">¶</a></h2>
<p>Let’s talk about why is there a second peak at 160 degrees; the DOA we simulated was 20 degrees, but it is not a coincidence that 180 - 20 = 160.  Picture three omnidirectional antennas in a line placed on a table.  The array’s boresight is 90 degrees to the axis of the array, as labeled in the first diagram in this chapter.  Now imagine the transmitter in front of the antennas, also on the (very large) table, such that its signal arrives at a +20 degree angle from boresight.  Well the array sees the same effect whether the signal is arriving with respect to its front or back, the phase delay is the same, as depicted below with the array elements in red and the two possible transmitter DOA’s in green.  Therefore, when we perform the DOA algorithm, there will always be a 180 degree ambiguity like this, the only way around it is to have a 2D array, or a second 1D array positioned at any other angle w.r.t the first array.  You may be wondering if this means we might as well only calculate -90 to +90 degrees to save compute cycles, and you would be correct!</p>
<a class="reference external image-reference" href="../_images/doa_from_behind.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_from_behind.svg" class="align-center" src="../_images/doa_from_behind.svg" /></a>
</div>
<div class="section" id="broadside-of-the-array">
<h2>Broadside of the Array<a class="headerlink" href="#broadside-of-the-array" title="Permalink to this headline">¶</a></h2>
<p>To demonstrate this next concept, let’s try sweeping the angle of arrival (AoA) from -90 to +90 degrees instead of keeping it constant at 20:</p>
<a class="reference internal image-reference" href="../_images/doa_sweeping_angle_animation.gif"><img alt="../_images/doa_sweeping_angle_animation.gif" class="align-center" src="../_images/doa_sweeping_angle_animation.gif" style="width: 800.0px; height: 400.0px;" /></a>
<p>As we approach the broadside of the array (a.k.a. endfire), which is when the signal arrives at or near the axis of the array, performance drops.  We see two main degredations: 1) the main lobe gets wider and 2) we get ambiguity and don’t know whether the signal is coming from the left or the right.  This ambiguity adds to the 180 degree ambiguity discussed earlier, where we get an extra lobe at 180 - theta, causing certain AoA to lead to three lobes of roughly equal size.  This broadside ambiguity makes sense though, the phase shifts that occur between elements are identical whether the signal arrives from the left or right side w.r.t. the array axis.  Just like with the 180 degree ambiguity, the solution is to use a 2D array or two 1D arrays at different angles.  In general, beamforming works best when the angle is closer to the boresight.</p>
</div>
<div class="section" id="when-d-is-not-2">
<h2>When d is not λ/2<a class="headerlink" href="#when-d-is-not-2" title="Permalink to this headline">¶</a></h2>
<p>So far we have been using a distance between elements, d, equal to one half wavelength.  So for example, an array designed for 2.4 GHz WiFi with λ/2 spacing would have a spacing of 3e8/2.4e9/2 = 12.5cm or about 5 inches, meaning a 4x4 element array would be about 15” x 15” x the height of the antennas.  There are times when an array may not be able to achieve exactly λ/2 spacing, such as when space is restricted, or when the same array has to work on a variety of carrier frequencies.</p>
<p>Let’s examine when the spacing is greater than λ/2, i.e., too much spacing, by varying d between λ/2 and 4λ.  We will remove the bottom half of the polar plot since it’s a mirror of the top anyway.</p>
<a class="reference internal image-reference" href="../_images/doa_d_is_large_animation.gif"><img alt="../_images/doa_d_is_large_animation.gif" class="align-center" src="../_images/doa_d_is_large_animation.gif" style="width: 433.0px; height: 238.0px;" /></a>
<p>As you can see, in addition to the 180 degree ambiguity we discussed earlier, we now have additional ambiguity, and it gets worse as d gets higher (extra/incorrect lobes form).  These extra lobes are known as grating lobes, and they are a result of “spatial aliasing”.  As we learned in the <a class="reference internal" href="sampling.html#sampling-chapter"><span class="std std-ref">IQ Sampling</span></a> chapter, when we don’t sample fast enough we get aliasing.  The same thing happens in the spatial domain; if our elements are not spaced close enough together w.r.t. the carrier frequency of the signal being observed, we get garbage results in our analysis.  You can think of spacing out antennas as sampling space!  In this example we can see that the grating lobes don’t get too problematic until d &gt; λ, but they will occur as soon as you go above λ/2 spacing.</p>
<p>Now what happens when d is less than λ/2, such as when we need to fit the array in a small space?  Let’s repeat the same simulation:</p>
<a class="reference internal image-reference" href="../_images/doa_d_is_small_animation.gif"><img alt="../_images/doa_d_is_small_animation.gif" class="align-center" src="../_images/doa_d_is_small_animation.gif" style="width: 433.0px; height: 237.0px;" /></a>
<p>While the main lobe gets wider as d gets lower, it still has a maximum at 20 degrees, and there are no grating lobes, so in theory this would still work (at least at high SNR).  To better understand what breaks as d gets too small, let’s repeat the experiment but with an additional signal arriving from -40 degrees:</p>
<a class="reference internal image-reference" href="../_images/doa_d_is_small_animation2.gif"><img alt="../_images/doa_d_is_small_animation2.gif" class="align-center" src="../_images/doa_d_is_small_animation2.gif" style="width: 431.0px; height: 236.0px;" /></a>
<p>Once we get lower than λ/4 there is no distinguishing between the two different paths, and the array performs poorly.  As we will see later in this chapter, there are beamforming techniques that provide more precise beams than conventional beamforming, but keeping d as close to λ/2 as possible will continue to be a theme.</p>
</div>
<div class="section" id="antennas">
<h2>Antennas<a class="headerlink" href="#antennas" title="Permalink to this headline">¶</a></h2>
<p>Coming soon!</p>
<ul class="simple">
<li>common antenna types used for arrays (eg patch, monopole)</li>
</ul>
</div>
<div class="section" id="number-of-elements">
<h2>Number of Elements<a class="headerlink" href="#number-of-elements" title="Permalink to this headline">¶</a></h2>
<p>Coming soon!</p>
</div>
<div class="section" id="capon-s-beamformer">
<h2>Capon’s Beamformer<a class="headerlink" href="#capon-s-beamformer" title="Permalink to this headline">¶</a></h2>
<p>In the basic DOA example we swept across all angles, multiplying <code class="code docutils literal notranslate"><span class="pre">r</span></code> by the weights <code class="code docutils literal notranslate"><span class="pre">w</span></code>, applying an energy detector to the resulting 1D array.  In that example, <code class="code docutils literal notranslate"><span class="pre">w</span></code> was equal to the array factor, <code class="code docutils literal notranslate"><span class="pre">a</span></code>, so we were essentially just multiplying <code class="code docutils literal notranslate"><span class="pre">r</span></code> by <code class="code docutils literal notranslate"><span class="pre">a</span></code>.  We will now look at a beamformer that is slightly more complicated but tends to perform much better, called Capon’s Beamformer, a.k.a. the minimum variance distortionless response (MVDR) beamformer.  This beamformer can be summarized in the following equation:</p>
<div class="math">
<p><img src="../_images/math/085334b4cfb66a6b714016edd28223c99601f2ef.svg" alt="\hat{\theta} = \mathrm{argmax}\left(\frac{1}{a^H R^{-1} a}\right)"/></p>
</div><p>where <img class="math" src="../_images/math/b17fefe1917e4d7f20f58f78e1199881c041757a.svg" alt="R"/> is the sample covariance matrix, calculated by multiplying r with the complex conjugate transpose of itself, <img class="math" src="../_images/math/17653541a64f71a998cb54e312c1b505f1801cf6.svg" alt="R = r r^H"/>, and the result will be a <code class="code docutils literal notranslate"><span class="pre">Nr</span></code> x <code class="code docutils literal notranslate"><span class="pre">Nr</span></code> size matrix (3x3 in the examples we have seen so far).  This covariance matrix tells us how similar the samples received from the three elements are, although to use Capon’s method we don’t have to fully understand how that works.  In textbooks and other resources you might see the Capon’s equation with some terms in the numerator; these are purely for scaling/normalization and they don’t change the results.</p>
<p>We can implement the equations above in Python fairly easily:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">theta_scan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1"># between -180 and +180 degrees</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">theta_i</span> <span class="ow">in</span> <span class="n">theta_scan</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nr</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_i</span><span class="p">)))</span> <span class="c1"># array factor</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span> <span class="c1"># needs to be a column vector for the math below</span>

    <span class="c1"># Calc covariance matrix</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">r</span> <span class="o">@</span> <span class="n">r</span><span class="o">.</span><span class="n">H</span> <span class="c1"># gives a Nr x Nr covariance matrix of the samples</span>

    <span class="n">Rinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="c1"># pseudo-inverse tends to work better than a true inverse</span>

    <span class="n">metric</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">H</span> <span class="o">@</span> <span class="n">Rinv</span> <span class="o">@</span> <span class="n">a</span><span class="p">)</span> <span class="c1"># Capon&#39;s method!</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># convert the 1x1 matrix to a Python scalar, it&#39;s still complex though</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="c1"># take magnitude</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="c1"># convert to dB so its easier to see small and large lobes at the same time</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>

<span class="n">results</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="c1"># normalize</span>
</pre></div>
</div>
<p>When applied to the previous DOA example code, we get the following:</p>
<a class="reference external image-reference" href="../_images/doa_capons.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_capons.svg" class="align-center" src="../_images/doa_capons.svg" /></a>
<p>Works fine, but to really compare this to other techniques we’ll have to create a more interesting problem.  Let’s set up a simulation with an 8-element array receiving three signals from different angles: 20, 25, and 40 degrees, with the 40 degree one received at a much lower power than the other two.  Our goal will be to detect all three.  The code to generate this new scenario is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Nr</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1"># 8 elements</span>
<span class="n">theta1</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="c1"># convert to radians</span>
<span class="n">theta2</span> <span class="o">=</span> <span class="mi">25</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">theta3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">40</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nr</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)))</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nr</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)))</span>
<span class="n">a3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nr</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta3</span><span class="p">)))</span>
<span class="c1"># we&#39;ll use 3 different frequencies</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.01e6</span><span class="o">*</span><span class="n">t</span><span class="p">))</span> <span class="o">+</span> \
    <span class="n">a2</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.02e6</span><span class="o">*</span><span class="n">t</span><span class="p">))</span> <span class="o">+</span> \
    <span class="mf">0.1</span> <span class="o">*</span> <span class="n">a3</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.03e6</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">Nr</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">Nr</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.04</span><span class="o">*</span><span class="n">n</span>
</pre></div>
</div>
<p>And if we run our Capon’s beamformer on this new scenario we get the following results:</p>
<a class="reference external image-reference" href="../_images/doa_capons2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_capons2.svg" class="align-center" src="../_images/doa_capons2.svg" /></a>
<p>It works pretty well, we can see the two signals received only 5 degrees apart, and we can also see the 3rd signal (at -40 or 320 degrees) that was received at one tenth the power of the others.   Now let’s run the simple beamformer which is just an energy detector on this new scenario:</p>
<a class="reference external image-reference" href="../_images/doa_complex_scenario.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_complex_scenario.svg" class="align-center" src="../_images/doa_complex_scenario.svg" /></a>
<p>While it might be a pretty shape, it’s not finding all three signals at all…  By comparing these two results we can see the benefit from using a more complex beamformer.  There are many more beamformers out there, but next we are going to dive into a different class of beamformer that use the “subspace” method, often called adaptive beamforming.</p>
</div>
<div class="section" id="music">
<h2>MUSIC<a class="headerlink" href="#music" title="Permalink to this headline">¶</a></h2>
<p>We will now change gears and talk about a different kind of beamformer. All of the previous ones have fallen in the “delay-and-sum” category, but now we will dive into “sub-space” methods.  These involve dividing the signal subspace and noise subspace, which means we must estimate how many signals are being received by the array, to get a good result.  MUltiple SIgnal Classification (MUSIC) is a very popular sub-space method that involves calculating the eigenvectors of the covariance matrix (which is a computationally intensive operation by the way).  We split the eigenvectors into two groups: signal sub-space and noise-subspace, then project steering vectors into the noise sub-space and steer for nulls.  That might seem confusing at first, which is part of why MUSIC seems like black magic!</p>
<p>The core MUSIC equation is the following:</p>
<div class="math">
<p><img src="../_images/math/8dd4490c2d8c92ab8db5bb5c6b3e8b6e47270eea.svg" alt="\hat{\theta} = \mathrm{argmax}\left(\frac{1}{a^H V_n V^H_n a}\right)"/></p>
</div><p>where <img class="math" src="../_images/math/7f75b41963b83a0b40b039a70ae53c3dd3096404.svg" alt="V_n"/> is that list of noise sub-space eigenvectors we mentioned (a 2D matrix).  It is found by first calculating the eigenvectors of <img class="math" src="../_images/math/b17fefe1917e4d7f20f58f78e1199881c041757a.svg" alt="R"/>, which is done simply by <code class="code docutils literal notranslate"><span class="pre">w,</span> <span class="pre">v</span> <span class="pre">=</span> <span class="pre">np.linalg.eig(R)</span></code> in Python, and then splitting up the vectors (<code class="code docutils literal notranslate"><span class="pre">w</span></code>) based on how many signals we think the array is receiving.  There is a trick for estimating the number of signals that we’ll talk about later, but it must be between 1 and <code class="code docutils literal notranslate"><span class="pre">Nr</span> <span class="pre">-</span> <span class="pre">1</span></code>.  I.e., if you are designing an array, when you are choosing the number of elements you must have one more than the number of anticipated signals.  One thing to note about the equation above is <img class="math" src="../_images/math/7f75b41963b83a0b40b039a70ae53c3dd3096404.svg" alt="V_n"/> does not depend on the array factor <img class="math" src="../_images/math/375383b47352eb6cd2f5c760a77a36e69e4ed098.svg" alt="a"/>, so we can precalculate it before we start looping through theta.  The full MUSIC code is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_expected_signals</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># Try changing this!</span>

<span class="c1"># part that doesn&#39;t change with theta_i</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">r</span> <span class="o">@</span> <span class="n">r</span><span class="o">.</span><span class="n">H</span> <span class="c1"># Calc covariance matrix, it&#39;s Nr x Nr</span>
<span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="c1"># eigenvalue decomposition, v[:,i] is the eigenvector corresponding to the eigenvalue w[i]</span>
<span class="n">eig_val_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="c1"># find order of magnitude of eigenvalues</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">eig_val_order</span><span class="p">]</span> <span class="c1"># sort eigenvectors using this order</span>
<span class="c1"># We make a new eigenvector matrix representing the &quot;noise subspace&quot;, it&#39;s just the rest of the eigenvalues</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nr</span><span class="p">,</span> <span class="n">Nr</span> <span class="o">-</span> <span class="n">num_expected_signals</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nr</span> <span class="o">-</span> <span class="n">num_expected_signals</span><span class="p">):</span>
   <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

<span class="n">theta_scan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1"># -180 to +180 degrees</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">theta_i</span> <span class="ow">in</span> <span class="n">theta_scan</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nr</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_i</span><span class="p">)))</span> <span class="c1"># array factor</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">H</span> <span class="o">@</span> <span class="n">V</span> <span class="o">@</span> <span class="n">V</span><span class="o">.</span><span class="n">H</span> <span class="o">@</span> <span class="n">a</span><span class="p">)</span> <span class="c1"># The main MUSIC equation</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># take magnitude</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="c1"># convert to dB</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>

<span class="n">results</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="c1"># normalize</span>
</pre></div>
</div>
<p>Running this algorithm on the complex scenario we have been using, we get the following very precise results, showing the power of MUSIC:</p>
<a class="reference external image-reference" href="../_images/doa_music.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_music.svg" class="align-center" src="../_images/doa_music.svg" /></a>
<p>Now what if we had no idea how many signals were present?  Well there is a trick; you sort the eigenvalue magnitudes from highest to lowest, and plot them (it may help to plot them in dB):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)),</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/doa_eigenvalues.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/doa_eigenvalues.svg" class="align-center" src="../_images/doa_eigenvalues.svg" /></a>
<p>The eigenvalues associated with the noise-subspace are going to be the smallest, and they will all tend around the same value, so we can treat these low values like a “noise floor”, and any eigenvalue above the noise floor represents a signal.  Here we can clearly see there are three signals being received, and adjust our MUSIC algorithm accordingly.  If you don’t have a lot of IQ samples to process or the signals are at low SNR, the number of signals might not be as obvious.  Feel free to play around by adjusting <code class="code docutils literal notranslate"><span class="pre">num_expected_signals</span></code> between 1 and 7, you’ll find that underestimating the number will lead to missing signal(s) while overestimating will only slightly hurt performance.</p>
<p>Another experiment worth trying with MUSIC is to see how close two signals can arrive at (in angle) while still distinguishing between them; sub-space techniques are especially good at that.  The animation below shows an example, with one signal at 18 degrees and another slowly sweeping angle of arrival.</p>
<a class="reference internal image-reference" href="../_images/doa_music_animation.gif"><img alt="../_images/doa_music_animation.gif" class="align-center" src="../_images/doa_music_animation.gif" style="width: 224.0px; height: 241.0px;" /></a>
</div>
<div class="section" id="esprit">
<h2>ESPRIT<a class="headerlink" href="#esprit" title="Permalink to this headline">¶</a></h2>
<p>Coming soon!</p>
</div>
<div class="section" id="d-doa">
<h2>2D DOA<a class="headerlink" href="#d-doa" title="Permalink to this headline">¶</a></h2>
<p>Coming soon!</p>
</div>
<div class="section" id="steering-nulls">
<h2>Steering Nulls<a class="headerlink" href="#steering-nulls" title="Permalink to this headline">¶</a></h2>
<p>Coming soon!</p>
</div>
<div class="section" id="conclusion-and-references">
<h2>Conclusion and References<a class="headerlink" href="#conclusion-and-references" title="Permalink to this headline">¶</a></h2>
<p>All Python code, including code used to generate the figures/animations, can be found <a class="reference external" href="https://github.com/777arc/textbook/blob/master/figure-generating-scripts/doa.py" rel="noopener noreferrer" target="_blank">on the textbook’s GitHub page</a>.</p>
<ul class="simple">
<li>DOA implementation in GNU Radio - <a class="reference external" href="https://github.com/EttusResearch/gr-doa" rel="noopener noreferrer" target="_blank">https://github.com/EttusResearch/gr-doa</a></li>
<li>DOA implementation used by KrakenSDR - <a class="reference external" href="https://github.com/krakenrf/krakensdr_doa/blob/main/_signal_processing/krakenSDR_signal_processor.py" rel="noopener noreferrer" target="_blank">https://github.com/krakenrf/krakensdr_doa/blob/main/_signal_processing/krakenSDR_signal_processor.py</a></li>
</ul>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="rds.html" title="Previous document"><span class="section-number">15. </span>End-to-End Example</a>
        </li>
        <li>
          <a href="about_author.html" title="Next document"><span class="section-number">17. </span>About the Author</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>