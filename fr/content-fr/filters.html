
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>8. Filtres &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. Bilans de liaison" href="link_budgets.html" />
    <link rel="prev" title="7. le Bruit et les dB" href="noise.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/nl/index-nl.html">Dutch</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Filtres</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#principes-de-base-des-filtres">Principes de Base des Filtres</a></li>
<li class="toctree-l2"><a class="reference internal" href="#representation-des-filtres">Représentation des Filtres</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation-des-filtres">Implémentation des Filtres</a></li>
<li class="toctree-l2"><a class="reference internal" href="#outils-de-conception-de-filtres">Outils de conception de filtres</a></li>
<li class="toctree-l2"><a class="reference internal" href="#convolution">Convolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conception-de-filtres-en-python">Conception de Filtres en Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introduction-a-la-mise-en-forme">Introduction à la Mise en Forme</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="noise.html" title="previous chapter"><span class="section-number">7. </span>le Bruit et les dB</a></li>
      <li>Next: <a href="link_budgets.html" title="next chapter"><span class="section-number">9. </span>Bilans de liaison</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="noise.html" title="Previous document"><span class="section-number">7. </span>le Bruit et les dB</a>
        </li>
        <li>
          <a href="link_budgets.html" title="Next document"><span class="section-number">9. </span>Bilans de liaison</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="filtres">
<span id="filters-chapter"></span><h1><span class="section-number">8. </span>Filtres<a class="headerlink" href="#filtres" title="Permalink to this headline">¶</a></h1>
<p>Dans ce chapitre, nous nous familiarisons avec les filtres numériques en utilisant Python.  Nous couvrons les types de filtres (FIR/IIR et passe-bas/passe-haut/passe-bande/coupe-bande), comment les filtres sont représentés numériquement et comment ils sont conçus.  Nous terminons par une introduction aux filtres de mise en forme, que nous approfondissons dans le chapitre <a class="reference internal" href="../content-nl/pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a>.</p>
<div class="section" id="principes-de-base-des-filtres">
<h2>Principes de Base des Filtres<a class="headerlink" href="#principes-de-base-des-filtres" title="Permalink to this headline">¶</a></h2>
<p>Les filtres sont utilisés dans de nombreuses disciplines. Par exemple, le traitement des images fait un usage intensif des filtres 2D, où l’entrée et la sortie sont des images.  Vous utilisez peut-être un filtre chaque matin pour faire votre café, qui filtre les solides du liquide.  En DSP, les filtres sont principalement utilisés pour :</p>
<ol class="arabic simple">
<li>Séparation des signaux qui ont été combinés (par exemple, extraction du signal souhaité).</li>
<li>Suppression de l’excès de bruit après la réception d’un signal</li>
<li>Restauration des signaux qui ont été déformés d’une manière ou d’une autre (par exemple, un égaliseur audio est un filtre).</li>
</ol>
<p>Il existe certainement d’autres utilisations des filtres, mais ce chapitre a pour but d’introduire le concept plutôt que d’expliquer toutes les façons dont le filtrage peut se produire.</p>
<p>Vous pouvez penser que nous ne nous intéressons qu’aux filtres numériques; ce manuel explore le DSP, après tout. Cependant, il est important de savoir que de nombreux filtres seront analogiques, comme ceux de nos SDR placés avant le convertisseur analogique-numérique (CAN) du côté réception. L’image suivante juxtapose le schéma d’un circuit de filtrage analogique et la représentation sous forme d’organigramme d’un algorithme de filtrage numérique.</p>
<a class="reference internal image-reference" href="../_images/analog_digital_filter.png"><img alt="../_images/analog_digital_filter.png" class="align-center" src="../_images/analog_digital_filter.png" style="width: 793.0999999999999px; height: 223.29999999999998px;" /></a>
<p>En DSP, où l’entrée et la sortie sont des signaux, un filtre a un signal en entrée et un signal en sortie :</p>
<a class="reference internal image-reference" href="../_images/filter.png"><img alt="../_images/filter.png" class="align-center" src="../_images/filter.png" style="width: 527.8px; height: 86.1px;" /></a>
<p>Vous ne pouvez pas introduire deux signaux différents dans un seul filtre sans les additionner au préalable ou effectuer une autre opération.  De même, la sortie sera toujours un seul signal, c’est-à-dire un tableau 1D de nombres.</p>
<p>Il existe quatre types de filtres de base :passe-bas, passe-haut, passe-bande et coupe-bande. Chaque type modifie les signaux pour se concentrer sur les différentes plages de fréquences qu’ils contiennent. Les graphiques ci-dessous montrent comment les fréquences des signaux sont filtrées pour chaque type.</p>
<a class="reference internal image-reference" href="../_images/filter_types.png"><img alt="../_images/filter_types.png" class="align-center" src="../_images/filter_types.png" style="width: 703.5px; height: 145.6px;" /></a>
<p>(AJOUTER LE DIAGRAMME MONTRANT LES FRÉQUENCES NÉGATIVES AUSSI)</p>
<p>Chaque filtre permet à certaines fréquences de rester dans un signal tout en bloquant d’autres fréquences.  La gamme de fréquences qu’un filtre laisse passer est appelée “bande passante”, et le “bande rejetée” fait référence à ce qui est bloqué.  Dans le cas du filtre passe-bas, il laisse passer les basses fréquences et arrête les hautes fréquences, de sorte que 0 Hz sera toujours dans la bande passante.  Pour un filtre passe-haut et un filtre passe-bande, 0 Hz sera toujours dans la bande coupée.</p>
<p>Ne confondez pas ces types de filtrage avec la mise en œuvre algorithmique du filtre (par exemple, IIR vs FIR).  Le type le plus courant est de loin le filtre passe-bas (LPF pour <em>Low Pass Filter</em> en anglais) car nous représentons souvent des signaux en bande de base.  Le LPF nous permet de filtrer tout ce qui se trouve “autour” de notre signal, en éliminant le bruit excessif et les autres signaux.</p>
</div>
<div class="section" id="representation-des-filtres">
<h2>Représentation des Filtres<a class="headerlink" href="#representation-des-filtres" title="Permalink to this headline">¶</a></h2>
<p>Pour la plupart des filtres que nous verrons (connus sous le nom de filtres FIR, pour <em>Finite Impulse Response</em> en anglais, ou <em>filtres à réponse impulsionnelle finie</em> en français), nous pouvons représenter le filtre lui-même avec un seul tableau de flottants.  Pour les filtres symétriques dans le domaine fréquentiel, ces flottants seront réels (par opposition à complexes), et leur nombre tend à être impair.  Nous appelons ce tableau de flottants <em>les coéfficients</em> du filtre ou usuellement <em>taps</em> en anglais.  Nous utilisons souvent <img class="math" src="../_images/math/2475529ef4582ec92a0ef0ee2a266a22d98ba80d.svg" alt="h"/> comme symbole pour les taps du filtre.  Voici un exemple d’un ensemble de taps qui définissent un filtre :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span>  <span class="p">[</span> <span class="mf">9.92977939e-04</span>  <span class="mf">1.08410297e-03</span>  <span class="mf">8.51595307e-04</span>  <span class="mf">1.64604862e-04</span>
 <span class="o">-</span><span class="mf">1.01714338e-03</span> <span class="o">-</span><span class="mf">2.46268845e-03</span> <span class="o">-</span><span class="mf">3.58236429e-03</span> <span class="o">-</span><span class="mf">3.55412543e-03</span>
 <span class="o">-</span><span class="mf">1.68583512e-03</span>  <span class="mf">2.10562324e-03</span>  <span class="mf">6.93100252e-03</span>  <span class="mf">1.09302641e-02</span>
  <span class="mf">1.17766532e-02</span>  <span class="mf">7.60955496e-03</span> <span class="o">-</span><span class="mf">1.90555639e-03</span> <span class="o">-</span><span class="mf">1.48306750e-02</span>
 <span class="o">-</span><span class="mf">2.69313236e-02</span> <span class="o">-</span><span class="mf">3.25659606e-02</span> <span class="o">-</span><span class="mf">2.63400086e-02</span> <span class="o">-</span><span class="mf">5.04184562e-03</span>
  <span class="mf">3.08099470e-02</span>  <span class="mf">7.64264738e-02</span>  <span class="mf">1.23536693e-01</span>  <span class="mf">1.62377258e-01</span>
  <span class="mf">1.84320776e-01</span>  <span class="mf">1.84320776e-01</span>  <span class="mf">1.62377258e-01</span>  <span class="mf">1.23536693e-01</span>
  <span class="mf">7.64264738e-02</span>  <span class="mf">3.08099470e-02</span> <span class="o">-</span><span class="mf">5.04184562e-03</span> <span class="o">-</span><span class="mf">2.63400086e-02</span>
 <span class="o">-</span><span class="mf">3.25659606e-02</span> <span class="o">-</span><span class="mf">2.69313236e-02</span> <span class="o">-</span><span class="mf">1.48306750e-02</span> <span class="o">-</span><span class="mf">1.90555639e-03</span>
  <span class="mf">7.60955496e-03</span>  <span class="mf">1.17766532e-02</span>  <span class="mf">1.09302641e-02</span>  <span class="mf">6.93100252e-03</span>
  <span class="mf">2.10562324e-03</span> <span class="o">-</span><span class="mf">1.68583512e-03</span> <span class="o">-</span><span class="mf">3.55412543e-03</span> <span class="o">-</span><span class="mf">3.58236429e-03</span>
 <span class="o">-</span><span class="mf">2.46268845e-03</span> <span class="o">-</span><span class="mf">1.01714338e-03</span>  <span class="mf">1.64604862e-04</span>  <span class="mf">8.51595307e-04</span>
  <span class="mf">1.08410297e-03</span>  <span class="mf">9.92977939e-04</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="exemple-de-cas-d-utilisation">
<h3>Exemple de cas d’utilisation<a class="headerlink" href="#exemple-de-cas-d-utilisation" title="Permalink to this headline">¶</a></h3>
<p>Pour comprendre comment les filtres sont utilisés, prenons un exemple où nous accordons notre radio logicielle sur la fréquence d’un signal existant, et nous voulons l’isoler des autres signaux.  Rappelez-vous que nous indiquons à notre SDR la fréquence à laquelle il doit s’accorder, mais que les échantillons capturés par le SDR sont en bande de base, ce qui signifie que le signal s’affichera comme centré autour de 0 Hz. Nous devrons garder la trace de la fréquence sur laquelle nous avons demandé au SDR de s’accorder.  Voici ce que nous pourrions recevoir :</p>
<a class="reference internal image-reference" href="../_images/filter_use_case.png"><img alt="../_images/filter_use_case.png" class="align-center" src="../_images/filter_use_case.png" style="width: 595.6999999999999px; height: 326.2px;" /></a>
<p>Comme notre signal est déjà centré sur le courant continu DC (0 Hz), nous savons que nous voulons un filtre passe-bas.  Nous devons choisir une “fréquence de coupure” (aussi appelée fréquence d’angle), qui déterminera le moment où la bande passante passe en bande rejetée.  La fréquence de coupure sera toujours exprimée en Hz.  Dans cet exemple, 3 kHz semble être une bonne valeur :</p>
<a class="reference internal image-reference" href="../_images/filter_use_case2.png"><img alt="../_images/filter_use_case2.png" class="align-center" src="../_images/filter_use_case2.png" style="width: 599.9px; height: 325.5px;" /></a>
<p>Cependant, dans la plupart des filtres passe-bas, la limite de fréquence négative sera également de -3 kHz.  C’est-à-dire qu’elle est symétrique autour du DC (vous verrez plus tard pourquoi).  Nos fréquences de coupure ressembleront à ceci (la bande passante est la zone intermédiaire) :</p>
<a class="reference internal image-reference" href="../_images/filter_use_case3.png"><img alt="../_images/filter_use_case3.png" class="align-center" src="../_images/filter_use_case3.png" style="width: 420.0px; height: 323.4px;" /></a>
<p>Après avoir créé et appliqué le filtre avec une fréquence de coupure de 3 kHz, nous avons maintenant :</p>
<a class="reference internal image-reference" href="../_images/filter_use_case4.png"><img alt="../_images/filter_use_case4.png" class="align-center" src="../_images/filter_use_case4.png" style="width: 451.49999999999994px; height: 330.4px;" /></a>
<p>Ce signal filtré peut sembler déroutant jusqu’à ce que vous vous rappeliez que notre plancher de bruit <em>était</em> à la ligne verte autour de -65 dB.  Même si nous pouvons toujours voir le signal parasite centré à 10 kHz, nous avons <em>sévèrement</em> diminué la puissance de ce signal. Elle est maintenant inférieure à celle du plancher de bruit!  Nous avons également éliminé la plupart du bruit qui existait dans la bande rejetée.</p>
<p>En plus de la fréquence de coupure, l’autre paramètre principal de notre filtre passe-bas est appelé “largeur de transition”.  La largeur de transition, également mesurée en Hz, indique au filtre à quelle vitesse il doit passer de la bande passante à la bande rejetée, car une transition instantanée est impossible en pratique.</p>
<p>Visualisons la largeur de transition.  Dans le diagramme ci-dessous, la ligne <span class="green">verte</span> représente la réponse idéale pour la transition entre une bande passante et une bande d’arrêt, qui a essentiellement une largeur de transition de zéro.  La ligne <span class="red">rouge</span> montre le résultat d’un filtre réaliste, qui présente une certaine ondulation et une certaine largeur de transition.</p>
<a class="reference internal image-reference" href="../_images/realistic_filter.png"><img alt="../_images/realistic_filter.png" class="align-center" src="../_images/realistic_filter.png" style="width: 526.0px; height: 315.0px;" /></a>
<p>Vous vous demandez peut-être pourquoi nous n’avons pas simplement défini la largeur de transition la plus petite possible.  La raison principale est qu’une largeur de transition plus petite entraîne un plus grand nombre de taps, et plus de taps signifie plus de calculs - nous verrons pourquoi sous peu.  Un filtre de 50 taps peut fonctionner toute la journée en utilisant 1% du CPU d’un Raspberry Pi.  En revanche, un filtre à 50 000 prises fera exploser votre CPU !
En général, nous utilisons un outil de conception de filtre, puis nous voyons combien de taps il produit, et si c’est beaucoup trop (par exemple, plus de 100), nous augmentons la largeur de transition.  Tout dépend de l’application et du matériel qui exécute le filtre, bien sûr.</p>
<p>Dans l’exemple de filtrage ci-dessus, nous avions utilisé une coupure de 3 kHz et une largeur de transition de 1 kHz (il est difficile de voir la largeur de transition en regardant ces captures d’écran).  Le filtre résultant a 77 taps.</p>
<p>Revenons à la représentation des filtres.  Même si nous pouvons montrer la liste des taps d’un filtre, nous représentons généralement les filtres visuellement dans le domaine fréquentiel.  Nous appelons cela la “réponse fréquencielle” du filtre, et elle nous montre le comportement du filtre en fréquence. Voici la réponse en fréquence du filtre que nous venons d’utiliser :</p>
<a class="reference internal image-reference" href="../_images/filter_use_case5.png"><img alt="../_images/filter_use_case5.png" class="align-center" src="../_images/filter_use_case5.png" style="width: 575.0px; height: 275.0px;" /></a>
<p>Notez que ce que je montre ici <em>n’est pas</em> un signal - c’est juste la représentation du filtre dans le domaine fréquenciel.  Cela peut être un peu difficile à comprendre au début, mais au fur et à mesure des exemples et du code, cela deviendra plus clair.</p>
<p>Un filtre donné a également une représentation dans le domaine temporel; on l’appelle la “réponse impulsionnelle” du filtre car c’est ce que vous voyez dans le domaine temporel si vous prenez une impulsion et la faites passer par le filtre. (Cherche sur Google “fonction delta de Dirac” pour plus d’informations sur ce qu’est une impulsion). Pour un filtre de type FIR, la réponse impulsionnelle est simplement les taps eux-mêmes.  Pour le filtre à 77 taps que nous avons utilisé précédemment, les prises sont les suivantes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span>  <span class="p">[</span><span class="o">-</span><span class="mf">0.00025604525581002235</span><span class="p">,</span> <span class="mf">0.00013669139298144728</span><span class="p">,</span> <span class="mf">0.0005385575350373983</span><span class="p">,</span>
<span class="mf">0.0008378280326724052</span><span class="p">,</span> <span class="mf">0.000906112720258534</span><span class="p">,</span> <span class="mf">0.0006353431381285191</span><span class="p">,</span>
<span class="o">-</span><span class="mf">9.884083502996931e-19</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0008822851814329624</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0017323142383247614</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.0021665366366505623</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0018335371278226376</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0005912294145673513</span><span class="p">,</span>
<span class="mf">0.001349081052467227</span><span class="p">,</span> <span class="mf">0.0033936649560928345</span><span class="p">,</span> <span class="mf">0.004703888203948736</span><span class="p">,</span>
<span class="mf">0.004488115198910236</span><span class="p">,</span> <span class="mf">0.0023609865456819534</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0013707970501855016</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.00564080523326993</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.008859002031385899</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.009428252466022968</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.006394983734935522</span><span class="p">,</span> <span class="mf">4.76480351940553e-18</span><span class="p">,</span> <span class="mf">0.008114570751786232</span><span class="p">,</span>
<span class="mf">0.015200719237327576</span><span class="p">,</span> <span class="mf">0.018197273835539818</span><span class="p">,</span> <span class="mf">0.01482443418353796</span><span class="p">,</span>
<span class="mf">0.004636279307305813</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.010356673039495945</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.025791890919208527</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.03587324544787407</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.034922562539577484</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.019146423786878586</span><span class="p">,</span>
<span class="mf">0.011919975280761719</span><span class="p">,</span> <span class="mf">0.05478153005242348</span><span class="p">,</span> <span class="mf">0.10243935883045197</span><span class="p">,</span>
<span class="mf">0.1458890736103058</span><span class="p">,</span> <span class="mf">0.1762896478176117</span><span class="p">,</span> <span class="mf">0.18720689415931702</span><span class="p">,</span>
<span class="mf">0.1762896478176117</span><span class="p">,</span> <span class="mf">0.1458890736103058</span><span class="p">,</span> <span class="mf">0.10243935883045197</span><span class="p">,</span>
<span class="mf">0.05478153005242348</span><span class="p">,</span> <span class="mf">0.011919975280761719</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.019146423786878586</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.034922562539577484</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03587324544787407</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.025791890919208527</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.010356673039495945</span><span class="p">,</span> <span class="mf">0.004636279307305813</span><span class="p">,</span> <span class="mf">0.01482443418353796</span><span class="p">,</span>
<span class="mf">0.018197273835539818</span><span class="p">,</span> <span class="mf">0.015200719237327576</span><span class="p">,</span> <span class="mf">0.008114570751786232</span><span class="p">,</span>
<span class="mf">4.76480351940553e-18</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.006394983734935522</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.009428252466022968</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.008859002031385899</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00564080523326993</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0013707970501855016</span><span class="p">,</span>
<span class="mf">0.0023609865456819534</span><span class="p">,</span> <span class="mf">0.004488115198910236</span><span class="p">,</span> <span class="mf">0.004703888203948736</span><span class="p">,</span>
<span class="mf">0.0033936649560928345</span><span class="p">,</span> <span class="mf">0.001349081052467227</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0005912294145673513</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.0018335371278226376</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0021665366366505623</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0017323142383247614</span><span class="p">,</span>
<span class="o">-</span><span class="mf">0.0008822851814329624</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.884083502996931e-19</span><span class="p">,</span> <span class="mf">0.0006353431381285191</span><span class="p">,</span>
<span class="mf">0.000906112720258534</span><span class="p">,</span> <span class="mf">0.0008378280326724052</span><span class="p">,</span> <span class="mf">0.0005385575350373983</span><span class="p">,</span>
<span class="mf">0.00013669139298144728</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00025604525581002235</span><span class="p">]</span>
</pre></div>
</div>
<p>Et même si nous n’avons pas encore abordé la conception des filtres, voici le code Python qui a généré ce filtre:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">num_taps</span> <span class="o">=</span> <span class="mi">51</span> <span class="c1"># Il est utile d&#39;utiliser un nombre impair de robinets.</span>
<span class="n">cut_off</span> <span class="o">=</span> <span class="mi">3000</span> <span class="c1"># Hz</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">32000</span> <span class="c1"># Hz</span>

<span class="c1"># créer notre filtre passe-bas</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">num_taps</span><span class="p">,</span> <span class="n">cut_off</span><span class="p">,</span> <span class="n">nyq</span><span class="o">=</span><span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># tracer la réponse impulsionnelle</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Le simple fait de tracer ce tableau de flottants nous donne la réponse impulsionnelle du filtre:</p>
<a class="reference internal image-reference" href="../_images/impulse_response.png"><img alt="../_images/impulse_response.png" class="align-center" src="../_images/impulse_response.png" style="width: 562.0px; height: 283.0px;" /></a>
<p>Et voici le code qui a été utilisé pour produire la réponse fréquentielle, présentée plus tôt.  C’est un peu plus compliqué car nous devons créer le tableau des fréquences sur l’axe des x.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># tracer la réponse en fréquence</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span> <span class="c1"># prendre la FFT 1024 points et la magnitude</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="c1"># centrer à 0 Hz</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">))</span> <span class="c1"># axe des x</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="filtres-reels-et-complexes">
<h3>Filtres Réels et Complexes<a class="headerlink" href="#filtres-reels-et-complexes" title="Permalink to this headline">¶</a></h3>
<p>Le filtre que je vous ai montré avait des taps réelles, mais les taps peuvent aussi être complexes. Le fait que les taps soient réelles ou complexes ne doit pas nécessairement correspondre au signal que vous faites passer par le filtre, c’est-à-dire que vous pouvez faire passer un signal complexe par un filtre avec des taps réelles et vice versa.  Lorsque les taps sont réelles, la réponse en fréquence du filtre sera symétrique autour du DC (0 Hz).  En général, nous utilisons des prises complexes lorsque nous avons besoin d’asymétrie, ce qui arrive très rarement.</p>
<a class="reference internal image-reference" href="../_images/complex_taps.png"><img alt="../_images/complex_taps.png" class="align-center" src="../_images/complex_taps.png" style="width: 787.2px; height: 193.60000000000002px;" /></a>
<p>Pour illustrer les prises complexes, revenons au cas d’utilisation du filtrage, sauf que cette fois, nous voulons recevoir l’autre signal parasite (sans avoir à réaccorder la radio). Cela signifie que nous voulons un filtre passe-bande, mais pas un filtre symétrique. Nous voulons seulement garder (c’est-à-dire “passer”) les fréquences entre environ 7 kHz et 13 kHz (nous ne voulons pas passer également de -13 kHz à -7 kHz) :</p>
<a class="reference internal image-reference" href="../_images/filter_use_case6.png"><img alt="../_images/filter_use_case6.png" class="align-center" src="../_images/filter_use_case6.png" style="width: 418.59999999999997px; height: 310.09999999999997px;" /></a>
<p>Une façon de concevoir ce type de filtre est de réaliser un filtre passe-bas avec une coupure de 3 kHz, puis de le décaler en fréquence.  Rappelez-vous que nous pouvons décaler la fréquence de x(t) (domaine temporel) en la multipliant par <img class="math" src="../_images/math/96dfb45b25ce9d4a2fd55cf9e8da4f3886436897.svg" alt="e^{j2\pi f_0t}"/>. Dans ce cas, <img class="math" src="../_images/math/da647bd66569f61d6a3f16c3c2e09085c351a343.svg" alt="f_0"/> devrait être 10 kHz, ce qui décale notre filtre de 10 kHz. Rappelez-vous que dans notre code Python ci-dessus, <img class="math" src="../_images/math/2475529ef4582ec92a0ef0ee2a266a22d98ba80d.svg" alt="h"/> était les taps du filtre passe-bas. Afin de créer notre filtre passe-bande, il suffit de multiplier ces prises par <img class="math" src="../_images/math/96dfb45b25ce9d4a2fd55cf9e8da4f3886436897.svg" alt="e^{j2\pi f_0t}"/>, bien que cela implique la création d’un vecteur pour représenter le temps basé sur notre période d’échantillonnage (inverse de la fréquence d’échantillonnage) :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># (h a été trouvé en utilisant le premier extrait de code)</span>

<span class="c1"># Décaler le filtre en fréquence en multipliant par exp(j*2*pi*f0*t)</span>
<span class="n">f0</span> <span class="o">=</span> <span class="mf">10e3</span> <span class="c1"># le montant que nous allons transférer</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># période de l&#39;échantillon</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">Ts</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">Ts</span><span class="p">)</span> <span class="c1"># vecteur temps. les arguments sont (début, fin, pas)</span>
<span class="n">exponential</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f0</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># il s&#39;agit essentiellement d&#39;une onde sinusoïdale complexe</span>

<span class="n">h_band_pass</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">exponential</span> <span class="c1"># faire le décallage</span>

<span class="c1"># tracer la réponse impulsionnelle</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;impulsion&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">h_band_pass</span><span class="p">),</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">h_band_pass</span><span class="p">),</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;reél&#39;</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># tracer la réponse en fréquence</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">h_band_pass</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span> <span class="c1"># prendre la FFT 1024 points et l&#39;amplitude</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="c1"># faire 0 Hz au centre</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">))</span> <span class="c1"># axes des x</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;freq&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Fréquence [Hz]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The plots of the impulse response and frequency response are shown below:</p>
<a class="reference internal image-reference" href="../_images/shifted_filter.png"><img alt="../_images/shifted_filter.png" class="align-center" src="../_images/shifted_filter.png" style="width: 637.1999999999999px; height: 312.59999999999997px;" /></a>
<p>Comme notre filtre n’est pas symétrique autour de 0 Hz, il doit utiliser des taps complexes. Nous avons donc besoin de deux lignes pour tracer ces taps complexes. Ce que nous voyons dans le graphique de gauche ci-dessus est toujours la réponse impulsionnelle.  Notre courbe de réponse fréquencielle est ce qui valide réellement le fait que nous avons créé le type de filtre que nous espérions, où il filtrera tout sauf le signal centré autour de 10 kHz.  Une fois encore, n’oubliez pas que le tracé ci-dessus <em>n’est pas</em> un signal réel: il s’agit simplement d’une représentation du filtre.  Cela peut être très déroutant à comprendre, car lorsque vous appliquez le filtre au signal et que vous tracez la sortie dans le domaine fréquentiel, dans de nombreux cas, elle aura à peu près la même apparence que la réponse en fréquence du filtre lui-même.</p>
<p>Si cette sous-section a ajouté à la confusion, ne vous inquiétez pas, dans 99% des cas, vous aurez affaire à de simples filtres passe-bas avec des taps réelles de toute façon.</p>
</div>
</div>
<div class="section" id="implementation-des-filtres">
<h2>Implémentation des Filtres<a class="headerlink" href="#implementation-des-filtres" title="Permalink to this headline">¶</a></h2>
<p>Nous n’allons pas nous plonger trop profondément dans l’implémentation des filtres. Je me concentre plutôt sur la conception des filtres (de toute façon, vous pouvez trouver des implémentations prêtes à l’emploi dans n’importe quel langage de programmation).  Pour l’instant, voici ce qu’il faut retenir: pour filtrer un signal avec un filtre FIR, il suffit de convoluer la réponse impulsionnelle (le vecteur de taps) avec le signal d’entrée.  (Ne vous inquiétez pas, une section ultérieure explique la convolution.) Dans le monde discret, nous utilisons une convolution discrète (exemple ci-dessous). Les triangles labelisés par des <em>b</em> sont les taps. Dans le schéma, les carrés labelisés <img class="math" src="../_images/math/4ab963b7331cae46b916c29afa4dc9f2831023fa.svg" alt="z^{-1}"/> au-dessus des triangles signifient qu’il faut retarder d’un pas de temps.</p>
<a class="reference internal image-reference" href="../_images/discrete_convolution.png"><img alt="../_images/discrete_convolution.png" class="align-center" src="../_images/discrete_convolution.png" style="width: 385.6px; height: 152.8px;" /></a>
<p>Vous pouvez peut-être comprendre pourquoi nous les appelons maintenant des “taps” (<em>robinet</em> en anglais) de filtre, compte tenu de la façon dont le filtre lui-même est mis en œuvre.</p>
<div class="section" id="fir-vs-iir">
<h3>FIR vs IIR<a class="headerlink" href="#fir-vs-iir" title="Permalink to this headline">¶</a></h3>
<p>Il existe deux grandes classes de filtres numériques: FIR et IIR
1. Réponse impulsionnelle finie (<em>FIR pour Finite Impulse Response</em> en anglais)
2. Réponse impulsionnelle infinie (<em>IIR pour InFinite Impulse Response</em> en anglais)</p>
<p>Nous n’entrerons pas trop dans la théorie, pour l’instant, souvenez-vous que Les filtres FIR sont plus faciles à concevoir et peuvent faire tout ce que vous voulez si vous utilisez suffisamment de taps. Les filtres IIR en revanche sont plus compliqués et peuvent être instables, mais ils sont plus efficaces (ils utilisent moins de CPU et de mémoire pour un filtre donné). Si quelqu’un vous donne une liste de taps, on suppose qu’il s’agit de taps pour un filtre FIR.  S’il commence à mentionner des “pôles”, il s’agit de filtres IIR.  Nous nous en tiendrons aux filtres FIR dans ce manuel.</p>
<p>Vous trouverez ci-dessous un exemple de réponse fréquencielle, comparant un filtre FIR et un filtre IIR qui effectuent presque exactement le même filtrage; ils ont une largeur de transition similaire qui, comme nous l’avons appris, détermine le nombre de taps nécessaires.  Le filtre FIR a 50 prises et le filtre IIR a 12 pôles, ce qui revient à avoir 12 taps en termes de calculs nécessaires.</p>
<a class="reference internal image-reference" href="../_images/FIR_IIR.png"><img alt="../_images/FIR_IIR.png" class="align-center" src="../_images/FIR_IIR.png" style="width: 529.9px; height: 459.2px;" /></a>
<p>La leçon à retenir est que le filtre FIR nécessite beaucoup plus de ressources informatiques que le filtre IIR pour effectuer à peu près la même opération de filtrage.</p>
<p>Voici quelques exemples concrets de filtres FIR et IIR que vous avez peut-être déjà utilisés.</p>
<p>Si vous effectuez une “moyenne glissante” sur une liste de nombres, il s’agit simplement d’un filtre FIR avec des taps de 1:
- h = [1 1 1 1 1 1 1 1 1 1 1 1] pour un filtre de moyenne glissante avec une taille de fenêtre de 10.  Il s’agit également d’un filtre passe-bas, pourquoi?  Quelle est la différence entre l’utilisation de 1 et l’utilisation de taps qui diminuent jusqu’à zéro ?</p>
<details>
<summary>Réponse</summary><p>Un filtre à moyenne glissante est un filtre passe-bas car il atténue les changements de “haute fréquence”, ce qui est généralement la raison pour laquelle les gens en utilisent un.  La raison pour laquelle il faut utiliser des taps qui diminuent jusqu’à zéro aux deux extrémités est d’éviter un changement soudain dans la sortie, comme si le signal filtré était nul pendant un certain temps, puis augmentait soudainement.</p>
</details><p>Maintenant, un exemple de filtre IIR.  L’un d’entre vous a-t-il déjà fait ceci :</p>
<blockquote>
<div>x = x*0.99 + nouvelle_valeur*0.01</div></blockquote>
<p>où les 0,99 et 0,01 représentent la vitesse de mise à jour de la valeur (ou le taux de décroissance, même chose). C’est un moyen pratique de mettre à jour lentement une variable sans avoir à se souvenir des dernières valeurs.  Il s’agit en fait d’une forme de filtre IIR passe-bas.  Avec un peu de chance, vous avez compris pourquoi les filtres IIR sont moins stables que les filtres FIR: les valeurs ne disparaissent jamais complètement !</p>
</div>
</div>
<div class="section" id="outils-de-conception-de-filtres">
<h2>Outils de conception de filtres<a class="headerlink" href="#outils-de-conception-de-filtres" title="Permalink to this headline">¶</a></h2>
<p>En pratique, la plupart des gens utiliseront un outil de conception de filtre ou une fonction dans le code qui conçoit le filtre.  Il existe de nombreux outils différents, mais pour les étudiants, je recommande cette application Web facile à utiliser de Peter Isza qui vous montrera la réponse impulsionnelle et fréquencielle : <a class="reference external" href="http://t-filter.engineerjs.com" rel="noopener noreferrer" target="_blank">http://t-filter.engineerjs.com</a>.  En utilisant les valeurs par défaut, du moins au moment de l’écriture de ce document, l’application est configurée pour concevoir un filtre passe-bas avec une bande passante de 0 à 400 Hz et une bande rejetée à partir de 500 Hz. La fréquence d’échantillonnage est de 2 kHz, donc la fréquence maximale que nous pouvons “voir” est de 1 kHz.</p>
<a class="reference internal image-reference" href="../_images/filter_designer1.png"><img alt="../_images/filter_designer1.png" class="align-center" src="../_images/filter_designer1.png" style="width: 659.4px; height: 156.79999999999998px;" /></a>
<p>Cliquez sur le bouton “Design Filter” pour créer les prises et tracer la réponse en fréquence.</p>
<a class="reference internal image-reference" href="../_images/filter_designer2.png"><img alt="../_images/filter_designer2.png" class="align-center" src="../_images/filter_designer2.png" style="width: 970.9px; height: 401.79999999999995px;" /></a>
<p>Cliquez sur le texte “Impulse Response” au-dessus du graphique pour voir la réponse impulsionnelle, qui est une courbe des taps puisqu’il s’agit d’un filtre FIR.</p>
<a class="reference internal image-reference" href="../_images/filter_designer3.png"><img alt="../_images/filter_designer3.png" class="align-center" src="../_images/filter_designer3.png" style="width: 798.0px; height: 388.5px;" /></a>
<p>Cette application inclut même le code source C++ pour implémenter et utiliser ce filtre.  L’application web n’inclut aucun moyen de concevoir des filtres IIR, qui sont en général beaucoup plus difficiles à concevoir.</p>
</div>
<div class="section" id="convolution">
<h2>Convolution<a class="headerlink" href="#convolution" title="Permalink to this headline">¶</a></h2>
<p>Nous allons faire un bref détour pour présenter l’opérateur de convolution. N’hésitez pas à sauter cette section si elle vous est déjà familière.</p>
<p>L’addition de deux signaux est une façon de combiner deux signaux en un seul. Dans le chapitre <a class="reference internal" href="../content-nl/frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a>, nous avons étudié comment la propriété de linéarité s’applique à l’addition de deux signaux.  La convolution est une autre façon de combiner deux signaux en un seul, mais elle est très différente de leur simple addition.  La convolution de deux signaux revient à en glisser un sur l’autre et à l’intégrer.  Elle est <em>très</em> similaire à une corrélation croisée, si vous êtes familier avec cette opération.  En fait, elle est équivalente à une corrélation croisée dans de nombreux cas.</p>
<p>Je pense que l’opération de convolution s’apprend mieux par des exemples. Dans ce premier exemple, nous convoluons deux impulsions carrées ensemble :</p>
<a class="reference internal image-reference" href="../_images/convolution_animation1.gif"><img alt="../_images/convolution_animation1.gif" class="align-center" src="../_images/convolution_animation1.gif" style="width: 480.0px; height: 360.0px;" /></a>
<p>Comme il s’agit simplement d’une intégration glissante, le résultat est un triangle avec un maximum au point où les deux impulsions carrées s’alignent parfaitement.  Voyons ce qui se passe si nous convolvons une impulsion carrée avec une impulsion triangulaire :</p>
<a class="reference internal image-reference" href="../_images/convolution_animation2.gif"><img alt="../_images/convolution_animation2.gif" class="align-center" src="../_images/convolution_animation2.gif" style="width: 639.0px; height: 349.5px;" /></a>
<p>Dans les deux exemples, nous avons deux signaux d’entrée (un rouge, un bleu), puis la sortie de la convolution est affichée.  Vous pouvez voir que la sortie est l’intégration des deux signaux, l’un glissant sur l’autre.  En raison de cette nature “glissante”, la longueur de la sortie est en fait plus longue que celle de l’entrée.  Si un signal contient <code class="code docutils literal notranslate"><span class="pre">M</span></code> échantillons et l’autre <code class="code docutils literal notranslate"><span class="pre">N</span></code> échantillons, la convolution des deux signaux peut produire <code class="code docutils literal notranslate"><span class="pre">N+M-1</span></code> échantillons.  Cependant, des fonctions telles que <code class="code docutils literal notranslate"><span class="pre">numpy.convolve()</span></code> permettent de spécifier si vous voulez la totalité du résultat (<code class="code docutils literal notranslate"><span class="pre">max(M,</span> <span class="pre">N)</span></code> échantillons) ou seulement les échantillons où les signaux se chevauchent complètement (<code class="code docutils literal notranslate"><span class="pre">max(M,</span> <span class="pre">N)</span> <span class="pre">-</span> <span class="pre">min(M,</span> <span class="pre">N)</span> <span class="pre">+</span> <span class="pre">1</span></code> si vous êtes curieux).  Il n’est pas nécessaire de s’attarder sur ces détails. Sachez simplement que la longueur de la sortie d’une convolution n’est pas seulement la longueur des entrées.</p>
<p>Alors pourquoi la convolution est-elle importante en DSP? Pour commencer, pour filtrer un signal, nous pouvons simplement prendre la réponse impulsionnelle de ce filtre et la convoluer avec le signal. Le filtrage FIR est simplement une opération de convolution.</p>
<a class="reference internal image-reference" href="../_images/filter_convolve.png"><img alt="../_images/filter_convolve.png" class="align-center" src="../_images/filter_convolve.png" style="width: 502.59999999999997px; height: 275.79999999999995px;" /></a>
<p>Cela peut prêter à confusion car nous avons mentionné précédemment que la convolution prend deux <em>signaux</em> et en sort un.  Nous pouvons traiter la réponse impulsionnelle comme un signal, et la convolution est un opérateur mathématique après tout, qui opère sur deux tableaux 1D.  Si l’un de ces tableaux 1D est la réponse impulsionnelle du filtre, l’autre tableau 1D peut être un morceau du signal d’entrée, et la sortie sera une version filtrée de l’entrée.</p>
<p>Voyons un autre exemple. Dans l’exemple ci-dessous, le triangle représente la réponse impulsionnelle de notre filtre, et le signal <span class="green">vert</span> est notre signal filtré.</p>
<a class="reference internal image-reference" href="../_images/convolution.gif"><img alt="../_images/convolution.gif" class="align-center" src="../_images/convolution.gif" style="width: 347.2px; height: 226.79999999999998px;" /></a>
<p>La sortie <span class="red">rouge</span> est le signal filtré.</p>
<p>Question : Quel type de filtre était le triangle ?</p>
<details>
<summary>Réponse</summary><p>Il atténue les composantes haute fréquence du signal vert (c’est-à-dire les transitions nettes du carré) et agit donc comme un filtre passe-bas.</p>
</details><p>Maintenant que nous commençons à comprendre la convolution, je vais vous présenter son équation mathématique. L’astérisque (*) est généralement utilisé comme symbole de la convolution :</p>
<div class="math">
<p><img src="../_images/math/ef8e9cf9b5e1ed3093ee71fd9b8d1d4c92726693.svg" alt="(f * g)(t) = \int f(\tau) g(t - \tau) d\tau"/></p>
</div><p>Dans l’expression ci-dessus, <img class="math" src="../_images/math/cbb9334036d822d51e4eac3510e2186f3bdfbbdf.svg" alt="g(t)"/> est le signal ou l’entrée qui est inversée et glisse sur <img class="math" src="../_images/math/90b2784922f8eb4c71fae53b32ce51593054e5a4.svg" alt="f(t)"/>, mais <img class="math" src="../_images/math/cbb9334036d822d51e4eac3510e2186f3bdfbbdf.svg" alt="g(t)"/> et <img class="math" src="../_images/math/90b2784922f8eb4c71fae53b32ce51593054e5a4.svg" alt="f(t)"/> peuvent être intervertis et il s’agit toujours de la même expression.  En général, le vecteur le plus court sera utilisé comme <img class="math" src="../_images/math/cbb9334036d822d51e4eac3510e2186f3bdfbbdf.svg" alt="g(t)"/>. La convolution est égale à une corrélation croisée, définie comme <img class="math" src="../_images/math/49a7dd0e8b56496ace0c96543c01ab2bff092755.svg" alt="\int f(\tau) g(t+\tau)"/>, lorsque <img class="math" src="../_images/math/cbb9334036d822d51e4eac3510e2186f3bdfbbdf.svg" alt="g(t)"/> est symétrique, c’est-à-dire qu’il ne change pas lorsqu’il est retourné autour de l’origine.</p>
</div>
<div class="section" id="conception-de-filtres-en-python">
<h2>Conception de Filtres en Python<a class="headerlink" href="#conception-de-filtres-en-python" title="Permalink to this headline">¶</a></h2>
<p>Nous allons maintenant étudier une façon de concevoir nous-mêmes un filtre FIR en Python.  Bien qu’il existe de nombreuses approches de la conception de filtres, nous utiliserons la méthode consistant à commencer dans le domaine fréquentiel et à revenir en arrière pour trouver la réponse impulsionnelle. Car en fin de compte, c’est ainsi que notre filtre est représenté (par ses taps).</p>
<p>Vous commencez par créer un vecteur de votre réponse en fréquence souhaitée.  Concevons un filtre passe-bas de forme arbitraire illustré ci-dessous:</p>
<a class="reference internal image-reference" href="../_images/filter_design1.png"><img alt="../_images/filter_design1.png" class="align-center" src="../_images/filter_design1.png" style="width: 525.6999999999999px; height: 213.5px;" /></a>
<p>Le code utilisé pour créer ce filtre est assez simple :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">hstack()</span></code> est une façon de concaténer des vecteur en numpy. Nous savons que cela mènera à un filtre avec des taps complexes. Pourquoi ?</p>
<details>
<summary>Réponse</summary><p>Il n’est pas symétrique autour de 0 Hz.</p>
</details><p>Notre objectif final est de trouver les prises de ce filtre afin de pouvoir l’utiliser.  Comment obtenir les taps, étant donné la réponse fréquentielle? Eh bien, comment convertir le domaine fréquentiel en domaine temporel? La FFT inverse (IFFT)!  Rappelez-vous que la fonction IFFT est presque exactement la même que la fonction FFT.  Nous devons également décaler la réponse en fréquence souhaitée avant la IFFT, puis décaler à nouveau la réponse en fréquence après la IFFT (non, elles ne s’annulent pas toutes seules, vous pouvez essayer). Ce processus peut sembler déroutant. Rappelez-vous simplement que vous devez toujours effectuer un FFTshift après un FFT et un IFFshift après un IFFT.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;réél&#39;</span><span class="p">,</span><span class="s1">&#39;imag&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/filter_design2.png"><img alt="../_images/filter_design2.png" class="align-center" src="../_images/filter_design2.png" style="width: 503.1px; height: 306.90000000000003px;" /></a>
<p>Nous allons utiliser les taps indiqués ci-dessus comme filtre.  Nous savons que la réponse impulsionnelle consiste à tracer les taps, donc ce que nous voyons ci-dessus <em>est</em> notre réponse impulsionnelle. Prenons la FFT de nos taps pour voir à quoi ressemble réellement la réponse fréquentielle. Nous allons faire une FFT de 1 024 points pour obtenir une haute résolution :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">H_fft</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/filter_design3.png"><img alt="../_images/filter_design3.png" class="align-center" src="../_images/filter_design3.png" style="width: 806.4px; height: 240.79999999999998px;" /></a>
<p>Voyez comment la réponse en fréquence n’est pas très droite… elle ne correspond pas très bien à notre forme originale, si vous vous souvenez de la forme pour laquelle nous voulions initialement faire un filtre.  Une des raisons principales est que notre réponse impulsionnelle n’a pas fini de décroître, c’est-à-dire que les côtés gauche et droit n’atteignent pas zéro.  Nous avons deux options qui lui permettront de décroître jusqu’à zéro :</p>
<p><strong>Option 1:</strong> Nous “fenêtrons” notre réponse impulsionnelle actuelle de manière à ce qu’elle décroisse vers 0 des deux côtés.  Il s’agit de multiplier notre réponse impulsionnelle par une “fonction de fenêtrage” qui commence et se termine à zéro.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Après avoir créé h en utilisant le code précédent, créez et appliquez la fenêtre</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">window</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/filter_design4.png"><img alt="../_images/filter_design4.png" class="align-center" src="../_images/filter_design4.png" style="width: 770.0px; height: 226.1px;" /></a>
<p><strong>Option 2:</strong> Nous générons à nouveau notre réponse impulsionnelle en utilisant davantage de points afin qu’elle ait le temps de s’annuler. Nous devons ajouter de la résolution à notre vecteur original dans le domaine des fréquences (appelé interpolation).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">200</span><span class="p">)))</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># (le reste du code est le même)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/filter_design5.png"><img alt="../_images/filter_design5.png" class="align-center" src="../_images/filter_design5.png" style="width: 465.59999999999997px; height: 296.4px;" /></a>
<a class="reference internal image-reference" href="../_images/filter_design6.png"><img alt="../_images/filter_design6.png" class="align-center" src="../_images/filter_design6.png" style="width: 695.0999999999999px; height: 210.0px;" /></a>
<a class="reference internal image-reference" href="../_images/filter_design7.png"><img alt="../_images/filter_design7.png" class="align-center" src="../_images/filter_design7.png" style="width: 503.0px; height: 286.0px;" /></a>
<p>Les deux options ont fonctionné. Laquelle choisiriez-vous?  La deuxième méthode a permis d’obtenir plus de prises, mais la première méthode a permis d’obtenir une réponse en fréquence qui n’était pas très nette et dont le front descendant n’était pas très raide.  Il existe de nombreuses façons de concevoir un filtre, chacune ayant ses propres compromis. Beaucoup considèrent la conception de filtres comme un art.</p>
</div>
<div class="section" id="introduction-a-la-mise-en-forme">
<h2>Introduction à la Mise en Forme<a class="headerlink" href="#introduction-a-la-mise-en-forme" title="Permalink to this headline">¶</a></h2>
<p>Nous allons présenter brièvement un sujet très intéressant au sein de la DSP: la mise en forme. Nous l’étudierons plus tard en profondeur dans son propre chapitre, voir <a class="reference internal" href="../content-nl/pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a>. Il est intéressant de le mentionner en même temps que le filtrage, car la mise en forme est finalement un type de filtre, utilisé dans un but spécifique, avec des propriétés spéciales.</p>
<p>Comme nous l’avons appris, les signaux numériques utilisent des symboles pour représenter un ou plusieurs bits d’information.  Nous utilisons un schéma de modulation numérique tel que ASK, PSK, QAM, FSK, etc., pour moduler une porteuse afin que les informations puissent être envoyées sans fil.  Lorsque nous avons simulé la QPSK dans le chapitre <a class="reference internal" href="digital_modulation.html#modulation-chapitre"><span class="std std-ref">Modulation numérique</span></a>, nous n’avons simulé qu’un seul échantillon par symbole, c’est-à-dire que chaque nombre complexe que nous avons créé était l’un des points de la constellation - c’était un symbole.  En pratique, nous générons normalement plusieurs échantillons par symbole, et la raison est liée au filtrage.</p>
<p>Nous utilisons des filtres pour façonner la “forme” de nos symboles car la forme dans le domaine temporel modifie la forme dans le domaine fréquentiel. Le domaine des fréquences nous informe de la quantité de spectre/largeur de bande que notre signal utilisera, et nous voulons généralement la minimiser. Ce qu’il est important de comprendre, c’est que les caractéristiques spectrales (dans le domaine des fréquences) des symboles de la bande de base ne changent pas lorsque nous modulons sur une porteuse; la bande de base est simplement déplacée vers le haut en fréquence alors que sa forme reste la même, ce qui signifie que la quantité de bande passante qu’elle utilise reste la même.  Lorsque nous utilisons 1 échantillon par symbole, cela revient à transmettre des impulsions carrées. En fait, la BPSK utilisant 1 échantillon par symbole <em>est</em> juste une onde carrée de 1 et -1 aléatoires :</p>
<a class="reference external image-reference" href="../_images/bpsk.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/bpsk.svg" class="align-center" src="../_images/bpsk.svg" /></a>
<p>Et comme nous l’avons appris, les impulsions carrées ne sont pas efficaces car elles utilisent une quantité excessive de spectre:</p>
<img alt="../_images/square-wave.svg" class="align-center" src="../_images/square-wave.svg" /><p>Nous procédons donc à une “mise en forme” de ces symboles en forme de blocs afin qu’ils occupent moins de bande passante dans le domaine des fréquences.  Pour ce faire, nous utilisons un filtre passe-bas qui élimine les composantes haute fréquence de nos symboles.  Vous trouverez ci-dessous un exemple de symboles dans les domaines temporel (en haut) et fréquentiel (en bas), avant et après l’application d’un filtre de mise en forme:</p>
<a class="reference internal image-reference" href="../_images/pulse_shaping.png"><img alt="../_images/pulse_shaping.png" class="align-center" src="../_images/pulse_shaping.png" style="width: 613.1999999999999px; height: 179.89999999999998px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../_images/pulse_shaping_freq.png"><img alt="../_images/pulse_shaping_freq.png" class="align-center" src="../_images/pulse_shaping_freq.png" style="width: 628.2px; height: 315.0px;" /></a>
<p>Notez la rapidité avec laquelle le signal chute en fréquence. Les lobes secondaires sont inférieurs de 30 dB après la mise en forme, soit 1 000 fois moins! Et surtout, le lobe principal est plus étroit, donc moins de spectre est utilisé pour le même nombre de bits par seconde.</p>
<p>Pour l’instant, sachez que les filtres de mise en forme les plus courants sont les suivants :</p>
<ol class="arabic simple">
<li>Filtre à cosinus surélevé</li>
<li>Filtre à racines cosinus surélevé</li>
<li>Filtre Sinc</li>
<li>Filtre gaussien</li>
</ol>
<p>Ces filtres ont généralement un paramètre que vous pouvez ajuster pour diminuer la bande passante utilisée.  La figure ci-dessous montre le domaine temporel et fréquentiel d’un filtre cosinus surélevé avec différentes valeurs de <img class="math" src="../_images/math/3e8f4c4ef388379d55238ac81372a404ab28bcc2.svg" alt="\beta"/>, le paramètre qui définit la pente de l’amortissement, souvent appelé <em>roll-off</em>.</p>
<a class="reference internal image-reference" href="../_images/pulse_shaping_rolloff.png"><img alt="../_images/pulse_shaping_rolloff.png" class="align-center" src="../_images/pulse_shaping_rolloff.png" style="width: 707.2px; height: 202.8px;" /></a>
<p>Vous pouvez voir qu’une valeur plus faible de <img class="math" src="../_images/math/3e8f4c4ef388379d55238ac81372a404ab28bcc2.svg" alt="\beta"/> réduit le spectre utilisé (pour la même quantité de données). Cependant, si la valeur est trop faible, les symboles du domaine temporel mettent plus de temps à revenir à zéro. En fait, lorsque <img class="math" src="../_images/math/4f3447a0acb350996ffd4de1145f4b22132893f0.svg" alt="\beta=0"/>, les symboles ne tombent jamais complètement à zéro, ce qui signifie que nous ne pouvons pas transmettre ces symboles dans la pratique. Une valeur de <img class="math" src="../_images/math/3e8f4c4ef388379d55238ac81372a404ab28bcc2.svg" alt="\beta"/> autour de 0,35 est courante.</p>
<p>Vous en apprendrez beaucoup plus sur la mise en forme, y compris certaines propriétés spéciales que les filtres de mise en forme doivent satisfaire, dans le chapitre <a class="reference internal" href="../content-nl/pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a>.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="noise.html" title="Previous document"><span class="section-number">7. </span>le Bruit et les dB</a>
        </li>
        <li>
          <a href="link_budgets.html" title="Next document"><span class="section-number">9. </span>Bilans de liaison</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>