
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>7. le Bruit et les dB &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8. Filtres" href="filters.html" />
    <link rel="prev" title="6. USRP en Python" href="usrp.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script> 

<div id="topBanner" class="modal">
  <div class="modal-content">
    <div class="modal-header" style="background-color: rgb(255, 240, 129); text-align:center;">
      <i>-- Announcement from Marc --</i><br>I'm leading a new education-oriented open-source project called <a target="_blank" href="https://iqengine.org">IQEngine</a>!<br>It's a web-based SDR toolkit for analyzing, processing, and sharing RF recordings.  Checkout out our <a target="_blank" href="https://github.com/IQEngine/IQEngine">GitHub</a> and <a target="_blank" href="https://discord.gg/k7C8kp3b76">Discord</a>
      <div class="closeButton">
        <span style="font-size:30px; position:absolute; top:0px; right:5px; cursor:pointer; ">&times;</span>
      </div>
    </div>
  </div>
</div>

<script>
  var banner = document.getElementById("topBanner");
  var closeButton = document.getElementsByClassName("closeButton")[0];
  // Close banner if they have already clicked the close button in the past
  if (localStorage.getItem('pysdrvisited')){
    banner.style.display = "none";
  }
  // When they click the close button
  closeButton.onclick = function() {
    banner.style.display = "none";
    localStorage.setItem('pysdrvisited', true);
  }
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7. le Bruit et les dB</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#le-bruit-gaussien">Le Bruit Gaussien</a></li>
<li class="toctree-l2"><a class="reference internal" href="#decibels-db">Decibels (dB)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bruit-dans-le-domaine-frequentiel">Bruit dans le Domaine Fréquentiel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bruit-complexe">Bruit Complexe</a></li>
<li class="toctree-l2"><a class="reference internal" href="#awgn">AWGN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#snr-et-sinr">SNR et SINR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ressources-externes-en-anglais">Ressources Externes (en anglais)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="usrp.html" title="previous chapter"><span class="section-number">6. </span>USRP en Python</a></li>
      <li>Next: <a href="filters.html" title="next chapter"><span class="section-number">8. </span>Filtres</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="usrp.html" title="Previous document"><span class="section-number">6. </span>USRP en Python</a>
        </li>
        <li>
          <a href="filters.html" title="Next document"><span class="section-number">8. </span>Filtres</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="le-bruit-et-les-db">
<span id="noise-chapter"></span><h1><span class="section-number">7. </span>le Bruit et les dB<a class="headerlink" href="#le-bruit-et-les-db" title="Permalink to this headline">¶</a></h1>
<p>Dans ce chapitre, nous aborderons le bruit, notamment la façon dont il est modélisé et traité dans un système de communication sans fil.  Les concepts comprennent l’AWGN, le bruit complexe et le SNR/SINR.  Nous introduirons également les décibels (dB) en cours de route, car ils sont largement utilisés dans les communications sans fil et la radio logicielle.</p>
<div class="section" id="le-bruit-gaussien">
<h2>Le Bruit Gaussien<a class="headerlink" href="#le-bruit-gaussien" title="Permalink to this headline">¶</a></h2>
<p>La plupart des gens connaissent le concept de bruit: des fluctuations indésirables qui peuvent masquer le ou les signaux souhaités. Le bruit ressemble à quelque chose comme:</p>
<a class="reference internal image-reference" href="../_images/noise.png"><img alt="../_images/noise.png" class="align-center" src="../_images/noise.png" style="width: 663.5999999999999px; height: 352.09999999999997px;" /></a>
<p>Notez que la valeur moyenne est égale à zéro dans le graphique temporel.  Si la valeur moyenne n’était pas nulle, nous pourrions soustraire la valeur moyenne, l’appeler un biais, et il nous resterait une moyenne de zéro.  Notez également que les points individuels du graphique ne sont <em>pas</em> “uniformément aléatoires”, c’est-à-dire que les grandes valeurs sont plus rares et la plupart des points sont plus proches de zéro.</p>
<p>Nous appelons ce type de bruit “bruit gaussien”. C’est un bon modèle pour le type de bruit provenant de nombreuses sources naturelles, comme les vibrations thermiques des atomes dans le silicium des composants RF de notre récepteur.  Le <strong>théorème de la limite centrale</strong> nous dit que la somme de nombreux processus aléatoires aura tendance à avoir une distribution gaussienne, même si les processus individuels ont d’autres distributions. En d’autres termes, lorsqu’un grand nombre d’événements aléatoires se produisent et s’accumulent, le résultat semble approximativement gaussien, même si les événements individuels n’ont pas une distribution gaussienne.</p>
<a class="reference external image-reference" href="../_images/central_limit_theorem.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/central_limit_theorem.svg" class="align-center" src="../_images/central_limit_theorem.svg" /></a>
<p>La distribution gaussienne est également appelée distribution “normale” (rappelons une courbe en cloche).</p>
<p>La distribution gaussienne possède deux paramètres: la moyenne et la variance.  Nous avons déjà discuté de la façon dont la moyenne peut être considérée comme nulle, car vous pouvez toujours supprimer la moyenne, ou le biais, si elle n’est pas nulle.  La variance modifie la “puissance” du bruit.  Une variance plus élevée se traduira par des nombres plus importants. C’est pour cette raison que la variance définit la puissance du bruit.</p>
<p>La variance est égale à l’écart-type au carré (<img class="math" src="../_images/math/0936be74b1f1baf6a61fef9ea990545c4644751b.svg" alt="sigma^2"/>).</p>
</div>
<div class="section" id="decibels-db">
<h2>Decibels (dB)<a class="headerlink" href="#decibels-db" title="Permalink to this headline">¶</a></h2>
<p>Nous allons prendre une brève pause pour présenter officiellement les dB. Vous avez peut-être déjà entendu parler de dB, et si vous êtes déjà familier avec cette technologie, vous pouvez sauter cette section.</p>
<p>Le travail en dB est extrêmement utile lorsque nous devons traiter simultanément des petits et des grands nombres, ou simplement un ensemble de très grands nombres. Considérez combien il serait fastidieux de travailler avec des nombres de l’échelle de l’exemple 1 et de l’exemple 2.</p>
<p>Exemple 1: Le signal 1 est reçu à 2 watts et le plancher de bruit est à 0.0000002 watts.</p>
<p>Exemple 2: un broyeur d’ordures est 100 000 fois plus bruyant qu’une zone rurale calme, et une tronçonneuse est 10 000 fois plus bruyante qu’un broyeur d’ordures (en termes de puissance des ondes sonores).</p>
<p>Sans dB, c’est-à-dire en travaillant en termes “linéaires” normaux, nous devons utiliser beaucoup de 0 pour représenter les valeurs des exemples 1 et 2. Franchement, si nous devions représenter quelque chose comme le signal 1 en fonction du temps, nous ne verrions même pas le plancher de bruit. Si l’échelle de l’axe des y allait de 0 à 3 watts, par exemple, le bruit serait trop faible pour apparaître sur le graphique. Pour représenter ces échelles simultanément, nous travaillons avec une échelle logarithmique.</p>
<p>Pour illustrer davantage les problèmes d’échelle que nous rencontrons dans le traitement du signal, considérons les cascades ci-dessous de trois des mêmes signaux. La partie gauche représente le signal original en échelle linéaire, et la partie droite montre les signaux convertis en échelle logarithmique (dB).  Les deux représentations utilisent exactement la même carte de couleurs, où le bleu est la valeur la plus basse et le jaune la plus haute.  Vous pouvez à peine voir le signal de gauche dans l’échelle linéaire.</p>
<a class="reference internal image-reference" href="../_images/linear_vs_log.png"><img alt="../_images/linear_vs_log.png" class="align-center" src="../_images/linear_vs_log.png" style="width: 686.0px; height: 240.79999999999998px;" /></a>
<p>Pour une valeur x donnée, on peut représenter x en dB à l’aide de la formule suivante :</p>
<div class="math">
<p><img src="../_images/math/35f24a017cd3f62cdb401cd6ac8c54dd26c5b6f1.svg" alt="x_{dB} = 10 \log_{10} x"/></p>
</div><p>En Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x_db</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Vous avez peut-être vu que <code class="code docutils literal notranslate"><span class="pre">10</span> <span class="pre">*</span></code> est un <code class="code docutils literal notranslate"><span class="pre">20</span> <span class="pre">*</span></code> dans d’autres domaines.  Chaque fois que vous avez affaire à une puissance quelconque, vous utilisez 10, et vous utilisez 20 si vous avez affaire à une valeur qui n’est pas une puissance, comme la tension ou le courant. En DSP, nous avons tendance à traiter avec une puissance. En fait, il n’y a pas une seule fois dans ce manuel où nous devons utiliser 20 au lieu de 10.</p>
<p>Nous convertissons les dB en linéaires (nombres normaux) en utilisant:</p>
<div class="math">
<p><img src="../_images/math/20766f0f56596f4a74c03729f1bfb5c48d266aca.svg" alt="x = 10^{x_{dB}/10}"/></p>
</div><p>En Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">x_db</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Ne vous laissez pas prendre par la formule, car il y a un concept clé à retenir ici. En DSP, nous traitons à la fois de très grands et de très petits nombres (par exemple, la force d’un signal par rapport à la force du bruit). L’échelle logarithmique en dB nous permet d’avoir une plus grande plage dynamique lorsque nous exprimons des nombres ou les traçons. Elle offre également certaines commodités, comme la possibilité d’additionner alors qu’on multiplierait normalement (comme nous le verrons dans le chapitre <a class="reference internal" href="../content-nl/link_budgets.html#link-budgets-chapter"><span class="std std-ref">Link Budgets</span></a>).</p>
<p>Les erreurs les plus courantes que les gens rencontrent lorsqu’ils sont novices en matière de dB sont les suivantes :</p>
<ol class="arabic simple">
<li>Utiliser le log naturel au lieu du log base 10 car la fonction log() de la plupart des langages de programmation est en fait le log naturel.</li>
<li>Oublier d’inclure le dB lors de l’expression d’un nombre ou de l’étiquetage d’un axe.  Si nous sommes en dB, nous devons l’identifier quelque part.</li>
<li>Lorsque vous êtes en dB, vous additionnez/soustrayez des valeurs au lieu de multiplier/diviser, par ex:</li>
</ol>
<a class="reference internal image-reference" href="../_images/db.png"><img alt="../_images/db.png" class="align-center" src="../_images/db.png" style="width: 854.4000000000001px; height: 221.60000000000002px;" /></a>
<p>Il est également important de comprendre que le dB n’est pas techniquement une “unité”.  Une valeur en dB seule est sans unité, comme si quelque chose était 2x plus grand, il n’y a pas d’unités jusqu’à ce que je vous dise les unités. dB est une chose relative.  En audio, quand on dit dB, on veut dire dBA, qui est l’unité du niveau sonore (le A est l’unité). Dans le domaine du sans fil, nous utilisons généralement les watts pour faire référence à un niveau de puissance réel. Par conséquent, vous pouvez voir l’unité dBW, qui est relative à 1 W. Vous pouvez également voir l’unité dBmW (souvent écrite dBm pour faire court) qui est relative à 1 mW.  Par exemple, quelqu’un peut dire “notre émetteur est réglé sur 3 dBW” (donc 2 watts).  Parfois, nous utilisons le terme dB seul, ce qui signifie qu’il est relatif et qu’il n’y a pas d’unité. On peut dire “notre signal a été reçu 20 dB au-dessus du bruit de fond”.  Voici une petite astuces: 0 dBm = -30 dBW.</p>
<p>Voici quelques conversions courantes que je vous recommande de mémoriser :</p>
<table border="1" class="docutils align-default">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Linéaire</th>
<th class="head">dB</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1x</td>
<td>0 dB</td>
</tr>
<tr class="row-odd"><td>2x</td>
<td>3 dB</td>
</tr>
<tr class="row-even"><td>10x</td>
<td>10 dB</td>
</tr>
<tr class="row-odd"><td>0.5x</td>
<td>-3 dB</td>
</tr>
<tr class="row-even"><td>0.1x</td>
<td>-10 dB</td>
</tr>
<tr class="row-odd"><td>100x</td>
<td>20 dB</td>
</tr>
<tr class="row-even"><td>1000x</td>
<td>30 dB</td>
</tr>
<tr class="row-odd"><td>10000x</td>
<td>40 dB</td>
</tr>
</tbody>
</table>
<p>Enfin, pour mettre ces chiffres en perspective, voici quelques exemples de niveaux de puissance, en dBm :</p>
<table border="1" class="docutils align-default">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>80 dBm</td>
<td>Puissance d’émission d’une station de radio FM rurale</td>
</tr>
<tr class="row-even"><td>62 dBm</td>
<td>Puissance maximale d’un émetteur radio amateur</td>
</tr>
<tr class="row-odd"><td>60 dBm</td>
<td>Puissance d’un micro-ondes domestique typique</td>
</tr>
<tr class="row-even"><td>37 dBm</td>
<td>Puissance maximale d’une radio CB ou d’une radio amateur portative typique</td>
</tr>
<tr class="row-odd"><td>27 dBm</td>
<td>Puissance d’émission typique d’un téléphone cellulaire</td>
</tr>
<tr class="row-even"><td>15 dBm</td>
<td>Puissance d’émission typique du WiFi</td>
</tr>
<tr class="row-odd"><td>10 dBm</td>
<td>Puissance d’émission maximale du Bluetooth (version 4)</td>
</tr>
<tr class="row-even"><td>-10 dBm</td>
<td>Puissance de réception maximale du WiFi</td>
</tr>
<tr class="row-odd"><td>-70 dBm</td>
<td>Exemple de puissance reçue pour un signal radio amateur</td>
</tr>
<tr class="row-even"><td>-100 dBm</td>
<td>Puissance minimale reçue pour le WiFi</td>
</tr>
<tr class="row-odd"><td>-127 dBm</td>
<td>Puissance reçue typique des satellites GPS</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bruit-dans-le-domaine-frequentiel">
<h2>Bruit dans le Domaine Fréquentiel<a class="headerlink" href="#bruit-dans-le-domaine-frequentiel" title="Permalink to this headline">¶</a></h2>
<p>Dans le chapitre <a class="reference internal" href="../content-nl/frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a>, nous avons abordé la correspondance temps-fréquence de la transformée de Fourier, c’est-à-dire ce à quoi ressemble un certain signal dans le domaine temporel dans le domaine fréquentiel. Et bien, à quoi ressemble un bruit gaussien dans le domaine des fréquences?  Les graphiques suivants montrent un certain bruit simulé dans le domaine temporel (en haut) et un tracé de la densité spectrale de puissance (DSP) de ce bruit (en bas).  Ces graphiques sont tirés de GNU Radio.</p>
<a class="reference internal image-reference" href="../_images/noise_freq.png"><img alt="../_images/noise_freq.png" class="align-center" src="../_images/noise_freq.png" style="width: 599.5px; height: 506.00000000000006px;" /></a>
<p>Nous pouvons voir qu’il a à peu près la même apparence sur toutes les fréquences et qu’il est assez plat.  Il s’avère que le bruit gaussien dans le domaine temporel est également un bruit gaussien dans le domaine fréquentiel.  Alors pourquoi les deux graphiques ci-dessus ne sont-ils pas identiques?  C’est parce que le graphique du domaine fréquentiel montre l’amplitude de la FFT, donc il n’y aura que des nombres positifs. Il est important de noter qu’il utilise une échelle logarithmique, c’est-à-dire qu’il indique l’amplitude en dB.  Sinon, ces graphiques se ressembleraient.  Nous pouvons le prouver par nous-mêmes en générant un peu de bruit (dans le domaine temporel) dans Python, puis en prenant la FFT.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span> <span class="c1"># nombre d&#39;échantillons à simuler, choisissez le nombre que vous voulez</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span> <span class="c1"># ne regardez que les fréquences positives. rappelez-vous que // est juste un diviseur d&#39;entier</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Notez que la fonction randn() utilise par défaut la moyenne = 0 et la variance = 1.  Les deux graphiques ressembleront à ceci :</p>
<a class="reference internal image-reference" href="../_images/noise_python.png"><img alt="../_images/noise_python.png" class="align-center" src="../_images/noise_python.png" style="width: 374.0px; height: 252.0px;" /></a>
<p>Vous pouvez alors produire le DSP plate que nous avions dans GNU Radio en prenant le log et en faisant la moyenne de plusieurs d’entre eux. Le signal que nous avons généré et dont nous avons fait la FFT était un signal réel (par opposition à un signal complexe), et la FFT de tout signal réel aura des parties négatives et positives correspondantes, c’est pourquoi nous n’avons sauvegardé que la partie positive de la sortie FFT (la seconde moitié). Mais pourquoi n’avons-nous généré que du bruit “réel”, et comment les signaux complexes entrent-ils en jeu ?</p>
</div>
<div class="section" id="bruit-complexe">
<h2>Bruit Complexe<a class="headerlink" href="#bruit-complexe" title="Permalink to this headline">¶</a></h2>
<p>Le bruit “gaussien complexe” est celui que nous rencontrons lorsque nous avons un signal en bande de base; la puissance du bruit est répartie de manière égale entre les parties réelles et imaginaires.  Et surtout, les parties réelle et imaginaire sont indépendantes l’une de l’autre; connaître les valeurs de l’une ne vous donne pas les valeurs de l’autre.</p>
<p>Nous pouvons générer un bruit gaussien complexe en Python en utilisant :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
</pre></div>
</div>
<p>Mais attendez! L’équation ci-dessus ne génère pas la même “quantité” de bruit que <code class="code docutils literal notranslate"><span class="pre">np.random.randn()</span></code>, en termes de puissance (appelée puissance du bruit).  Nous pouvons trouver la puissance moyenne d’un signal (ou d’un bruit) de moyenne nulle en utilisant :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>où np.var() est la fonction de variance. Ici, la puissance de notre signal n est 2. Afin de générer un bruit complexe avec une “puissance unitaire”, c’est-à-dire une puissance de 1 (ce qui rend les choses plus pratiques), nous devons utiliser:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># AWGN de puissance unitaire</span>
</pre></div>
</div>
<p>Pour tracer un bruit complexe dans le domaine temporel, comme tout signal complexe, nous avons besoin de deux lignes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;real&#39;</span><span class="p">,</span><span class="s1">&#39;imag&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/noise3.png"><img alt="../_images/noise3.png" class="align-center" src="../_images/noise3.png" style="width: 798.4000000000001px; height: 296.8px;" /></a>
<p>Vous pouvez voir que les parties réelles et imaginaires sont complètement indépendantes.</p>
<p>À quoi ressemble un bruit gaussien complexe sur un graphique IQ? Rappelez-vous que le graphique IQ montre la partie réelle (axe horizontal) et la partie imaginaire (axe vertical), qui sont toutes deux des gaussiennes aléatoires indépendantes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/noise_iq.png"><img alt="../_images/noise_iq.png" class="align-center" src="../_images/noise_iq.png" style="width: 357.59999999999997px; height: 330.0px;" /></a>
<p>Il ressemble à ce que l’on pourrait attendre: une tache aléatoire centrée sur 0 + 0j, ou l’origine. Juste pour le plaisir, essayons d’ajouter du bruit à un signal QPSK pour voir à quoi ressemble le graphique IQ :</p>
<a class="reference internal image-reference" href="../_images/noisey_qpsk.png"><img alt="../_images/noisey_qpsk.png" class="align-center" src="../_images/noisey_qpsk.png" style="width: 721.1999999999999px; height: 342.0px;" /></a>
<p>Maintenant, que se passe-t-il quand le bruit est plus fort ?</p>
<a class="reference internal image-reference" href="../_images/noisey_qpsk2.png"><img alt="../_images/noisey_qpsk2.png" class="align-center" src="../_images/noisey_qpsk2.png" style="width: 643.5px; height: 229.0px;" /></a>
<p>Nous commençons à comprendre pourquoi la transmission de données sans fil n’est pas si simple. Nous voulons envoyer autant de bits par symbole que possible, mais si le bruit est trop élevé, nous aurons des bits erronés à la réception.</p>
</div>
<div class="section" id="awgn">
<h2>AWGN<a class="headerlink" href="#awgn" title="Permalink to this headline">¶</a></h2>
<p>Le bruit blanc additif gaussien ou AWGN (pour Additive White Gaussian Noise en anglais) est une abréviation que vous entendrez souvent dans le monde du DSP et de la SDR. Le GN, qui veut dire bruit gaussien, nous en avons déjà parlé. Additif signifie simplement que le bruit est ajouté à notre signal reçu.  Blanc, dans le domaine des fréquences, signifie que le spectre est plat sur toute la bande d’observation.  En pratique, il sera presque toujours blanc, ou approximativement blanc.  Dans ce manuel, nous utiliserons le bruit AWGN comme seule forme de bruit lorsque nous traiterons des liaisons de communication, des budgets de liaison, etc.  Le bruit non-AWGN tend à être un sujet de niche.</p>
</div>
<div class="section" id="snr-et-sinr">
<h2>SNR et SINR<a class="headerlink" href="#snr-et-sinr" title="Permalink to this headline">¶</a></h2>
<p>Le rapport signal à bruit (RSB) ou (SNR) (pour <em>signal to noise ratio</em> en anglais) est la façon dont nous allons mesurer les différences d’intensité entre le signal et le bruit. Il s’agit d’un rapport, donc sans unité. Le SNR est presque toujours exprimé en dB dans la pratique. Souvent, en simulation, nous codons de manière à ce que nos signaux soient d’une puissance unitaire (puissance = 1).  Ainsi, nous pouvons créer un rapport signal à bruit de 10 dB en produisant un bruit d’une puissance de -10 dB en ajustant la variance lorsque nous générons le bruit.</p>
<div class="math">
<p><img src="../_images/math/e3d034b776723e6c138a0ba0331cfd794b5fa4d8.svg" alt="\mathrm{SNR} = \frac{P_{signal}}{P_{noise}}"/></p>
</div><div class="math">
<p><img src="../_images/math/8f91e70a7813ff5dbe65bc819049807c241ca9ef.svg" alt="\mathrm{SNR_{dB}} = P_{signal\_dB} - P_{noise\_dB}"/></p>
</div><p>Si quelqu’un dit “SNR = 0 dB”, cela signifie que la puissance du signal et du bruit est la même. Un SNR positif signifie que notre signal est plus puissant que le bruit, tandis qu’un SNR négatif signifie que le bruit est plus puissant. La détection de signaux à un SNR négatif est généralement assez difficile.</p>
<p>Comme nous l’avons mentionné précédemment, la puissance d’un signal est égale à la variance du signal.  Nous pouvons donc représenter le SNR comme le rapport entre la variance du signal et la variance du bruit:</p>
<div class="math">
<p><img src="../_images/math/54d1172719b541c20b1866f9617d2b0665cd94eb.svg" alt="\mathrm{SNR} = \frac{P_{signal}}{P_{noise}} = \frac{\sigma^2_{signal}}{\sigma^2_{noise}}"/></p>
</div><p>Le rapport signal à interférence plus bruit (SINR pour <em>signal to interference and noise ration</em> en anglais) est essentiellement le même que le SNR, sauf que vous incluez l’interférence avec le bruit dans le dénominateur.</p>
<div class="math">
<p><img src="../_images/math/6a3ac8c945f1931a29da9c1cdd4b1506877c0088.svg" alt="\mathrm{SINR} = \frac{P_{signal}}{P_{interference} + P_{noise}}"/></p>
</div><p>La définition de l’interférence dépend de l’application/de la situation, mais il s’agit généralement d’un autre signal qui interfère avec le signal d’intérêt, qui le empiète sur lui dans le domaine fréquentiel, et/ou qui ne peut pas être filtré pour une raison quelconque.</p>
</div>
<div class="section" id="ressources-externes-en-anglais">
<h2>Ressources Externes (en anglais)<a class="headerlink" href="#ressources-externes-en-anglais" title="Permalink to this headline">¶</a></h2>
<p>Autres ressources sur l’AWGN, le SNR et la variance:</p>
<ol class="arabic simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Additive_white_Gaussian_noise" rel="noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Additive_white_Gaussian_noise</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Signal-to-noise_ratio" rel="noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Signal-to-noise_ratio</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Variance" rel="noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Variance</a></li>
</ol>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="usrp.html" title="Previous document"><span class="section-number">6. </span>USRP en Python</a>
        </li>
        <li>
          <a href="filters.html" title="Next document"><span class="section-number">8. </span>Filtres</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>