
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>13. Mise en Forme &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="14. Synchronisation" href="sync.html" />
    <link rel="prev" title="12. Evanouissement par Multi-Trajets" href="multipath_fading.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">13. Mise en Forme</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#interference-inter-symboles-isi">Interférence inter-symboles (ISI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filtre-adapte">Filtre Adapté</a></li>
<li class="toctree-l2"><a class="reference internal" href="#diviser-un-filtre-en-deux">Diviser un Filtre en Deux</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filtres-de-mise-en-forme-specifiques">Filtres de Mise en Forme Spécifiques</a></li>
<li class="toctree-l2"><a class="reference internal" href="#facteur-roll-off">Facteur Roll-Off</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercise-python">Exercise Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="multipath_fading.html" title="previous chapter"><span class="section-number">12. </span>Evanouissement par Multi-Trajets</a></li>
      <li>Next: <a href="sync.html" title="next chapter"><span class="section-number">14. </span>Synchronisation</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="multipath_fading.html" title="Previous document"><span class="section-number">12. </span>Evanouissement par Multi-Trajets</a>
        </li>
        <li>
          <a href="sync.html" title="Next document"><span class="section-number">14. </span>Synchronisation</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="mise-en-forme">
<span id="pulse-shaping-chapter"></span><h1><span class="section-number">13. </span>Mise en Forme<a class="headerlink" href="#mise-en-forme" title="Permalink to this headline">¶</a></h1>
<p>Ce chapitre traite de la mise en forme, des interférences inter-symboles, du filtrage adapté et des filtres à cosinus surélevé.  À la fin, nous utilisons Python pour ajouter la mise en forme aux symboles BPSK.  Vous pouvez considérer cette section comme la deuxième partie du chapitre sur les filtres, où nous approfondissons les mises en forme.</p>
<div class="section" id="interference-inter-symboles-isi">
<h2>Interférence inter-symboles (ISI)<a class="headerlink" href="#interference-inter-symboles-isi" title="Permalink to this headline">¶</a></h2>
<p>Dans le chapitre <a class="reference internal" href="filters.html#filters-chapter"><span class="std std-ref">Filtres</span></a>, nous avons appris que les symboles/impulsions en forme de blocs utilisent une quantité excessive de spectre, et que nous pouvons réduire considérablement la quantité de spectre utilisée en ” façonnant ” nos impulsions.  Cependant, vous ne pouvez pas utiliser n’importe quel filtre passe-bas, sinon vous risquez d’obtenir des interférences inter-symboles (ISI), où les symboles se mélangent et interfèrent les uns avec les autres.</p>
<p>Lorsque nous transmettons des symboles numériques, nous les transmettons dos à dos (au lieu d’attendre un certain temps entre eux).  Lorsque vous appliquez un filtre de mise en forme, il allonge l’impulsion dans le domaine temporel (afin de la condenser en fréquence), ce qui entraîne un chevauchement des symboles adjacents.  Ce chevauchement n’est pas un problème, à condition que votre filtre de mise en forme réponde à un critère: la somme de toutes les impulsions doit être égale à zéro à chaque multiple de notre période de symbole <img class="math" src="../_images/math/51acb7b4939189dc34f1c1f10cf8acb7aeb5218a.svg" alt="T"/>, sauf pour l’une des impulsions. L’idée est mieux comprise grâce à la visualisation suivante:</p>
<a class="reference external image-reference" href="../_images/pulse_train.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/pulse_train.svg" class="align-center" src="../_images/pulse_train.svg" /></a>
<p>Comme vous pouvez le voir, à chaque intervalle de <img class="math" src="../_images/math/51acb7b4939189dc34f1c1f10cf8acb7aeb5218a.svg" alt="T"/>, il y a un pic d’une impulsion tandis que le reste des impulsions sont à 0 (elles traversent l’axe des x). Lorsque le récepteur échantillonne le signal, il le fait au moment parfait (au pic des impulsions), ce qui signifie que c’est le seul point dans le temps qui compte. Il existe généralement un bloc de synchronisation des symboles au niveau du récepteur qui garantit que les symboles sont échantillonnés aux pics.</p>
</div>
<div class="section" id="filtre-adapte">
<h2>Filtre Adapté<a class="headerlink" href="#filtre-adapte" title="Permalink to this headline">¶</a></h2>
<p>Une astuce que nous utilisons dans les communications sans fil s’appelle le filtrage adapté. Pour comprendre le filtrage adapté, vous devez d’abord comprendre ces deux points:</p>
<ol class="arabic simple">
<li>Les impulsions dont nous avons parlé ci-dessus doivent seulement être parfaitement alignées <em>au niveau du récepteur</em> avant l’échantillonnage.  Jusqu’à ce moment-là, l’existence d’une ISI n’a pas vraiment d’importance, c’est-à-dire que les signaux peuvent être envoyés dans l’air avec une ISI et tout va bien.</li>
<li>Nous voulons un filtre passe-bas dans notre émetteur pour réduire la quantité de spectre que notre signal utilise. Mais le récepteur a également besoin d’un filtre passe-bas pour éliminer autant de bruit/interférences que possible à côté du signal. Par conséquent, nous avons un filtre passe-bas à l’émetteur (Tx) et un autre au récepteur (Rx), puis l’échantillonnage se produit après les deux filtres (et les effets du canal sans fil).</li>
</ol>
<p>Ce que nous faisons dans les communications modernes est de diviser le filtre de mise en forme des impulsions de manière égale entre la Tx et la Rx. Il n’est pas nécessaire qu’il s’agisse de filtres identiques, mais, en théorie, le filtre linéaire optimal pour maximiser le rapport signal/bruit en présence d’un bruit blanc gaussien (AWGN) est d’utiliser le même filtre à la fois à la Tx et à la Rx. Cette stratégie est appelée le concept de “filtre adapté”.</p>
<p>Une autre façon d’envisager les filtres appariés est que le récepteur corrèle le signal reçu avec le signal modèle connu. Le signal modèle est essentiellement constitué des impulsions envoyées par l’émetteur, indépendamment des déphasages/amplitudes qui leur sont appliqués. Rappelez-vous que le filtrage est effectué par convolution, qui est en fait une corrélation (en fait, elles sont mathématiquement identiques lorsque le modèle est symétrique). Ce processus de corrélation du signal reçu avec le modèle nous donne notre meilleure chance de récupérer ce qui a été envoyé, et c’est pourquoi il est théoriquement optimal. Par analogie, pensez à un système de reconnaissance d’images qui recherche des visages à l’aide d’un modèle de visage et d’une corrélation 2D :</p>
<a class="reference internal image-reference" href="../_images/face_template.png"><img alt="../_images/face_template.png" class="align-center" src="../_images/face_template.png" style="width: 451.49999999999994px; height: 175.7px;" /></a>
</div>
<div class="section" id="diviser-un-filtre-en-deux">
<h2>Diviser un Filtre en Deux<a class="headerlink" href="#diviser-un-filtre-en-deux" title="Permalink to this headline">¶</a></h2>
<p>Comment fait-on pour diviser un filtre en deux? La convolution est associative, ce qui signifie:</p>
<div class="math">
<p><img src="../_images/math/d373bec11aacfd8b57d59338616e3f13e472dfaf.svg" alt="(f * g) * h = f * (g * h)"/></p>
</div><p>Imaginons que <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> soit notre signal d’entrée, et que <img class="math" src="../_images/math/1566fe953af0c667c8521ad1ab00cf9841c047f7.svg" alt="g"/> et <img class="math" src="../_images/math/2475529ef4582ec92a0ef0ee2a266a22d98ba80d.svg" alt="h"/> soient des filtres.  Filtrer <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> avec <img class="math" src="../_images/math/1566fe953af0c667c8521ad1ab00cf9841c047f7.svg" alt="g"/>, puis <img class="math" src="../_images/math/2475529ef4582ec92a0ef0ee2a266a22d98ba80d.svg" alt="h"/> revient à filtrer avec un filtre égal à <img class="math" src="../_images/math/5973aeb55a9c71c8f90a8e7c22d47ed0c89d0575.svg" alt="g * h"/>.</p>
<p>Rappelons également que la convolution dans le domaine temporel est une multiplication dans le domaine fréquentiel:</p>
<div class="math">
<p><img src="../_images/math/8a8b0e64b50fef46c755559f57ed84fdade537e8.svg" alt="g(t) * h(t) \leftrightarrow G(f)H(f)"/></p>
</div><p>Pour diviser un filtre en deux, vous pouvez prendre la racine carrée de la réponse en fréquence.</p>
<div class="math">
<p><img src="../_images/math/7e7d6f2cb6946f45a7252e5229da937c2571556b.svg" alt="X(f) = X_H(f) X_H(f) \quad \mathrm{where} \quad X_H(f) = \sqrt{X(f)}"/></p>
</div></div>
<div class="section" id="filtres-de-mise-en-forme-specifiques">
<h2>Filtres de Mise en Forme Spécifiques<a class="headerlink" href="#filtres-de-mise-en-forme-specifiques" title="Permalink to this headline">¶</a></h2>
<p>Nous savons que nous voulons :</p>
<ol class="arabic simple">
<li>Concevoir un filtre qui réduit la largeur de bande de notre signal (pour utiliser moins de spectre) et toutes les impulsions sauf une doivent s’additionner à zéro à chaque intervalle de symbole.</li>
<li>Diviser le filtre en deux, en plaçant une moitié dans la Tx et l’autre dans la Rx.</li>
</ol>
<p>Examinons quelques filtres spécifiques qui sont couramment utilisés pour la mise en forme.</p>
<div class="section" id="filtre-cosinus-sureleve">
<h3>Filtre Cosinus Surélevé<a class="headerlink" href="#filtre-cosinus-sureleve" title="Permalink to this headline">¶</a></h3>
<p>Le filtre de mise en forme le plus populaire semble être le filtre “cosinus surélevé”.  C’est un bon filtre passe-bas pour limiter la largeur de bande que notre signal occupera, et il a aussi la propriété de ramener la somme à zéro à des intervalles de <img class="math" src="../_images/math/51acb7b4939189dc34f1c1f10cf8acb7aeb5218a.svg" alt="T"/>:</p>
<a class="reference external image-reference" href="../_images/raised_cosine.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/raised_cosine.svg" class="align-center" src="../_images/raised_cosine.svg" /></a>
<p>Notez que le graphique ci-dessus est dans le domaine temporel. Il représente la réponse impulsionnelle du filtre. Le paramètre <img class="math" src="../_images/math/fa5efa2bbe3175c3db8445abd969fbd3adb4df42.svg" alt="beta"/> est le seul paramètre du filtre à cosinus surélevé. Il détermine la vitesse à laquelle le filtre se réduit dans le domaine temporel, ce qui est inversement proportionnel à la vitesse à laquelle il se réduit en fréquence:</p>
<a class="reference external image-reference" href="../_images/raised_cosine_freq.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/raised_cosine_freq.svg" class="align-center" src="../_images/raised_cosine_freq.svg" /></a>
<p>La raison pour laquelle on l’appelle le filtre à cosinus surélevé est que le domaine de fréquence lorsque <img class="math" src="../_images/math/217d52f233550c7a726f575db158518ced478842.svg" alt="\beta = 1"/> est un demi-cycle d’une onde cosinusoïdale, surélevée pour s’asseoir sur l’axe des abscisses.</p>
<p>L’équation qui définit la réponse impulsionnelle du filtre à cosinus surélevé est la suivante:</p>
<div class="math">
<p><img src="../_images/math/3a84ae15bf1462dbad48595c4ce62d7c9e2f5f5a.svg" alt="h(t) = \frac{1}{T} \mathrm{sinc}\left( \frac{t}{T} \right) \frac{\cos\left(\frac{\pi\beta t}{T}\right)}{1 - \left( \frac{2 \beta t}{T}   \right)^2}"/></p>
</div><p>Vous trouverez de plus amples informations sur la fonction <img class="math" src="../_images/math/1dc463ee70728c7eab54120b1ff09530c775b139.svg" alt="\mathrm{sinc}()"/> <a class="reference external" href="https://fr.wikipedia.org/wiki/Sinus_cardinal" rel="noopener noreferrer" target="_blank">ici</a>.</p>
<p>Rappelez-vous: nous partageons ce filtre entre la Tx et la Rx de manière égale. Entrez dans le filtre racine cosinus surélevé (RRC en anglais pour <em>Root Raised Cosine</em>)!</p>
</div>
<div class="section" id="filtre-racine-cosinus-sureleve">
<h3>Filtre Racine Cosinus Surélevé<a class="headerlink" href="#filtre-racine-cosinus-sureleve" title="Permalink to this headline">¶</a></h3>
<p>Le filtre racine cosinus surélevé (RRC) est ce que nous mettons réellement en œuvre dans nos Tx et Rx. Combinés, ils forment un filtre normal à cosinus surélevé, comme nous l’avons vu. Comme la division d’un filtre en deux implique une racine carrée dans le domaine de la fréquence,la réponse impulsionnelle devient un peu désordonnée :</p>
<a class="reference internal image-reference" href="../_images/rrc_filter.png"><img alt="../_images/rrc_filter.png" class="align-center" src="../_images/rrc_filter.png" style="width: 494.2px; height: 181.29999999999998px;" /></a>
<p>Heureusement, il s’agit d’un filtre très utilisé et il existe de nombreuses implémentations, dont les suivantes <a class="reference external" href="https://commpy.readthedocs.io/en/latest/generated/commpy.filters.rrcosfilter.html" rel="noopener noreferrer" target="_blank">in Python</a>.</p>
</div>
<div class="section" id="autres-filtres-de-mise-en-forme-des-impulsions">
<h3>Autres Filtres de Mise en Forme des Impulsions<a class="headerlink" href="#autres-filtres-de-mise-en-forme-des-impulsions" title="Permalink to this headline">¶</a></h3>
<p>Parmi les autres filtres, citons le filtre gaussien, dont la réponse impulsionnelle ressemble à une fonction gaussienne. Il existe également un filtre sinc qui est équivalent au filtre à cosinus surélevé lorsque <img class="math" src="../_images/math/c272967e44cc0ec43f26404776c42e0bdac1824b.svg" alt="\beta = 0"/>.  Le filtre sinc est plutôt un filtre idéal, c’est-à-dire qu’il élimine les fréquences nécessaires sans grande région de transition.</p>
</div>
</div>
<div class="section" id="facteur-roll-off">
<h2>Facteur Roll-Off<a class="headerlink" href="#facteur-roll-off" title="Permalink to this headline">¶</a></h2>
<p>Examinons le paramètre <img class="math" src="../_images/math/3e8f4c4ef388379d55238ac81372a404ab28bcc2.svg" alt="\beta"/>.  Il s’agit d’un nombre compris entre 0 et 1, appelé facteur de “roll-off” ou parfois “excès de bande passante”.  Il détermine à quelle vitesse, dans le domaine temporel, le filtre se réduit à zéro.  Rappelez-vous que, pour être utilisée comme un filtre, la réponse impulsionnelle doit décroître jusqu’à zéro des deux côtés :</p>
<a class="reference external image-reference" href="../_images/rrc_rolloff.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/rrc_rolloff.svg" class="align-center" src="../_images/rrc_rolloff.svg" /></a>
<p>Plus le nombre de taps du filtre requis est élevé, plus <img class="math" src="../_images/math/3e8f4c4ef388379d55238ac81372a404ab28bcc2.svg" alt="\beta"/> est faible. Lorsque <img class="math" src="../_images/math/c272967e44cc0ec43f26404776c42e0bdac1824b.svg" alt="\beta = 0"/>, la réponse impulsionnelle n’atteint jamais complètement zéro, nous essayons donc d’obtenir <img class="math" src="../_images/math/3e8f4c4ef388379d55238ac81372a404ab28bcc2.svg" alt="\beta"/> aussi bas que possible sans causer d’autres problèmes. Plus le roll-off est faible, plus nous pouvons créer un signal compact en fréquence pour un débit de symboles donné, ce qui est toujours important.</p>
<p>Une équation courante utilisée pour calculer approximativement la largeur de bande, en Hz, pour un débit de symboles et un facteur Roll-Off donnés est la suivante :</p>
<div class="math">
<p><img src="../_images/math/b523dad49a1eeb78bddd0fb3c4fe2d5756d570f8.svg" alt="\mathrm{BW} = R_S(\beta + 1)"/></p>
</div><p><img class="math" src="../_images/math/4841008ae7293fefd4baf0734e5079d4dae06dea.svg" alt="R_S"/> est le débit de symboles en Hz. Pour les communications sans fil, nous aimons généralement un roll-off entre 0,2 et 0,5.  En règle générale, un signal numérique qui utilise le rythme symbole <img class="math" src="../_images/math/4841008ae7293fefd4baf0734e5079d4dae06dea.svg" alt="R_S"/> va occuper un peu plus de <img class="math" src="../_images/math/4841008ae7293fefd4baf0734e5079d4dae06dea.svg" alt="R_S"/> de spectre, y compris les parties positives et négatives du spectre. Une fois que nous convertissons et transmettons notre signal, les deux côtés sont certainement importants. Si nous transmettons une QPSK à 1 million de symboles par seconde (MSps), elle occupera environ 1,3 MHz. Le débit de données sera de 2 Mbps (rappelons que la QPSK utilise 2 bits par symbole), y compris les redondances du codage de canal et les en-têtes de trame.</p>
</div>
<div class="section" id="exercise-python">
<h2>Exercise Python<a class="headerlink" href="#exercise-python" title="Permalink to this headline">¶</a></h2>
<p>En guise d’exercice Python, filtrons et façonnons quelques impulsions. Nous utiliserons des symboles BPSK afin de faciliter la visualisation. Avant l’étape de mise en forme des impulsions, la BPSK consiste à transmettre des 1 ou des -1 avec la partie “Q” égale à zéro. Avec Q égal à zéro, nous pouvons tracer la partie I uniquement, et c’est plus facile à regarder.</p>
<p>Dans cette simulation, nous utiliserons 8 échantillons par symbole et, au lieu d’utiliser un signal de type onde carrée composé de 1 et de -1, nous utiliserons un train d’impulsions.  Lorsque vous faites passer une impulsion dans un filtre, la sortie est la réponse impulsionnelle (d’où le nom).  Par conséquent, si vous voulez une série d’impulsions, vous devez utiliser des impulsions entrecoupées de zéros pour éviter les impulsions carrées.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

<span class="n">num_symbols</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">sps</span> <span class="o">=</span> <span class="mi">8</span>

<span class="n">bits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_symbols</span><span class="p">)</span> <span class="c1"># les données a envoyées de 1&#39;s and 0&#39;s</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
<span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">:</span>
    <span class="n">pulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sps</span><span class="p">)</span>
    <span class="n">pulse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bit</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># définir la première valeur à 1 ou -1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">pulse</span><span class="p">))</span> <span class="c1"># ajouter les 8 échantillons au signal</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/pulse_shaping_python1.png"><img alt="../_images/pulse_shaping_python1.png" class="align-center" src="../_images/pulse_shaping_python1.png" style="width: 717.6px; height: 221.60000000000002px;" /></a>
<p>A ce stade, nos symboles sont toujours des 1 et des -1.  Ne vous laissez pas emporter par le fait que nous avons utilisé des impulsions. En fait, il est peut-être plus facile de <em>ne pas</em> visualiser la réponse des impulsions, mais plutôt d’y penser comme à un tableau :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bits</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">Symboles</span> <span class="n">BPSK</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">Application</span> <span class="n">de</span> <span class="mi">8</span> <span class="n">échantillons</span> <span class="n">par</span> <span class="n">symbole</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Nous allons créer un filtre en cosinus surélevé en utilisant un <img class="math" src="../_images/math/3e8f4c4ef388379d55238ac81372a404ab28bcc2.svg" alt="\beta"/> de 0.35, et nous allons le faire durer 101 taps pour donner au signal suffisamment de temps pour décroître jusqu’à zéro. Bien que l’équation du cosinus surélevé a besoin de la période du symbole et d’un vecteur temporel <img class="math" src="../_images/math/de24e9d9b4f685051e7f51c8931d4f7f53a37457.svg" alt="t"/>, nous pouvons supposer une période d’échantillon** de 1 seconde pour “normaliser” notre simulation. Cela signifie que notre période de symbole <img class="math" src="../_images/math/cf7ef5fe2f8fb6fbe8d12889ddeb4ffab5fad16d.svg" alt="Ts"/> est de 8 car nous avons 8 échantillons par symbole.  Notre vecteur temps sera donc une liste d’entiers. Avec la façon dont l’équation du cosinus surélevé fonctionne, nous voulons que <img class="math" src="../_images/math/21f8a502724f22f06d4ecccdb026486274a3150f.svg" alt="t=0"/> soit au centre.  Nous allons générer un vecteur temporel de 101 longueurs, commençant à -51 et finissant à +51.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Créer notre filtre à base de cosinus surélevé</span>
<span class="n">num_taps</span> <span class="o">=</span> <span class="mi">101</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.35</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">sps</span> <span class="c1"># Supposons que la fréquence d&#39;échantillonnage soit de 1 Hz, donc que la période d&#39;échantillonnage soit de 1, donc que la période du symbole soit de 8.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="c1"># n&#39;oubliez pas que le nombre final n&#39;est pas inclus</span>
<span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Ts</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/pulse_shaping_python2.png"><img alt="../_images/pulse_shaping_python2.png" class="align-center" src="../_images/pulse_shaping_python2.png" style="width: 418.40000000000003px; height: 285.6px;" /></a>
<p>Notez comment la sortie décroît définitivement vers zéro. Le fait que nous utilisions 8 échantillons par symbole détermine l’étroitesse de ce filtre et la vitesse à laquelle il décroît vers zéro. La réponse impulsionnelle ci-dessus ressemble à un filtre passe-bas typique, et il n’y a vraiment aucun moyen pour nous de savoir qu’il s’agit d’un filtre spécifique de mise en forme d’impulsion par rapport à n’importe quel autre filtre passe-bas.</p>
<p>Enfin, nous pouvons filtrer notre signal <img class="math" src="../_images/math/1907afd3cc2000b5af26022e2cf2c0ee820b13a7.svg" alt="x"/> et examiner le résultat. Ne vous focalisez pas trop sur l’introduction d’une boucle for dans le code fourni. Nous verrons pourquoi elle est là après le bloc de code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Filtrer notre signal, afin d&#39;appliquer la mise en forme</span>
<span class="n">x_shaped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_shaped</span><span class="p">,</span> <span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_symbols</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">sps</span><span class="o">+</span><span class="n">num_taps</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="n">sps</span><span class="o">+</span><span class="n">num_taps</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_shaped</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">sps</span><span class="o">+</span><span class="n">num_taps</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/pulse_shaping_python3.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/pulse_shaping_python3.svg" class="align-center" src="../_images/pulse_shaping_python3.svg" /></a>
<p>Le signal résultant est additionné à partir d’un grand nombre de nos réponses impulsionnelles, dont la moitié environ est d’abord multipliée par -1.  Cela peut sembler compliqué, mais nous allons le faire ensemble.</p>
<p>Tout d’abord, il y a des échantillons transitoires avant et après les données à cause du filtre et de la façon dont la convolution fonctionne. Ces échantillons supplémentaires sont inclus dans notre transmission, mais ils ne contiennent pas réellement de “pics” d’impulsions.</p>
<p>Deuxièmement, les lignes verticales ont été créées dans la boucle for pour des raisons de visualisation. Elles sont destinées à montrer où se trouvent les intervalles de <img class="math" src="../_images/math/cf7ef5fe2f8fb6fbe8d12889ddeb4ffab5fad16d.svg" alt="Ts"/>. Ces intervalles représentent l’endroit où ce signal sera échantillonné par le récepteur.  Observez que pour les intervalles <img class="math" src="../_images/math/cf7ef5fe2f8fb6fbe8d12889ddeb4ffab5fad16d.svg" alt="Ts"/> la courbe a la valeur exacte de 1.0 ou -1.0, ce qui en fait les points idéaux dans le temps pour l’échantillonnage.</p>
<p>Si nous devions convertir et transmettre ce signal, le récepteur devrait déterminer quand se trouvent les positions de <img class="math" src="../_images/math/cf7ef5fe2f8fb6fbe8d12889ddeb4ffab5fad16d.svg" alt="Ts"/>, par exemple, en utilisant un algorithme de synchronisation des symboles. De cette façon, le récepteur sait <em>exactement</em> quand il doit échantillonner pour obtenir les bonnes données. Si le récepteur échantillonne un peu trop tôt ou trop tard, il obtiendra des valeurs légèrement faussées à cause de l’ISI, et s’il se trompe, il obtiendra un tas de nombres bizarres.</p>
<p>Voici un exemple, créé à l’aide de GNU Radio, qui illustre ce à quoi ressemble le tracé IQ (ou constellation) lorsque nous échantillonnons au bon et au mauvais moment.  Les impulsions originales ont leurs valeurs binaires annotées.</p>
<a class="reference internal image-reference" href="../_images/symbol_sync1.png"><img alt="../_images/symbol_sync1.png" class="align-center" src="../_images/symbol_sync1.png" style="width: 562.5px; height: 241.5px;" /></a>
<p>Le graphique ci-dessous représente la position idéale dans le temps pour échantillonner, ainsi que le tracé du QI :</p>
<a class="reference internal image-reference" href="../_images/symbol_sync2.png"><img alt="../_images/symbol_sync2.png" class="align-center" src="../_images/symbol_sync2.png" style="width: 667.6px; height: 194.8px;" /></a>
<p>Comparez cela au pire temps d’échantillonnage. Remarquez les trois clusters dans la constellation. Nous échantillonnons directement entre chaque symbole; nos échantillons vont être très différents.</p>
<a class="reference internal image-reference" href="../_images/symbol_sync3.png"><img alt="../_images/symbol_sync3.png" class="align-center" src="../_images/symbol_sync3.png" style="width: 676.4000000000001px; height: 195.60000000000002px;" /></a>
<p>Voici un autre exemple d’un mauvais temps d’échantillonnage, quelque part entre notre cas idéal et le pire. Tenez compte des quatre groupes.  Avec un SNR élevé, nous pourrions nous en sortir avec cet intervalle de temps d’échantillonnage, mais ce n’est pas conseillé.</p>
<a class="reference internal image-reference" href="../_images/symbol_sync4.png"><img alt="../_images/symbol_sync4.png" class="align-center" src="../_images/symbol_sync4.png" style="width: 676.8000000000001px; height: 193.60000000000002px;" /></a>
<p>Rappelez-vous que nos valeurs Q n’apparaissent pas sur le tracé du domaine temporel parce qu’elles sont à peu près nulles, ce qui permet aux courbes IQ de s’étendre horizontalement seulement.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="multipath_fading.html" title="Previous document"><span class="section-number">12. </span>Evanouissement par Multi-Trajets</a>
        </li>
        <li>
          <a href="sync.html" title="Next document"><span class="section-number">14. </span>Synchronisation</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>