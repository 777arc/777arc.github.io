
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>6. USRP en Python &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7. le Bruit et les dB" href="noise.html" />
    <link rel="prev" title="5. PlutoSDR en Python" href="pluto.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. USRP en Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation-de-logiciels-pilotes">Installation de logiciels/pilotes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reception">Réception</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transmettre">Transmettre</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transmettre-et-recevoir-simultanement">Transmettre et recevoir simultanément</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sous-dispositif-canaux-et-antennes">Sous-dispositif, canaux et antennes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronisation-a-10-mhz-et-pps">Synchronisation à 10 MHz et PPS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="pluto.html" title="previous chapter"><span class="section-number">5. </span>PlutoSDR en Python</a></li>
      <li>Next: <a href="noise.html" title="next chapter"><span class="section-number">7. </span>le Bruit et les dB</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pluto.html" title="Previous document"><span class="section-number">5. </span>PlutoSDR en Python</a>
        </li>
        <li>
          <a href="noise.html" title="Next document"><span class="section-number">7. </span>le Bruit et les dB</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="usrp-en-python">
<span id="usrp-chapter"></span><h1><span class="section-number">6. </span>USRP en Python<a class="headerlink" href="#usrp-en-python" title="Permalink to this headline">¶</a></h1>
<a class="reference internal image-reference" href="../_images/usrp.png"><img alt="../_images/usrp.png" class="align-center" src="../_images/usrp.png" style="width: 428.5px; height: 212.0px;" /></a>
<p>Dans ce chapitre, nous apprenons à utiliser l’API Python UHD pour contrôler et recevoir/transmettre des signaux avec un <a class="reference external" href="https://www.ettus.com/" rel="noopener noreferrer" target="_blank">USRP</a> qui est une série de SDRs fabriqués par Ettus Research (qui fait maintenant partie de NI).  Nous discuterons de la transmission et de la réception sur l’USRP en Python, et nous plongerons dans les sujets spécifiques à l’USRP, notamment les args de streams ou flux, les sous-devices, les canaux, la synchronisation 10 MHz et PPS.</p>
<div class="section" id="installation-de-logiciels-pilotes">
<h2>Installation de logiciels/pilotes<a class="headerlink" href="#installation-de-logiciels-pilotes" title="Permalink to this headline">¶</a></h2>
<p>Bien que le code Python fourni dans ce manuel doive fonctionner sous Windows, Mac et Linux, nous ne fournirons que des instructions d’installation des pilotes/API spécifiques à Ubuntu 20 (bien que les instructions ci-dessous doivent fonctionner sur la plupart des distributions basées sur Debian).  Nous allons commencer par créer une VM Ubuntu 20 VirtualBox ; n’hésitez pas à sauter la partie VM si votre système d’exploitation est déjà prêt.</p>
<div class="section" id="configuration-d-une-vm-ubuntu-20">
<h3>Configuration d’une VM Ubuntu 20<a class="headerlink" href="#configuration-d-une-vm-ubuntu-20" title="Permalink to this headline">¶</a></h3>
<p>(Optionel)</p>
<ol class="arabic simple">
<li>Télécharger Ubuntu 20.04 Desktop .iso- <a class="reference external" href="https://ubuntu.com/download/desktop" rel="noopener noreferrer" target="_blank">https://ubuntu.com/download/desktop</a></li>
<li>Installez et ouvrez <a class="reference external" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener noreferrer" target="_blank">VirtualBox</a>.</li>
<li>Créez une nouvelle VM.  Pour la taille de la mémoire, je recommande d’utiliser 50% de la RAM de votre ordinateur.</li>
<li>Créez le disque dur virtuel, choisissez VDI, et allouez dynamiquement la taille.  15 Go devraient suffire. Si vous voulez être vraiment sûr, vous pouvez utiliser plus.</li>
<li>Démarrez la VM. Il vous demandera le support d’installation. Choisissez le fichier .iso du bureau Ubuntu 20.  Choisissez “install ubuntu”, utilisez les options par défaut, et une fenêtre pop-up vous avertira des changements que vous êtes sur le point d’effectuer. Cliquez sur continuer.  Choisissez le nom/mot de passe et attendez que la VM finisse de s’initialiser.  Après avoir terminé, la VM va redémarrer, mais vous devez éteindre la VM après le redémarrage.</li>
<li>Allez dans les paramètres de la VM (l’icône de l’engrenage).</li>
<li>Sous système &gt; processeur &gt; choisissez au moins 3 processeurs.  Si vous avez une carte vidéo réelle, alors dans affichage &gt; mémoire vidéo &gt; choisissez quelque chose de beaucoup plus élevé.</li>
<li>Démarrez votre VM.</li>
<li>Pour les USRP de type USB, vous devrez installer des ajouts invités VM. Dans la VM, allez dans Périphériques &gt; Insérer le CD Guest Additions &gt; cliquez sur run quand une boîte apparaît.  Suivez les instructions. Redémarrez la VM, puis essayez de transférer l’USRP à la VM, en supposant qu’elle apparaisse dans la liste sous Périphériques &gt; USB.  Le presse-papiers partagé peut être activé via Dispositifs &gt; Presse-papiers partagé &gt; Bidirectionnel.</li>
</ol>
</div>
<div class="section" id="installation-de-l-uhd-et-de-l-api-python">
<h3>Installation de l’UHD et de l’API Python<a class="headerlink" href="#installation-de-l-uhd-et-de-l-api-python" title="Permalink to this headline">¶</a></h3>
<p>Les commandes de terminal ci-dessous devraient compiler et installer la dernière version de UHD, y compris l’API Python :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>git<span class="w"> </span>cmake<span class="w"> </span>libboost-all-dev<span class="w"> </span>libusb-1.0-0-dev<span class="w"> </span>python3-docutils<span class="w"> </span>python3-mako<span class="w"> </span>python3-numpy<span class="w"> </span>python3-requests<span class="w"> </span>python3-ruamel.yaml<span class="w"> </span>python3-setuptools<span class="w"> </span>build-essential
<span class="nb">cd</span><span class="w"> </span>~
git<span class="w"> </span>clone<span class="w"> </span>https://github.com/EttusResearch/uhd.git
<span class="nb">cd</span><span class="w"> </span>uhd/host
mkdir<span class="w"> </span>build
<span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>-DENABLE_TESTS<span class="o">=</span>OFF<span class="w"> </span>-DENABLE_C_API<span class="o">=</span>OFF<span class="w"> </span>-DENABLE_MANUAL<span class="o">=</span>OFF<span class="w"> </span>..
make<span class="w"> </span>-j8
sudo<span class="w"> </span>make<span class="w"> </span>install
sudo<span class="w"> </span>ldconfig
</pre></div>
</div>
<p>Pour plus d’aide, voir la page officielle d’Ettus <a class="reference external" href="https://files.ettus.com/manual/page_build_guide.html" rel="noopener noreferrer" target="_blank">Building and Installing UHD from source</a>.  Notez qu’il existe également des méthodes d’installation des pilotes qui ne nécessitent pas de construire à partir des sources.</p>
</div>
<div class="section" id="test-des-pilotes-uhd-et-de-l-api-python">
<h3>Test des pilotes UHD et de l’API Python<a class="headerlink" href="#test-des-pilotes-uhd-et-de-l-api-python" title="Permalink to this headline">¶</a></h3>
<p>Ouvrez un nouveau terminal et tapez les commandes suivantes :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3
import<span class="w"> </span>uhd
<span class="nv">usrp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>uhd.usrp.MultiUSRP<span class="o">()</span>
<span class="nv">samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>usrp.recv_num_samps<span class="o">(</span><span class="m">10000</span>,<span class="w"> </span>100e6,<span class="w"> </span>1e6,<span class="w"> </span><span class="o">[</span><span class="m">0</span><span class="o">]</span>,<span class="w"> </span><span class="m">50</span><span class="o">)</span>
print<span class="o">(</span>samples<span class="o">[</span><span class="m">0</span>:10<span class="o">])</span>
</pre></div>
</div>
<p>Si aucune erreur ne se produit, vous êtes prêt à partir !</p>
</div>
<div class="section" id="analyse-comparative-de-la-vitesse-de-l-usrp-en-python">
<h3>Analyse comparative de la vitesse de l’USRP en Python<a class="headerlink" href="#analyse-comparative-de-la-vitesse-de-l-usrp-en-python" title="Permalink to this headline">¶</a></h3>
<p>(Optionel)</p>
<p>Si vous avez utilisé l’installation standard, la commande suivante devrait évaluer le taux de réception de votre USRP en utilisant l’API Python.  Si l’utilisation de 56e6 a causé beaucoup d’échantillons perdus ou de dépassements, essayez de diminuer le nombre.  Les échantillons perdus ne vont pas nécessairement ruiner quoi que ce soit, mais c’est un bon moyen de tester les inefficacités qui peuvent venir de l’utilisation d’une VM ou d’un ordinateur plus ancien, par exemple.  Si vous utilisez un B 2X0, un ordinateur assez moderne avec un port USB 3.0 fonctionnant correctement devrait réussir à faire 56 MHz sans échantillons perdus, surtout avec num_recv_frames réglé aussi haut.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python<span class="w"> </span>/usr/lib/uhd/examples/python/benchmark_rate.py<span class="w"> </span>--rx_rate<span class="w"> </span>56e6<span class="w"> </span>--args<span class="w"> </span><span class="s2">&quot;num_recv_frames=1000&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="reception">
<h2>Réception<a class="headerlink" href="#reception" title="Permalink to this headline">¶</a></h2>
<p>La réception d’échantillons à partir d’une USRP est extrêmement facile grâce à la fonction de commodité intégrée “recv_num_samps()”. Le code Python ci-dessous accorde l’USRP à 100MHz, utilise une fréquence d’échantillonnage de 1MHz et prélève 10 000 échantillons à partir de l’USRP, en utilisant un gain de réception de 50dB :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uhd</span>
<span class="n">usrp</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">usrp</span><span class="o">.</span><span class="n">MultiUSRP</span><span class="p">()</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">usrp</span><span class="o">.</span><span class="n">recv_num_samps</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mf">100e6</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">50</span><span class="p">)</span> <span class="c1"># unités: N, Hz, Hz, liste des canaux IDs, dB</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
<p>Le [0] indique à l’USRP d’utiliser son premier port d’entrée et de ne recevoir qu’un seul canal d’échantillons (pour qu’un B210 reçoive sur deux canaux à la fois, par exemple, vous pourriez utiliser [0, 1]).</p>
<p>Voici une astuce si vous essayez de recevoir à un taux élevé mais que vous obtenez des débordements (des O s’affichent dans votre console).  Au lieu de <code class="code docutils literal notranslate"><span class="pre">usrp</span> <span class="pre">=</span> <span class="pre">uhd.usrp.MultiUSRP()</span></code>, utilisez :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">usrp</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">usrp</span><span class="o">.</span><span class="n">MultiUSRP</span><span class="p">(</span><span class="s2">&quot;num_recv_frames=1000&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>qui rend le tampon de réception beaucoup plus grand (la valeur par défaut est de 32), ce qui permet de réduire les débordements.   La taille réelle du tampon en octets dépend de l’USRP et du type de connexion, mais le simple fait de définir <code class="code docutils literal notranslate"><span class="pre">num_recv_frames</span></code> à une valeur bien supérieure à 32 permet d’aider.</p>
<p>Pour des applications plus sérieuses, je recommande de ne pas utiliser la fonction recv_num_samps(), parce qu’elle cache une partie du comportement intéressant qui se passe sous le capot, et il y a une certaine configuration qui se produit à chaque appel que nous pourrions vouloir faire seulement une fois au début, par exemple, si nous voulons recevoir des échantillons indéfiniment.  Le code suivant a la même fonctionnalité que recv_num_samps(), en fait c’est presque exactement ce qui est appelé lorsque vous utilisez cette fonction, mais maintenant nous avons la possibilité de modifier le comportement :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uhd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">usrp</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">usrp</span><span class="o">.</span><span class="n">MultiUSRP</span><span class="p">()</span>

<span class="n">num_samps</span> <span class="o">=</span> <span class="mi">10000</span> <span class="c1"># nombre d&#39;échantillons reçus</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">100e6</span> <span class="c1"># Hz</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># Hz</span>
<span class="n">gain</span> <span class="o">=</span> <span class="mi">50</span> <span class="c1"># dB</span>

<span class="n">usrp</span><span class="o">.</span><span class="n">set_rx_rate</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">usrp</span><span class="o">.</span><span class="n">set_rx_freq</span><span class="p">(</span><span class="n">uhd</span><span class="o">.</span><span class="n">libpyuhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">tune_request</span><span class="p">(</span><span class="n">center_freq</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">usrp</span><span class="o">.</span><span class="n">set_rx_gain</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Configurer le flux et le tampon de réception</span>
<span class="n">st_args</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">usrp</span><span class="o">.</span><span class="n">StreamArgs</span><span class="p">(</span><span class="s2">&quot;fc32&quot;</span><span class="p">,</span> <span class="s2">&quot;sc16&quot;</span><span class="p">)</span>
<span class="n">st_args</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">RXMetadata</span><span class="p">()</span>
<span class="n">streamer</span> <span class="o">=</span> <span class="n">usrp</span><span class="o">.</span><span class="n">get_rx_stream</span><span class="p">(</span><span class="n">st_args</span><span class="p">)</span>
<span class="n">recv_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>

<span class="c1"># Démarrer le flux</span>
<span class="n">stream_cmd</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">StreamCMD</span><span class="p">(</span><span class="n">uhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">StreamMode</span><span class="o">.</span><span class="n">start_cont</span><span class="p">)</span>
<span class="n">stream_cmd</span><span class="o">.</span><span class="n">stream_now</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">streamer</span><span class="o">.</span><span class="n">issue_stream_cmd</span><span class="p">(</span><span class="n">stream_cmd</span><span class="p">)</span>

<span class="c1"># Recevoir des échantillons</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samps</span><span class="o">//</span><span class="mi">1000</span><span class="p">):</span>
    <span class="n">streamer</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">recv_buffer</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
    <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">1000</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">]</span> <span class="o">=</span> <span class="n">recv_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Arrêter le flux</span>
<span class="n">stream_cmd</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">StreamCMD</span><span class="p">(</span><span class="n">uhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">StreamMode</span><span class="o">.</span><span class="n">stop_cont</span><span class="p">)</span>
<span class="n">streamer</span><span class="o">.</span><span class="n">issue_stream_cmd</span><span class="p">(</span><span class="n">stream_cmd</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
<p>Avec num_samps fixé à 10 000 et le recv_buffer fixé à 1000, la boucle for sera exécutée 10 fois, c’est-à-dire qu’il y aura 10 appels à streamer.recv.  Notez que nous avons codé en dur le recv_buffer à 1000 mais vous pouvez trouver la valeur maximale autorisée en utilisant <code class="code docutils literal notranslate"><span class="pre">streamer.get_max_num_samps()</span></code>, qui se situe souvent autour de 3000 et quelques.  Notez également que recv_buffer doit être 2d car la même API est utilisée lors de la réception de plusieurs canaux à la fois, mais dans notre cas, nous n’avons reçu qu’un seul canal, donc recv_buffer[0] nous a donné le tableau 1D d’échantillons que nous voulions.  Pour l’instant, vous n’avez pas besoin d’en savoir trop sur la façon dont le flux démarre/arrête, mais sachez qu’il existe d’autres options que le mode “continu”, comme recevoir un nombre spécifique d’échantillons et faire en sorte que le flux s’arrête automatiquement.  Bien que nous ne traitions pas les métadonnées dans cet exemple de code, elles contiennent toutes les erreurs qui se produisent, entre autres choses, que vous pouvez vérifier en regardant metadata.error_code à chaque itération de la boucle, si vous le souhaitez (les erreurs ont tendance à apparaître également dans la console elle-même, en raison de l’UHD, donc ne vous sentez pas obligé de les vérifier dans votre code Python).</p>
<div class="section" id="gain-de-reception">
<h3>Gain de réception<a class="headerlink" href="#gain-de-reception" title="Permalink to this headline">¶</a></h3>
<p>La liste suivante montre la gamme de gain des différents USRP, ils vont tous de 0dB au nombre spécifié ci-dessous.  Notez que ce n’est pas du dBm, c’est essentiellement du dBm combiné à un décalage inconnu car ce ne sont pas des appareils calibrés.</p>
<ul class="simple">
<li>B200/B210/B200-mini: 76 dB</li>
<li>X310/N210 with WBX/SBX/UBX: 31.5 dB</li>
<li>X310 with TwinRX: 93 dB</li>
<li>E310/E312: 76 dB</li>
<li>N320/N321: 60 dB</li>
</ul>
<p>Vous pouvez également utiliser la commande <code class="code docutils literal notranslate"><span class="pre">uhd_usrp_probe</span></code> dans un terminal et dans la section RX Frontend il mentionnera la gamme de gain.</p>
<p>Pour spécifier le gain, vous pouvez utiliser la fonction normale set_rx_gain() qui prend la valeur du gain en dB, mais vous pouvez aussi utiliser set_normalized_rx_gain() qui prend une valeur de 0 à 1 et la convertit automatiquement dans la gamme de l’USRP que vous utilisez.  Ceci est pratique lorsqu’on crée une application qui supporte différents modèles d’USRP.  L’inconvénient de l’utilisation du gain normalisé est que vous n’avez plus vos unités en dB, donc si vous voulez augmenter votre gain de 10dB, par exemple, vous devez maintenant calculer la quantité.</p>
</div>
<div class="section" id="controle-automatique-du-gain">
<h3>Contrôle automatique du gain<a class="headerlink" href="#controle-automatique-du-gain" title="Permalink to this headline">¶</a></h3>
<p>Certains USRP, y compris les séries B200 et E310, prennent en charge la commande automatique de gain (AGC pour <em>automatic gain controller</em>  en anglais) qui ajuste automatiquement le gain de réception en fonction du niveau du signal reçu, afin d’essayer de “remplir” au mieux les bits de l’ADC.  L’AGC peut être activé en utilisant :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">usrp</span><span class="o">.</span><span class="n">set_rx_agc</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># 0 pour le canal 0, c&#39;est-à-dire le premier canal de l&#39;USRP</span>
</pre></div>
</div>
<p>Si vous avez une USRP qui n’implémente pas d’AGC, une exception sera levée lors de l’exécution de la ligne ci-dessus.  Avec l’AGC activé, le réglage du gain ne fera rien.</p>
<div class="section" id="arguments-relatifs-aux-flux">
<h4>Arguments relatifs aux flux<a class="headerlink" href="#arguments-relatifs-aux-flux" title="Permalink to this headline">¶</a></h4>
<p>Dans l’exemple complet ci-dessus, vous verrez la ligne <code class="code docutils literal notranslate"><span class="pre">st_args</span> <span class="pre">=</span> <span class="pre">uhd.usrp.StreamArgs(&quot;fc32&quot;,</span> <span class="pre">&quot;sc16&quot;)</span></code>.  Le premier argument est le format de données CPU, qui est le type de données des échantillons une fois qu’ils sont sur votre ordinateur hôte.  UHD supporte les types de données CPU suivants lors de l’utilisation de l’API Python :</p>
<table border="1" class="colwidths-given docutils align-default">
<colgroup>
<col width="23%" />
<col width="31%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stream Arg</th>
<th class="head">Numpy Data Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>fc64</td>
<td>np.complex128</td>
<td>Complex-valued double-precision data</td>
</tr>
<tr class="row-odd"><td>fc32</td>
<td>np.complex64</td>
<td>Complex-valued single-precision data</td>
</tr>
</tbody>
</table>
<p>Vous pouvez voir d’autres options dans la documentation de l’API UHD C++, mais elles n’ont jamais été implémentées dans l’API Python, du moins au moment de la rédaction de ce document.</p>
<p>Le deuxième argument est le format de données “over-the-wire”, c’est-à-dire le type de données lorsque les échantillons sont envoyés à l’hôte via USB/Ethernet/SFP.  Pour l’API Python, les options sont : “sc16”, “sc12” et “sc8”, l’option 12 bits n’étant prise en charge que par certains USRP.  Ce choix est important car la connexion entre l’USRP et l’ordinateur hôte est souvent le goulot d’étranglement, donc en passant de 16 bits à 8 bits, vous pouvez obtenir un taux plus élevé.  Rappelez-vous également que de nombreux USRP ont des ADC limités à 12 ou 14 bits, utiliser “sc16” ne signifie pas que l’ADC est de 16 bits.</p>
<p>Pour la partie canal du <code class="code docutils literal notranslate"><span class="pre">st_args</span></code>, voir la sous-section Sous-dispositif and Channels ci-dessous.</p>
</div>
</div>
</div>
<div class="section" id="transmettre">
<h2>Transmettre<a class="headerlink" href="#transmettre" title="Permalink to this headline">¶</a></h2>
<p>Similaire à la fonction pratique recv_num_samps(), UHD fournit la fonction send_waveform() pour transmettre un lot d’échantillons, un exemple est montré ci-dessous.  Si vous spécifiez une durée (en secondes) plus longue que le signal fourni, il sera simplement répété.  Il est utile de garder les valeurs des échantillons entre -1.0 et 1.0.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uhd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">usrp</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">usrp</span><span class="o">.</span><span class="n">MultiUSRP</span><span class="p">()</span>
<span class="n">samples</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="c1"># créer un signal aléatoire</span>
<span class="n">duration</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># secondes</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">915e6</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="n">gain</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1"># [dB] Commencez doucement puis montez en grade</span>
<span class="n">usrp</span><span class="o">.</span><span class="n">send_waveform</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">center_freq</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gain</span><span class="p">)</span>
</pre></div>
</div>
<p>Pour plus de détails sur la façon dont cette fonction pratique fonctionne sous le capot, voir le code source <a class="reference external" href="https://github.com/EttusResearch/uhd/blob/master/host/python/uhd/usrp/multi_usrp.py" rel="noopener noreferrer" target="_blank">ici</a>.</p>
<div class="section" id="gain-d-emission">
<h3>Gain d’émission<a class="headerlink" href="#gain-d-emission" title="Permalink to this headline">¶</a></h3>
<p>Comme pour la réception, la plage de gain d’émission varie en fonction du modèle USRP, allant de 0 dB au nombre spécifié ci-dessous :</p>
<ul class="simple">
<li>B200/B210/B200-mini: 90 dB</li>
<li>N210 with WBX: 25 dB</li>
<li>N210 with SBX or UBX: 31.5 dB</li>
<li>E310/E312: 90 dB</li>
<li>N320/N321: 60 dB</li>
</ul>
<p>Il existe également une fonction set_normalized_tx_gain() si vous souhaitez spécifier le gain d’émission en utilisant la plage 0 à 1.</p>
</div>
</div>
<div class="section" id="transmettre-et-recevoir-simultanement">
<h2>Transmettre et recevoir simultanément<a class="headerlink" href="#transmettre-et-recevoir-simultanement" title="Permalink to this headline">¶</a></h2>
<p>Si vous voulez émettre et recevoir en utilisant la même USRP en même temps, la clé est de le faire en utilisant plusieurs threads dans le même processus ; l’USRP ne peut pas couvrir plusieurs processus.  Par exemple, dans l’exemple C++ <a class="reference external" href="https://github.com/EttusResearch/uhd/blob/master/host/examples/txrx_loopback_to_file.cpp" rel="noopener noreferrer" target="_blank">txrx_loopback_to_file</a> un thread séparé est créé pour exécuter l’émetteur, et la réception est faite dans le thread principal.  Vous pouvez aussi simplement créer deux threads, un pour l’émission et un pour la réception, comme cela est fait dans l’exemple Python <a class="reference external" href="https://github.com/EttusResearch/uhd/blob/master/host/examples/python/benchmark_rate.py" rel="noopener noreferrer" target="_blank">benchmark_rate</a>.  Un exemple complet n’est pas montré ici, simplement parce que ce serait un exemple assez long et que le benchmark_rate.py d’Ettus peut toujours servir de point de départ à quelqu’un.</p>
</div>
<div class="section" id="sous-dispositif-canaux-et-antennes">
<h2>Sous-dispositif, canaux et antennes<a class="headerlink" href="#sous-dispositif-canaux-et-antennes" title="Permalink to this headline">¶</a></h2>
<p>Une source fréquente de confusion lors de l’utilisation des USRP est de savoir comment choisir le bon ID de sous-dispositif et de canal.  Vous avez peut-être remarqué que dans tous les exemples ci-dessus, nous avons utilisé le canal 0, et n’avons rien spécifié concernant le subdev.  Si vous utilisez un B210 et que vous voulez juste utiliser RF:B au lieu de RF:A, tout ce que vous avez à faire est de choisir le canal 1 au lieu de 0. Mais sur les USRP comme le X310 qui ont deux slots pour carte fille, vous devez dire à UHD si vous voulez utiliser le slot A ou B, et quel canal sur cette carte fille, par exemple :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">usrp</span><span class="o">.</span><span class="n">set_rx_subdev_spec</span><span class="p">(</span><span class="s2">&quot;B:0&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Si vous voulez utiliser le port TX/RX au lieu de RX2 (par défaut), c’est aussi simple que cela :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">usrp</span><span class="o">.</span><span class="n">set_rx_antenna</span><span class="p">(</span><span class="s1">&#39;TX/RX&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Réglez le canal 0 sur &#39;TX/RX&#39;.</span>
</pre></div>
</div>
<p>qui ne fait que contrôler un commutateur RF à bord de l’USRP, pour l’acheminer depuis l’autre connecteur SMA.</p>
<p>Pour recevoir ou émettre sur deux canaux à la fois, au lieu d’utiliser <code class="code docutils literal notranslate"><span class="pre">st_args.channels</span> <span class="pre">=</span> <span class="pre">[0]</span></code> vous fournissez une liste, telle que <code class="code docutils literal notranslate"><span class="pre">[0,1]</span></code>.  Le tampon de réception des échantillons devra être de taille (2, N) dans ce cas, au lieu de (1,N).  Rappelez-vous qu’avec la plupart des USRP, les deux canaux partagent un LO, donc vous ne pouvez pas indiquer différentes fréquences en même temps.</p>
</div>
<div class="section" id="synchronisation-a-10-mhz-et-pps">
<h2>Synchronisation à 10 MHz et PPS<a class="headerlink" href="#synchronisation-a-10-mhz-et-pps" title="Permalink to this headline">¶</a></h2>
<p>Un des énormes avantages de l’utilisation d’une USRP par rapport à d’autres SDR est leur capacité à se synchroniser à une source externe ou au <a class="reference external" href="https://www.ettus.com/all-products/gpsdo-tcxo-module/" rel="noopener noreferrer" target="_blank">GPSDO</a> embarqué.  Si vous avez connecté une source externe 10 MHz et PPS à votre USRP, vous voudrez vous assurer d’appeler ces deux lignes après avoir initialisé votre USRP :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">usrp</span><span class="o">.</span><span class="n">set_clock_source</span><span class="p">(</span><span class="s2">&quot;external&quot;</span><span class="p">)</span>
<span class="n">usrp</span><span class="o">.</span><span class="n">set_time_source</span><span class="p">(</span><span class="s2">&quot;external&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Si vous utilisez un GPSDO embarqué, vous utiliserez plutôt :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">usrp</span><span class="o">.</span><span class="n">set_clock_source</span><span class="p">(</span><span class="s2">&quot;gpsdo&quot;</span><span class="p">)</span>
<span class="n">usrp</span><span class="o">.</span><span class="n">set_time_source</span><span class="p">(</span><span class="s2">&quot;gpsdo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Du côté de la synchronisation en fréquence, il n’y a pas grand chose d’autre à faire ; la LO utilisée dans le mélangeur de l’USRP va maintenant être liée à la source externe ou à <a class="reference external" href="https://www.ettus.com/all-products/gpsdo-tcxo-module/" rel="noopener noreferrer" target="_blank">GPSDO</a>.  Mais du côté du timing, vous pouvez souhaiter commander à l’USRP de commencer à échantillonner exactement sur le PPS, par exemple.  Cela peut être fait avec le code suivant :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># copier l&#39;exemple de réception ci-dessus, tout jusqu&#39;à # Start Stream</span>

<span class="c1"># Attendez que 1 PPS se produise, puis réglez le temps au prochain PPS à 0.0</span>
<span class="n">time_at_last_pps</span> <span class="o">=</span> <span class="n">usrp</span><span class="o">.</span><span class="n">get_time_last_pps</span><span class="p">()</span><span class="o">.</span><span class="n">get_real_secs</span><span class="p">()</span>
<span class="k">while</span> <span class="n">time_at_last_pps</span> <span class="o">==</span> <span class="n">usrp</span><span class="o">.</span><span class="n">get_time_last_pps</span><span class="p">()</span><span class="o">.</span><span class="n">get_real_secs</span><span class="p">():</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1"># continuez à attendre jusqu&#39;à ce que ça arrive - si cette boucle while ne se termine jamais alors le signal PPS n&#39;est pas là.</span>
<span class="n">usrp</span><span class="o">.</span><span class="n">set_time_next_pps</span><span class="p">(</span><span class="n">uhd</span><span class="o">.</span><span class="n">libpyuhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">time_spec</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>

<span class="c1"># Planifie la réception des échantillons num_samps exactement 3 secondes après le dernier PPS.</span>
<span class="n">stream_cmd</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">StreamCMD</span><span class="p">(</span><span class="n">uhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">StreamMode</span><span class="o">.</span><span class="n">num_done</span><span class="p">)</span>
<span class="n">stream_cmd</span><span class="o">.</span><span class="n">num_samps</span> <span class="o">=</span> <span class="n">num_samps</span>
<span class="n">stream_cmd</span><span class="o">.</span><span class="n">stream_now</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">stream_cmd</span><span class="o">.</span><span class="n">time_spec</span> <span class="o">=</span> <span class="n">uhd</span><span class="o">.</span><span class="n">libpyuhd</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">time_spec</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span> <span class="c1"># définir l&#39;heure de début (essayez de modifier cela)</span>
<span class="n">streamer</span><span class="o">.</span><span class="n">issue_stream_cmd</span><span class="p">(</span><span class="n">stream_cmd</span><span class="p">)</span>

<span class="c1"># Recevoir des échantillons. recv() retournera des zéros, puis nos échantillons, puis encore des zéros, pour nous dire que c&#39;est terminé.</span>
<span class="n">waiting_to_start</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># garder la trace de l&#39;endroit où nous sommes dans le cycle (voir le commentaire ci-dessus)</span>
<span class="n">nsamps</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="k">while</span> <span class="n">nsamps</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">waiting_to_start</span><span class="p">:</span>
    <span class="n">nsamps</span> <span class="o">=</span> <span class="n">streamer</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">recv_buffer</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nsamps</span> <span class="ow">and</span> <span class="n">waiting_to_start</span><span class="p">:</span>
        <span class="n">waiting_to_start</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">nsamps</span><span class="p">:</span>
        <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">nsamps</span><span class="p">]</span> <span class="o">=</span> <span class="n">recv_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">nsamps</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="n">nsamps</span>
</pre></div>
</div>
<p>Si vous avez l’impression qu’il ne fonctionne pas, mais qu’il n’y a pas d’erreur, essayez de remplacer le chiffre 3.0 par un chiffre compris entre 1.0 et 5.0.  Vous pouvez également vérifier les métadonnées après l’appel à recv(), en vérifiant simplement <code class="code docutils literal notranslate"><span class="pre">if</span> <span class="pre">metadata.error_code</span> <span class="pre">!=</span> <span class="pre">uhd.types.RXMetadataErrorCode.none:</span></code>.</p>
<p>Pour des raisons de débogage, vous pouvez vérifier que le signal 10MHz apparaît sur l’USRP en vérifiant le retour de <code class="code docutils literal notranslate"><span class="pre">usrp.get_mboard_sensor(&quot;ref_locked&quot;,</span> <span class="pre">0)</span></code>.  Si le signal PPS n’apparaît pas, vous le saurez car la première boucle while du code ci-dessus ne se terminera jamais.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pluto.html" title="Previous document"><span class="section-number">5. </span>PlutoSDR en Python</a>
        </li>
        <li>
          <a href="noise.html" title="Next document"><span class="section-number">7. </span>le Bruit et les dB</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>