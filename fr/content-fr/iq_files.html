
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>11. Fichiers IQ et SigMF &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="12. Evanouissement par Multi-Trajets" href="multipath_fading.html" />
    <link rel="prev" title="10. Codage Canal" href="channel_coding.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script> 

<div id="topBanner" class="modal">
  <div class="modal-content">
    <div class="modal-header" style="background-color: rgb(255, 240, 129); text-align:center;">
      <i>-- Announcement from Marc --</i><br>I'm leading a new education-oriented open-source project called <a target="_blank" href="https://iqengine.org">IQEngine</a>!<br>It's a web-based SDR toolkit for analyzing, processing, and sharing RF recordings.  Checkout out our <a target="_blank" href="https://github.com/IQEngine/IQEngine">GitHub</a> and <a target="_blank" href="https://discord.gg/k7C8kp3b76">Discord</a>
      <div class="closeButton">
        <span style="font-size:30px; position:absolute; top:0px; right:5px; cursor:pointer; ">&times;</span>
      </div>
    </div>
  </div>
</div>

<script>
  var banner = document.getElementById("topBanner");
  var closeButton = document.getElementsByClassName("closeButton")[0];
  // Close banner if they have already clicked the close button in the past
  if (localStorage.getItem('pysdrvisited')){
    banner.style.display = "none";
  }
  // When they click the close button
  closeButton.onclick = function() {
    banner.style.display = "none";
    localStorage.setItem('pysdrvisited', true);
  }
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. Fichiers IQ et SigMF</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#fichiers-binaires">Fichiers binaires</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exemples-python">Exemples Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="#analyse-visuelle-d-un-fichier-rf">Analyse visuelle d’un fichier RF</a></li>
<li class="toctree-l2"><a class="reference internal" href="#valeurs-maximales-et-saturation">Valeurs maximales et saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sigmf-et-l-annotation-des-fichiers-iq">SigMF et l’annotation des fichiers IQ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="channel_coding.html" title="previous chapter"><span class="section-number">10. </span>Codage Canal</a></li>
      <li>Next: <a href="multipath_fading.html" title="next chapter"><span class="section-number">12. </span>Evanouissement par Multi-Trajets</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="channel_coding.html" title="Previous document"><span class="section-number">10. </span>Codage Canal</a>
        </li>
        <li>
          <a href="multipath_fading.html" title="Next document"><span class="section-number">12. </span>Evanouissement par Multi-Trajets</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="fichiers-iq-et-sigmf">
<span id="iq-files-chapter"></span><h1><span class="section-number">11. </span>Fichiers IQ et SigMF<a class="headerlink" href="#fichiers-iq-et-sigmf" title="Permalink to this headline">¶</a></h1>
<p>Dans tous nos exemples Python précédents, nous avons stocké les signaux sous forme de tableaux NumPy 1D de type “flottants complexes”.  Dans ce chapitre, nous apprenons comment les signaux peuvent être stockés dans un fichier, puis relus dans Python, et nous présentons la norme SigMF.  Le stockage des données de signaux dans un fichier est extrêmement utile ; vous pouvez souhaiter enregistrer un signal dans un fichier afin de l’analyser manuellement hors ligne, de le partager avec un collègue ou de constituer un ensemble de données complet.</p>
<div class="section" id="fichiers-binaires">
<h2>Fichiers binaires<a class="headerlink" href="#fichiers-binaires" title="Permalink to this headline">¶</a></h2>
<p>Rappelons qu’un signal numérique en bande de base est une séquence de nombres complexes.</p>
<p>Exemple : [0.123 + j0.512, 0.0312 + j0.4123, 0.1423 + j0.06512, …]</p>
<p>Ces nombres correspondent à [I+jQ, I+jQ, I+jQ, I+jQ, I+jQ, I+jQ, I+jQ, I+jQ, …].</p>
<p>Lorsque nous voulons enregistrer des nombres complexes dans un fichier, nous les enregistrons au format IQIQIQIQIQIQIQIQ.  C’est-à-dire que nous stockons un tas de flottants dans une rangée, et lorsque nous les relisons, nous devons les séparer en [I+jQ, I+jQ, …].</p>
<p>Bien qu’il soit possible de stocker les nombres complexes dans un fichier texte ou un fichier csv, nous préférons les enregistrer dans ce que l’on appelle un “fichier binaire” pour gagner de l’espace.  À des taux d’échantillonnage élevés, vos enregistrements de signaux peuvent facilement atteindre plusieurs Go, et nous voulons être aussi économes en mémoire que possible.  Si vous avez déjà ouvert un fichier dans un éditeur de texte et qu’il semblait incompréhensible comme la capture d’écran ci-dessous, il s’agissait probablement d’un fichier binaire.  Les fichiers binaires contiennent une série d’octets, et vous devez garder la trace du format vous-même.  Les fichiers binaires sont le moyen le plus efficace de stocker des données, en supposant que toutes les compressions possibles ont été effectuées.  Étant donné que nos signaux ressemblent généralement à une séquence aléatoire de flottants, nous n’essayons généralement pas de compresser les données.  Les fichiers binaires sont utilisés pour beaucoup d’autres choses, par exemple pour les programmes compilés (appelés “binaires”).  Lorsqu’ils sont utilisés pour enregistrer des signaux, nous les appelons “fichiers IQ” binaires, en utilisant l’extension de fichier .iq.</p>
<a class="reference internal image-reference" href="../_images/binary_file.png"><img alt="../_images/binary_file.png" class="align-center" src="../_images/binary_file.png" style="width: 840.0px; height: 301.7px;" /></a>
<p>En Python, le type complexe par défaut est np.complex128, qui utilise deux flottants de 64 bits par échantillon.  Mais en DSP/SDR, nous avons tendance à utiliser des flottants de 32 bits à la place, car les ADC de nos SDR n’ont pas <strong>tant</strong> de précision que cela pour justifier des flottants de 64 bits.  En Python, nous utiliserons <strong>np.complex64</strong>, qui utilise deux flottants de 32 bits.  Lorsque vous traitez simplement un signal en Python, cela n’a pas vraiment d’importance, mais lorsque vous allez enregistrer le tableau 1d dans un fichier, vous voulez d’abord vous assurer qu’il s’agit d’un tableau de np.complex64.</p>
</div>
<div class="section" id="exemples-python">
<h2>Exemples Python<a class="headerlink" href="#exemples-python" title="Permalink to this headline">¶</a></h2>
<p>En Python, et spécifiquement en numpy, nous utilisons la fonction <code class="code docutils literal notranslate"><span class="pre">tofile()</span></code> pour enregistrer un tableau numpy dans un fichier.  Voici un court exemple de création d’un simple signal BPSK plus du bruit et de son enregistrement dans un fichier dans le même répertoire que celui à partir duquel nous avons exécuté notre script :
.. code-block:: python</p>
<blockquote>
<div><p>import numpy as np
import matplotlib.pyplot as plt</p>
<p>num_symbols = 10000</p>
<p>x_symbols = np.random.randint(0, 2, num_symbols)*2-1 # -1 et 1
n = (np.random.randn(num_symbols) + 1j*np.random.randn(num_symbols))/np.sqrt(2) # AWGN de puissance unitaire
r = x_symbols + n * np.sqrt(0.01) # puissance du bruit de 0.01
print(r)
plt.plot(np.real(r), np.imag(r), ‘.’)
plt.grid(True)
plt.show()</p>
<p># Sauvegarder le fichier IQ
print(type(r[0])) # Vérifier le type de données.  Oups, c’est 128 et non 64 !
r = r.astype(np.complex64) # Convertir en64
print(type(r[0])) # Verifier que c’est bien 64
r.tofile(‘bpsk_in_noise.iq’) # Sauvegarder le fichier</p>
</div></blockquote>
<p>Maintenant, examinez les détails du fichier produit et vérifiez combien d’octets il contient.  Ce devrait être num_symbols * 8 parce que nous avons utilisé np.complex64, ce qui représente 8 octets par échantillon, 4 octets par flottant (2 flottants par échantillon).</p>
<p>En utilisant un nouveau script Python, nous pouvons lire ce fichier en utilisant <code class="code docutils literal notranslate"><span class="pre">np.fromfile()</span></code>, comme ceci :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;bpsk_in_noise.iq&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span> <span class="c1"># Lire dans le fichier.  Nous devons lui dire quel est son format</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

<span class="c1"># Tracez la constellation pour vous assurer qu&#39;elle est correcte</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Une grosse erreur est d’oublier d’indiquer à np.fromfile() le format du fichier. Les fichiers binaires n’incluent aucune information sur leur format.  Par défaut, np.fromfile() suppose qu’il lit un tableau de float64s.</p>
<p>La plupart des autres langages ont des méthodes pour lire les fichiers binaires, par exemple, dans MATLAB vous pouvez utiliser fread().  Pour l’analyse visuelle d’un fichier RF, voir la section ci-dessous.</p>
<p>Si vous vous retrouvez un jour à traiter des int16 (alias ints courts), ou tout autre type de données pour lequel numpy n’a pas d’équivalent complexe, vous serez obligé de lire les échantillons en tant que réels, même s’ils sont en fait complexes.  L’astuce est de les lire en tant que réels, mais ensuite de les entrelacer dans le format IQIQIQ… vous-même, quelques manières différentes de le faire sont montrées ci-dessous :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;iq_samples_as_int16.iq&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;iq_samples_as_int16.iq&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">/=</span> <span class="mi">32768</span> <span class="c1"># convertir en -1 en +1 (facultatif)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># convertir en IQIQIQ...</span>
</pre></div>
</div>
</div>
<div class="section" id="analyse-visuelle-d-un-fichier-rf">
<h2>Analyse visuelle d’un fichier RF<a class="headerlink" href="#analyse-visuelle-d-un-fichier-rf" title="Permalink to this headline">¶</a></h2>
<p>Bien que nous ayons appris à créer notre propre tracé de spectrogramme dans le chapitre <a class="reference internal" href="../content-nl/frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a>, rien ne vaut l’utilisation d’un logiciel déjà créé, et quand il s’agit d’analyser un long enregistrement RF, je recommande d’utiliser <a class="reference external" href="https://github.com/miek/inspectrum" rel="noopener noreferrer" target="_blank">inspectrum</a>.  Inspectrum est un outil graphique assez simple mais puissant pour balayer visuellement un fichier RF, avec un contrôle fin sur la gamme de cartes de couleurs et la taille de la FFT (quantité de zoom).  Vous pouvez maintenir la touche alt et utiliser la molette de défilement pour vous déplacer dans le temps.  Il dispose de curseurs optionnels pour mesurer le delta-temps entre deux rafales d’énergie, et la possibilité d’exporter une tranche du fichier RF dans un nouveau fichier.  Pour l’installation sur des plateformes basées sur Debian comme Ubuntu, utilisez les commandes suivantes :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo apt-get install qt5-default libfftw3-dev cmake pkg-config libliquid-dev
git clone https://github.com/miek/inspectrum.git
<span class="nb">cd</span> inspectrum
mkdir build
<span class="nb">cd</span> build
cmake ..
make
sudo make install
inspectrum
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/inspectrum.jpg"><img alt="../_images/inspectrum.jpg" class="align-center" src="../_images/inspectrum.jpg" style="width: 671.4px; height: 321.9px;" /></a>
</div>
<div class="section" id="valeurs-maximales-et-saturation">
<h2>Valeurs maximales et saturation<a class="headerlink" href="#valeurs-maximales-et-saturation" title="Permalink to this headline">¶</a></h2>
<p>Lorsque vous recevez des échantillons d’un SDR, il est important de connaître la valeur maximale de l’échantillon.  De nombreux SDR émettent les échantillons sous forme de flottants avec une valeur maximale de 1.0 et une valeur minimale de -1.0.  D’autres SDR vous donneront des échantillons sous forme d’entiers, généralement 16 bits, auquel cas les valeurs max et min seront +32767 et -32768 (sauf indication contraire), et vous pouvez choisir de diviser par 32 768 pour les convertir en flottants de -1,0 à 1,0.  La raison pour laquelle il faut connaître la valeur maximale de votre SDR est due à la saturation : lors de la réception d’un signal extrêmement fort (ou si le gain est réglé trop haut), le récepteur va “saturer” et il va tronquer les valeurs élevées à la valeur maximale de l’échantillon.  Les ADCs de nos SDRs ont un nombre limité de bits.  Lorsque vous créez une application SDR, il est sage de toujours vérifier la saturation, et lorsque cela se produit, vous devez l’indiquer d’une manière ou d’une autre.
Un signal qui est saturé aura l’air perturbé dans le domaine temporel, comme ceci :</p>
<a class="reference internal image-reference" href="../_images/saturated_time.png"><img alt="../_images/saturated_time.png" class="align-center" src="../_images/saturated_time.png" style="width: 715.1999999999999px; height: 505.2px;" /></a>
<p>En raison des changements soudains dans le domaine temporel, dus à la troncature, le domaine fréquentiel peut sembler étalé.  En d’autres termes, le domaine des fréquences comprendra de fausses caractéristiques, des caractéristiques résultant de la saturation et ne faisant pas réellement partie du signal, ce qui peut déconcerter les gens lors de l’analyse d’un signal.</p>
</div>
<div class="section" id="sigmf-et-l-annotation-des-fichiers-iq">
<h2>SigMF et l’annotation des fichiers IQ<a class="headerlink" href="#sigmf-et-l-annotation-des-fichiers-iq" title="Permalink to this headline">¶</a></h2>
<p>Comme le fichier IQ lui-même n’est associé à aucune métadonnée, il est courant d’avoir un second fichier contenant des informations sur le signal, portant le même nom de fichier mais une extension .txt ou autre.  Ces informations devraient au minimum inclure la fréquence d’échantillonnage utilisée pour collecter le signal, et la fréquence sur laquelle le SDR était accordé.  Après l’analyse du signal, le fichier de métadonnées peut inclure des informations sur les plages d’échantillonnage des caractéristiques intéressantes, telles que les rafales d’énergie.  L’index d’échantillon est simplement un nombre entier qui commence à 0 et s’incrémente à chaque échantillon complexe.  Si vous savez qu’il y a de l’énergie entre les échantillons 492342 et 528492, vous pouvez lire le fichier et extraire cette partie du tableau : <code class="code docutils literal notranslate"><span class="pre">samples[492342:528493]</span></code>.</p>
<p>Heureusement, il existe désormais une norme ouverte qui spécifie un format de métadonnées utilisé pour décrire les enregistrements de signaux, connue sous le nom de <a class="reference external" href="https://github.com/gnuradio/SigMF" rel="noopener noreferrer" target="_blank">SigMF</a>.  En utilisant une norme ouverte comme SigMF, de multiples parties peuvent partager des enregistrements RF plus facilement, et utiliser différents outils pour opérer sur les mêmes ensembles de données.  Cela permet également d’éviter le “bitrot” des ensembles de données RF où les détails de la capture sont perdus au fil du temps en raison de détails de l’enregistrement qui ne sont pas colocalisés avec l’enregistrement lui-même.
La façon la plus simple (et minimale) d’utiliser le standard SigMF pour décrire un fichier IQ binaire que vous avez créé est de renommer le fichier .iq en .sigmf-data et de créer un nouveau fichier avec le même nom mais l’extension .sigmf-meta, et de s’assurer que le champ datatype dans le méta-fichier correspond au format binaire de votre fichier de données.  Ce fichier méta est un fichier en texte clair rempli de json, vous pouvez donc simplement l’ouvrir avec un éditeur de texte et le remplir manuellement (nous verrons plus tard comment le faire de manière automatique).  Voici un exemple de fichier .sigmf-meta que vous pouvez utiliser comme modèle :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;global&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;core:datatype&quot;</span><span class="p">:</span> <span class="s2">&quot;cf32_le&quot;</span><span class="p">,</span>
        <span class="s2">&quot;core:sample_rate&quot;</span><span class="p">:</span> <span class="mi">1000000</span><span class="p">,</span>
        <span class="s2">&quot;core:hw&quot;</span><span class="p">:</span> <span class="s2">&quot;PlutoSDR with 915 MHz whip antenna&quot;</span><span class="p">,</span>
        <span class="s2">&quot;core:author&quot;</span><span class="p">:</span> <span class="s2">&quot;Art Vandelay&quot;</span><span class="p">,</span>
        <span class="s2">&quot;core:version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;captures&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">&quot;core:sample_start&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;core:frequency&quot;</span><span class="p">:</span> <span class="mi">915000000</span>
        <span class="p">}</span>
    <span class="p">],</span>
    <span class="s2">&quot;annotations&quot;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notez que <code class="code docutils literal notranslate"><span class="pre">core:cf32_le</span></code> indique que votre fichier .sigmf-data est de type IQIQIQIQ… avec des flottants 32 bits, c’est-à-dire np.complex64 comme nous l’avons utilisé précédemment.  Référez-vous aux spécifications pour les autres types de données disponibles, par exemple si vous avez des données réelles au lieu de complexes, ou si vous utilisez des entiers 16 bits au lieu de flottants pour gagner de la place.</p>
<p>En dehors du type de données, les lignes les plus importantes à remplir sont <code class="code docutils literal notranslate"><span class="pre">core:sample_rate</span></code> et <code class="code docutils literal notranslate"><span class="pre">core:frequency</span></code>.  Il est bon de saisir également des informations sur le matériel (<code class="code docutils literal notranslate"><span class="pre">core:hw</span></code>) utilisé pour capturer l’enregistrement, comme le type de SDR et l’antenne, ainsi qu’une description de ce que l’on sait du ou des signaux dans l’enregistrement dans <code class="code docutils literal notranslate"><span class="pre">core:description</span></code>.  Le <code class="code docutils literal notranslate"><span class="pre">core:version</span></code> est simplement la version de la norme SigMF utilisée au moment de la création du fichier de métadonnées.</p>
<p>Si vous capturez votre enregistrement RF à partir de Python, par exemple en utilisant l’API Python pour votre SDR, vous pouvez éviter de devoir créer manuellement ces fichiers de métadonnées en utilisant le paquetage SigMF Python.  Celui-ci peut être installé sur un système d’exploitation basé sur Ubuntu/Debian comme suit :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> ~
git clone https://github.com/gnuradio/SigMF.git
<span class="nb">cd</span> SigMF
sudo pip install .
</pre></div>
</div>
<p>Le code Python permettant d’écrire le fichier .sigmf-meta pour l’exemple du début de ce chapitre, où nous avons enregistré bpsk_in_noise.iq, est présenté ci-dessous :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">from</span> <span class="nn">sigmf</span> <span class="kn">import</span> <span class="n">SigMFFile</span>

<span class="c1"># &lt;code pour exemple&gt;</span>

<span class="c1"># r.tofile(&#39;bpsk_in_noise.iq&#39;)</span>
<span class="n">r</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s1">&#39;bpsk_in_noise.sigmf-data&#39;</span><span class="p">)</span> <span class="c1"># remplacer la ligne ci-dessus par celle-ci</span>

<span class="c1"># crérer les metadata</span>
<span class="n">meta</span> <span class="o">=</span> <span class="n">SigMFFile</span><span class="p">(</span>
    <span class="n">data_file</span><span class="o">=</span><span class="s1">&#39;example.sigmf-data&#39;</span><span class="p">,</span> <span class="c1"># extension optionalle</span>
    <span class="n">global_info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">DATATYPE_KEY</span><span class="p">:</span> <span class="s1">&#39;cf32_le&#39;</span><span class="p">,</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">SAMPLE_RATE_KEY</span><span class="p">:</span> <span class="mi">8000000</span><span class="p">,</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">AUTHOR_KEY</span><span class="p">:</span> <span class="s1">&#39;Your name and/or email&#39;</span><span class="p">,</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">DESCRIPTION_KEY</span><span class="p">:</span> <span class="s1">&#39;Simulation of BPSK with noise&#39;</span><span class="p">,</span>
        <span class="n">SigMFFile</span><span class="o">.</span><span class="n">VERSION_KEY</span><span class="p">:</span> <span class="n">sigmf</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1"># créer une clé de capture à l&#39;index temporel 0</span>
<span class="n">meta</span><span class="o">.</span><span class="n">add_capture</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="p">{</span>
    <span class="n">SigMFFile</span><span class="o">.</span><span class="n">FREQUENCY_KEY</span><span class="p">:</span> <span class="mi">915000000</span><span class="p">,</span>
    <span class="n">SigMFFile</span><span class="o">.</span><span class="n">DATETIME_KEY</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span>
<span class="p">})</span>

<span class="c1"># vérifier les erreurs et écrire sur le disque</span>
<span class="k">assert</span> <span class="n">meta</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>
<span class="n">meta</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s1">&#39;bpsk_in_noise.sigmf-meta&#39;</span><span class="p">)</span> <span class="c1"># extension optionalle</span>
</pre></div>
</div>
<p>Remplacez simplement <code class="code docutils literal notranslate"><span class="pre">8000000</span></code> et <code class="code docutils literal notranslate"><span class="pre">915000000</span></code> par les variables que vous avez utilisées pour stocker respectivement la fréquence d’échantillonnage et la fréquence centrale.</p>
<p>Pour lire un enregistrement SigMF dans Python, utilisez le code suivant.  Dans cet exemple, les deux fichiers SigMF doivent être nommés <code class="code docutils literal notranslate"><span class="pre">bpsk_in_noise.sigmf-meta</span></code> et <code class="code docutils literal notranslate"><span class="pre">bpsk_in_noise.sigmf-data</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sigmf</span> <span class="kn">import</span> <span class="n">SigMFFile</span><span class="p">,</span> <span class="n">sigmffile</span>

<span class="c1"># charger les données</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;bpsk_in_noise&#39;</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">sigmffile</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">read_samples</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span> <span class="c1"># examinons les 10 premiers échantillons</span>

<span class="c1"># Obtenir certaines métadonnées et toutes les annotations</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">get_global_field</span><span class="p">(</span><span class="n">SigMFFile</span><span class="o">.</span><span class="n">SAMPLE_RATE_KEY</span><span class="p">)</span>
<span class="n">sample_count</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">sample_count</span>
<span class="n">signal_duration</span> <span class="o">=</span> <span class="n">sample_count</span> <span class="o">/</span> <span class="n">sample_rate</span>
</pre></div>
</div>
<p>Pour plus de détails, voir la référence <a class="reference external" href="https://github.com/gnuradio/SigMF" rel="noopener noreferrer" target="_blank">the SigMF documentation</a>.</p>
<p>Un petit bonus pour ceux qui ont lu jusqu’ici: le logo SigMF est en fait stocké comme un enregistrement SigMF lui-même, et quand le signal est tracé comme une constellation (IQ plot) dans le temps, il produit l’animation suivante :</p>
<a class="reference internal image-reference" href="../_images/sigmf_logo.gif"><img alt="../_images/sigmf_logo.gif" class="align-center" src="../_images/sigmf_logo.gif" style="width: 450.0px; height: 428.0px;" /></a>
<p>Le code Python utilisé pour lire le fichier du logo (situé <a class="reference external" href="https://github.com/gnuradio/SigMF/tree/master/logo" rel="noopener noreferrer" target="_blank">ici</a>) et produire le gif animé ci-dessus est présenté ci-dessous, pour les curieux :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">imageio</span>
<span class="kn">from</span> <span class="nn">sigmf</span> <span class="kn">import</span> <span class="n">SigMFFile</span><span class="p">,</span> <span class="n">sigmffile</span>

<span class="c1"># charger les données</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;sigmf_logo&#39;</span> <span class="c1"># supposez qu&#39;il se trouve dans le même répertoire que ce script</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">sigmffile</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">read_samples</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="c1"># Ajoutez des zéros à la fin pour que ce soit clair lorsque l&#39;animation se répète.</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">50000</span><span class="p">)))</span>

<span class="n">sample_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">samples_per_frame</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">num_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_count</span><span class="o">/</span><span class="n">samples_per_frame</span><span class="p">)</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_frames</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;out of&quot;</span><span class="p">,</span> <span class="n">num_frames</span><span class="p">)</span>
    <span class="c1"># tracer le cadre</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">samples_frame</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">samples_per_frame</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">samples_per_frame</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">samples_frame</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">samples_frame</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;cyan&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.35</span><span class="p">,</span><span class="o">-</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.35</span><span class="p">])</span> <span class="c1"># garder les axes existants</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;black&#39;</span><span class="p">)</span> <span class="c1"># couleur d&#39;arrière plan</span>

    <span class="c1"># Enregister la figure dans un fichier</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;/tmp/sigmf_logo_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="n">filenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="c1"># Créer un gif animé</span>
<span class="n">images</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
    <span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imageio</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
<span class="n">imageio</span><span class="o">.</span><span class="n">mimsave</span><span class="p">(</span><span class="s1">&#39;/tmp/sigmf_logo.gif&#39;</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="channel_coding.html" title="Previous document"><span class="section-number">10. </span>Codage Canal</a>
        </li>
        <li>
          <a href="multipath_fading.html" title="Next document"><span class="section-number">12. </span>Evanouissement par Multi-Trajets</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>