
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2. Domaine fréquentiel &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. échantillonnage IQ" href="sampling.html" />
    <link rel="prev" title="1. Introduction" href="intro.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/nl/index-nl.html">Dutch</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Domaine fréquentiel</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#series-de-fourier">Séries de Fourier</a></li>
<li class="toctree-l2"><a class="reference internal" href="#la-dualite-temps-frequence">La dualité temps-fréquence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transformee-de-fourier">Transformée de Fourier</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proprietes-temps-frequence">Propriétés temps-fréquence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transformee-de-fourier-rapide-fft">Transformée de Fourier rapide (FFT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#frequences-negatives">Fréquences négatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="#l-ordre-dans-le-domaine-temporel-n-a-pas-d-importance">L’ordre dans le domaine temporel n’a pas d’importance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fft-en-python">FFT en Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fenetrage">Fenêtrage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#taille-de-la-fft">Taille de la FFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spectrogramme">Spectrogramme</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="intro.html" title="previous chapter"><span class="section-number">1. </span>Introduction</a></li>
      <li>Next: <a href="sampling.html" title="next chapter"><span class="section-number">3. </span>échantillonnage IQ</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="intro.html" title="Previous document"><span class="section-number">1. </span>Introduction</a>
        </li>
        <li>
          <a href="sampling.html" title="Next document"><span class="section-number">3. </span>échantillonnage IQ</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="domaine-frequentiel">
<span id="freq-domain-chapter"></span><h1><span class="section-number">2. </span>Domaine fréquentiel<a class="headerlink" href="#domaine-frequentiel" title="Permalink to this headline">¶</a></h1>
<p>Ce chapitre présente le domaine fréquentiel d’un signal et couvre les séries de Fourier, la transformée de Fourier, ses propriétés, la FFT, le fenêtrage et les spectrogrammes, à l’aide d’exemples Python.</p>
<p>L’une des conséquences indirectes les plus intéressantes de l’apprentissage du DSP (en anglais <em>digital signal processing</em> pour <em>traitements numériques du signal</em> en français) et des communications sans fil est que vous apprendrez également à raisonner dans le domaine fréquentiel.  L’expérience de la plupart des gens en matière de <em>manipulation</em> dans le domaine fréquenciel se limite à l’ajustement de boutons de réglage des basses, des médiums et des aigus sur le système audio d’une voiture.  L’expérience de la plupart des gens en matière de visualisation d’un signal dans le domaine fréquenciel se limite à voir un égaliseur audio, comme cette animation :</p>
<img alt="../_images/audio_equalizer.webp" class="align-center" src="../_images/audio_equalizer.webp" />
<p>À la fin de ce chapitre, vous comprendrez ce que signifie réellement le domaine fréquentiel, comment basculer entre le domaine temporel et fréquentiel (et ce qui se passe lorsque nous le faisons), ainsi que certains principes intéressants que nous utiliserons tout au long de nos études de DSP et de SDR (<em>Software-Defined Radio</em> en anglaie pour <em>radio logicielle</em> en français). À la fin de ce manuel, vous deviendrez un maître dans l’art de manipuler un signal dans le domaine fréquentiel, c’est garanti!</p>
<p>Tout d’abord, pourquoi aimons-nous regarder les signaux dans le domaine des fréquences?  Voici deux exemples de signaux, présentés à la fois dans le domaine temporel et dans le domaine fréquentiel:</p>
<a class="reference internal image-reference" href="../_images/time_and_freq_domain_example_signals.png"><img alt="../_images/time_and_freq_domain_example_signals.png" class="align-center" src="../_images/time_and_freq_domain_example_signals.png" style="width: 576.0px; height: 238.8px;" /></a>
<p>Comme vous pouvez le voir, dans le domaine temporel, ils ressemblent tous les deux à du bruit, mais dans le domaine fréquentiel, nous pouvons voir des caractéristiques différentes.  Dans le domaine temporel, tout se trouve sous sa forme <em>naturelle</em>; lorsque nous échantillonnons des signaux, nous le faisons dans le domaine temporel, car vous ne pouvez pas échantillonner <em>directement</em> un signal dans le domaine fréquentiel. Et pourtant, les choses les plus intéressantes se passent généralement dans le domaine des fréquences.</p>
<div class="section" id="series-de-fourier">
<h2>Séries de Fourier<a class="headerlink" href="#series-de-fourier" title="Permalink to this headline">¶</a></h2>
<p>Les bases du domaine fréquentiel commencent par comprendre que tout signal peut être représenté par la somme d’ondes sinusoïdales. Lorsque nous décomposons un signal en ses ondes sinusoïdales, on obtient ce qu’on appelle une série de Fourier. Voici un exemple de signal composé de seulement deux ondes sinusoïdales:</p>
<a class="reference external image-reference" href="../_images/summing_sinusoids.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/summing_sinusoids.svg" class="align-center" src="../_images/summing_sinusoids.svg" /></a>
<p>Voici un autre exemple: la courbe rouge ci-dessous reproduit approximativement une onde en dents de scie en additionnant jusqu’à 10 ondes sinusoïdales. On peut observer qu’il ne s’agit pas d’une reconstruction parfaite - il faudrait en fait sommer un nombre infini d’ondes sinusoïdales pour reproduire le signal en dents de scie à cause des transitions abruptes:</p>
<a class="reference internal image-reference" href="../_images/fourier_series_triangle.gif"><img alt="../_images/fourier_series_triangle.gif" class="align-center" src="../_images/fourier_series_triangle.gif" style="width: 561.4px; height: 180.6px;" /></a>
<p>Certains signaux nécessitent ainsi de sommer plus d’ondes sinusoïdales que d’autres, alors que d’autres ont besoin d’un nombre infini, bien qu’ils puissent toujours être approximés avec un nombre limité.  Voici un autre exemple de décomposition d’un signal en une série d’ondes sinusoïdales :</p>
<a class="reference internal image-reference" href="../_images/fourier_series_arbitrary_function.gif"><img alt="../_images/fourier_series_arbitrary_function.gif" class="align-center" src="../_images/fourier_series_arbitrary_function.gif" style="width: 561.4px; height: 180.6px;" /></a>
<p>Pour comprendre comment décomposer un signal en somme de sinusoïdes, nous devons d’abord définir les trois paramètres d’une onde sinusoïdale :</p>
<ol class="arabic simple">
<li>Amplitude</li>
<li>Fréquence</li>
<li>Phase</li>
</ol>
<p><strong>L’amplitude</strong> indique la “force” de l’onde, tandis que la <strong>fréquence</strong> est le nombre d’<em>ondulations</em> par seconde. <strong>La phase</strong> est utilisée pour représenter la façon dont l’onde sinusoïdale est décalée dans le temps, de 0 à 360 degrés (ou de 0 à <img class="math" src="../_images/math/bf50b56b21d67ede45fc1ec5b8213871824fe365.svg" alt="2\pi"/>), mais elle doit être relative à quelque chose pour avoir un sens, comme deux signaux de même fréquence déphasés de 30 degrés l’un par rapport à l’autre.</p>
<a class="reference external image-reference" href="../_images/amplitude_phase_period.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/amplitude_phase_period.svg" class="align-center" src="../_images/amplitude_phase_period.svg" /></a>
<p>À ce stade, vous avez peut-être compris qu’un “signal” n’est essentiellement qu’une fonction, généralement représentée “dans le temps” (c’est-à-dire sur l’axe des x). Un autre attribut facile à retenir est la <strong>période</strong>, qui est l’inverse de la <strong>fréquence</strong>. La <strong>période</strong> d’une sinusoïde est le temps, en secondes, que met l’onde pour terminer un cycle.  Ainsi, l’unité de fréquence est 1/seconde, ou Hz.</p>
<p>Lorsque nous décomposons un signal en une somme d’ondes sinusoïdales, chacune d’entre elles aura une certaine <strong>amplitude</strong>, <strong>phase</strong> et <strong>fréquence</strong>.  L’<strong>amplitude</strong> de chaque onde sinusoïdale nous indique l’intensité de la <strong>fréquence</strong> présente dans le signal d’origine.  Ne vous préoccupez pas trop de la <strong>phase</strong> pour l’instant, si ce n’est pour réaliser que la seule différence entre sin() et cos() est un déphasage (décalage temporel).</p>
<p>Il est plus important de comprendre le concept sous-jacent que les équations réelles pour résoudre une série de Fourier, mais pour ceux qui sont intéressés par les équations, je vous renvoie à l’explication concise de Wolfram : <a class="reference external" href="https://mathworld.wolfram.com/FourierSeries.html" rel="noopener noreferrer" target="_blank">https://mathworld.wolfram.com/FourierSeries.html</a>.</p>
</div>
<div class="section" id="la-dualite-temps-frequence">
<h2>La dualité temps-fréquence<a class="headerlink" href="#la-dualite-temps-frequence" title="Permalink to this headline">¶</a></h2>
<p>Nous avons expliqué que les signaux peuvent être représentés comme des ondes sinusoïdales, chacune ayant plusieurs paramètres. Maintenant, voyons comment tracer ces signaux dans le domaine des fréquences. Là où la représentation dans le domaine temporel montre comment un signal évolue dans le temps, le domaine fréquentiel, lui, montre la proportion du signal qui se trouve dans telle ou telle fréquence. De ce fait, l’axe des x ne sera plus le temps mais la fréquence. Nous pouvons représenter un signal donné à la fois en temps <em>et</em> en fréquence. Prenons quelques exemples simples pour commencer.</p>
<p>Voici à quoi ressemble une onde sinusoïdale, de fréquence f, dans le domaine temporel et fréquentiel:</p>
<a class="reference internal image-reference" href="../_images/sine-wave.png"><img alt="../_images/sine-wave.png" class="align-center" src="../_images/sine-wave.png" style="width: 407.4px; height: 171.5px;" /></a>
<p>Le domaine temporel devrait vous sembler très familier. Il s’agit tout simplement d’une fonction oscillante. Ne vous souciez pas de savoir à quel moment du cycle elle commence à l’instant t=0 ou combien de temps elle dure.  Ce qu’il faut retenir, c’est que le signal a une <strong>unique fréquence</strong>, c’est pourquoi nous voyons un seul pic dans le domaine des fréquences.  Quelle que soit la fréquence à laquelle cette onde sinusoïdale oscille, c’est là que nous verrons le pic dans le domaine des fréquences.  Le nom mathématique d’un pic de ce type est appelé “impulsion”.</p>
<p>Maintenant, et si nous avions une impulsion dans le domaine temporel ?  Imaginez l’enregistrement sonore d’une personne tapant dans ses mains ou frappant un clou avec un marteau.  Cette paire temps-fréquence est un peu moins intuitive.</p>
<a class="reference internal image-reference" href="../_images/impulse.png"><img alt="../_images/impulse.png" class="align-center" src="../_images/impulse.png" style="width: 409.5px; height: 161.0px;" /></a>
<p>Comme nous pouvons le voir, un pic/impulsion dans le domaine temporel est un plat dans le domaine fréquentiel; il contient théoriquement toutes les fréquences. Il n’existe pas d’impulsion théoriquement parfaite, car elle devrait être infiniment courte dans le domaine temporel. Comme pour l’onde sinusoïdale, l’endroit où l’impulsion se produit dans le domaine temporel n’a pas d’importance. Ce qu’il faut retenir ici, c’est que les changements rapides dans le domaine temporel entraînent l’apparition de nombreuses fréquences dans le domaine fréquentiel.</p>
<p>Examinons mainteant les tracés d’une onde carrée dans le domaine temporel et fréquentiel:</p>
<a class="reference external image-reference" href="../_images/square-wave.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/square-wave.svg" class="align-center" src="../_images/square-wave.svg" /></a>
<p>Cet exemple est également pas très intuitif, mais nous pouvons dans un premier temps observer que la présence d’une forte pointe à 10 Hz, qui est la fréquence de l’onde carrée. En revanche, on observe aussi que les fréquences ne s’arrête pas à ce pic mais continue au delà. Cela est dû au changements rapides qu’on peut observer dans le domaine temporel, tout comme dans l’exemple précédent. Toutefois, la courbe dans le domaine fréquentiel ici n’est plus plate. Elle présente plutôt des pics à certains intervalles, et le niveau décroît lentement (bien qu’il se poursuive indéfiniment). Une onde carrée dans le domaine temporel a la forme de la fonction sin(x)/x dans le domaine fréquentiel (fonction aussi appelée sinc).</p>
<p>Maintenant, que se passe-t-il si nous avons un signal constant dans le domaine temporel? Un signal constant n’a pas de “fréquence”.  Voyons voir :</p>
<a class="reference internal image-reference" href="../_images/dc-signal.png"><img alt="../_images/dc-signal.png" class="align-center" src="../_images/dc-signal.png" style="width: 633.0px; height: 217.0px;" /></a>
<p>Comme il n’y a pas de fréquence, nous avons un pic à 0 Hz dans le domaine des fréquences. C’est logique si vous y réfléchissez.  Le domaine des fréquences ne sera pas “vide”, car cela ne se produit que lorsqu’il n’y aucun signal de présent (c’est-à-dire un signal de valeur dans le domaine temporel).  Nous appelons ce 0Hz dans le domaine des fréquences la “CC” (pour <em>courant continue</em>) ou souvent “DC” (pour <em>direct current</em> en anglais), car il est causé par un signal continu et constant dans le temps.  Notez que si nous augmentons l’amplitude de notre signal DC dans le domaine temporel, le pic à 0 Hz dans le domaine fréquentiel augmentera également.</p>
<p>Nous verrons plus tard ce que signifie exactement l’axe des y dans le graphique du domaine des fréquences, mais pour l’instant, vous pouvez le considérer comme une sorte d’amplitude qui vous indique la quantité de cette fréquence présente dans le signal temporel.</p>
</div>
<div class="section" id="transformee-de-fourier">
<h2>Transformée de Fourier<a class="headerlink" href="#transformee-de-fourier" title="Permalink to this headline">¶</a></h2>
<p>Mathématiquement, la “transformation” que nous utilisons pour passer du domaine temporel au domaine fréquentiel ou inversement s’appelle la transformation de Fourier. Elle est définie comme suit :</p>
<div class="math">
<p><img src="../_images/math/6ec9b03637d9f36f1f21065d0ea5f51a02de4423.svg" alt="X(f) = \int x(t) e^{-j2\pi ft} dt"/></p>
</div><p>Pour un signal temporel x(t), nous pouvons obtenir sa version dans le domaine fréquentiel, X(f), en utilisant cette formule.  Nous représenterons la version temporelle d’une fonction par x(t) ou y(t), et la version fréquentielle correspondante par X(f) et Y(f).  Notez qu’on utlise la variable “t” pour le temps, et “f” pour la fréquence. Le “j” est simplement l’unité imaginaire pure. Vous l’avez peut-être vu sous la forme “i” en cours de mathématiques au lycée.  Nous utilisons “j” en ingénierie et en informatique car “i” fait souvent référence au courant, et en programmation, il est souvent utilisé comme itérateur de boucle.</p>
<p>Pour revenir au domaine temporel à partir de la fréquence, c’est presque la même chose, à part un une constante multiplicative et un signe négatif :</p>
<div class="math">
<p><img src="../_images/math/5be5072ccaf0978ad48c208cd73799c36aef51cd.svg" alt="x(t) = \frac{1}{2 \pi} \int X(f) e^{j2\pi ft} df"/></p>
</div><p>Notez que de nombreux manuels utilisent plutôt <img class="math" src="../_images/math/c37cd8faff2fe4e2b7d74bb3d54411948d081962.svg" alt="w"/> à la place de <img class="math" src="../_images/math/f2db2fc8f3c55a36937062e1797243b47a90f001.svg" alt="2\pi f"/>. <img class="math" src="../_images/math/c37cd8faff2fe4e2b7d74bb3d54411948d081962.svg" alt="w"/> est la fréquence angulaire en radians par seconde, alors que <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> est en Hz.  Tout ce que vous devez savoir, c’est que</p>
<div class="math">
<p><img src="../_images/math/198ad5c1c03eb34cf94aa5de5ecc4e89624a2964.svg" alt="\omega = 2 \pi f"/></p>
</div><p>Même si cela ajoute un terme <img class="math" src="../_images/math/adbf740b3ae712140edad99b950ffd8c9ec2919b.svg" alt="2 \pi"/> à de nombreuses équations, il est plus facile de s’en tenir à la fréquence en Hz. En fin de compte, vous travaillerez avec des Hz dans votre application SDR.</p>
<p>L’équation ci-dessus pour la transformée de Fourier est la forme continue, que vous ne verrez que dans les problèmes de mathématiques. La forme discrète est beaucoup plus proche de ce qui est mis en œuvre dans les implémentations matérielles:</p>
<div class="math">
<p><img src="../_images/math/d94eb6f124e7e929c0420fd6d6a19eb14903b593.svg" alt="X_k = \sum_{n=0}^{N-1} x_n e^{-\frac{j2\pi}{N}kn}"/></p>
</div><p>Notez que la principale différence est que nous avons remplacé l’intégrale par une sommation. L’indice <img class="math" src="../_images/math/30d4f39194cc2ced00937a2642c0345222fed6cd.svg" alt="k"/> va de 0 à N-1.</p>
<p>Ce n’est pas grave si aucune de ces équations ne vous intéresse. En fait, nous n’avons pas besoin de les utiliser directement pour faire des trucs cool avec les DSP et les SDR!</p>
</div>
<div class="section" id="proprietes-temps-frequence">
<h2>Propriétés temps-fréquence<a class="headerlink" href="#proprietes-temps-frequence" title="Permalink to this headline">¶</a></h2>
<p>Earlier we examined examples of how signals appear in the time domain and the frequency domain.  Now, we will cover five important “Fourier properties”.  These are properties that tell us if we do ____ to our time domain signal, then ____ happens to our frequency domain signal.  It will give us an important insight into the type of Digital Signal Processing (DSP) we will perform on time domain signals in practice.</p>
<p>Nous avons examiné précédemment des exemples de la manière dont les signaux apparaissent dans le domaine temporel et dans le domaine fréquentiel. Nous allons maintenant aborder cinq importantes “propriétés de Fourier”.  Il s’agit de propriétés qui nous disent que si nous appliquons ____ à notre signal dans le domaine temporel, alors ____ s’appliquera à notre signal dans le domaine fréquentiel. Cela nous donnera un aperçu important du type de traitement numérique du signal (DSP) que nous effectuerons sur les signaux du domaine temporel dans la pratique.</p>
<ol class="arabic simple">
<li>Propriété de linéarité:</li>
</ol>
<div class="math">
<p><img src="../_images/math/746a7887541f0ad9d3847793bc3a342014dc4d6d.svg" alt="a x(t) + b y(t) \leftrightarrow a X(f) + b Y(f)"/></p>
</div><p>Cette propriété est probablement la plus facile à comprendre.  Si nous additionnons deux signaux dans le temps, la version dans le domaine des fréquences sera également la somme de la représentation fréquentielle des deux signaux.  Elle nous indique également que si nous multiplions l’un ou l’autre par une constante, l’équivalent fréquentiel sera également multiplié par la même quantité. L’utilité de cette propriété deviendra plus évidente lorsque nous additionnerons plusieurs signaux à la fois.</p>
<ol class="arabic simple">
<li>Propriété du décalage de fréquence:</li>
</ol>
<div class="math">
<p><img src="../_images/math/be894b85227c716548c31342eccabe9c1b515b57.svg" alt="e^{2 \pi j f_0 t}x(t) \leftrightarrow X(f-f_0)"/></p>
</div><p>Le terme à gauche de x(t) est ce que nous appelons une “sinusoïde complexe” ou une “exponentielle complexe”. Pour l’instant, il nous suffit de savoir qu’il s’agit essentiellement d’une onde sinusoïdale à la fréquence <img class="math" src="../_images/math/da647bd66569f61d6a3f16c3c2e09085c351a343.svg" alt="f_0"/>. Cette propriété nous indique que si nous prenons un signal <img class="math" src="../_images/math/b52a14c3452fbd1a467b640bb6269127e997a8e3.svg" alt="x(t)"/> et que nous le multiplions par une onde sinusoïdale, nous obtenons dans le domaine fréquentiel <img class="math" src="../_images/math/8107fe72abc774dcc596c9fa4ee452bf8f6748af.svg" alt="X(f)"/> sauf qu’il est décalé d’une certaine fréquence, <img class="math" src="../_images/math/da647bd66569f61d6a3f16c3c2e09085c351a343.svg" alt="f_0"/>. Ce décalage en fréquence peut être plus facile à comprendre avec une visualisation:</p>
<a class="reference external image-reference" href="../_images/freq-shift.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/freq-shift.svg" class="align-center" src="../_images/freq-shift.svg" /></a>
<p>Le décalage de fréquence fait partie intégrante du DSP parce que nous voulons décaler les signaux vers le haut et vers le bas en fréquence pour de nombreuses raisons. Cette propriété nous indique comment le faire (en multipliant par une onde sinusoïdale).  Voici une autre façon de visualiser cette propriété:</p>
<a class="reference external image-reference" href="../_images/freq-shift-diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/freq-shift-diagram.svg" class="align-center" src="../_images/freq-shift-diagram.svg" /></a>
<ol class="arabic simple">
<li>Propriété du changement d’échelle dans le temps:</li>
</ol>
<div class="math">
<p><img src="../_images/math/0a4a9d25a8969bb46059aa8e6ae6672fce599b17.svg" alt="x(at) \leftrightarrow X\left(\frac{f}{a}\right)"/></p>
</div><p>Sur la partie gauche de l’équation, nous pouvons voir que nous faisons un changement d’échelle de notre signal x(t) dans le domaine temporel. Voici un exemple du changement d’échelle d’un signal temporel, puis ce qu’il advient des versions dans le domaine des fréquences de chacun d’entre eux.</p>
<a class="reference external image-reference" href="../_images/time-scaling.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-scaling.svg" class="align-center" src="../_images/time-scaling.svg" /></a>
<p>Le changement d’échelle dans le temps a pour effet de rétrécir ou d’étendre le signal sur l’axe des x.  Cette propriété nous indique que la mise à l’échelle dans le domaine temporel entraîne une mise à l’échelle inverse dans le domaine fréquentiel. Par exemple, lorsque nous transmettons des bits plus rapidement, nous devons utiliser davantage de fréquences. Cette propriété permet d’expliquer pourquoi les signaux à haut débit de données occupent une plus grande largeur de bande/spectre. Si l’échelle temps-fréquence était proportionnelle et non inversement proportionnelle, les opérateurs de téléphonie mobile pourraient transmettre tous les bits par seconde qu’ils souhaitent sans avoir à payer des milliards pour avoir accès à plus de spectre!</p>
<p>Les personnes déjà familiarisées avec cette propriété remarqueront peut-être l’absence d’une constante multiplicative, qui a été laissé de côté pour des raisons de simplicité. En pratique, cela ne fait pas de différence.</p>
<ol class="arabic simple">
<li>Propriété de la convolution dans le temps:</li>
</ol>
<div class="math">
<p><img src="../_images/math/866b024f252bc95ed034ab893af1cb799453d7d0.svg" alt="\int x(\tau) y(t-\tau) d\tau  \leftrightarrow X(f)Y(f)"/></p>
</div><p>On l’appelle la propriété de convolution car, dans le domaine temporel, nous convoluons x(t) et y(t). Vous ne connaissez peut-être pas encore l’opération de convolution. Pour l’instant, imaginez-la comme une corrélation croisée. Lorsque nous convoluons des signaux du domaine temporel, cela revient à multiplier les versions du domaine fréquentiel de ces deux signaux. C’est très différent de juste la sommation de deux signaux. Lorsque vous additionnez deux signaux, comme nous l’avons vu, rien ne se passe vraiment, vous additionnez simplement les versions du domaine fréquentiel. Mais lorsque vous convoluez deux signaux, c’est comme si vous créiez un nouveau signal à partir de ceux-ci. La convolution est la technique la plus importante du traitement numérique des signaux, même si nous devons d’abord comprendre le fonctionnement des filtres pour l’appréhender pleinement.</p>
<p>Avant de poursuivre, pour expliquer brièvement pourquoi cette propriété est si importante, considérez la situation suivante: vous avez un signal que vous voulez recevoir, et il y a un signal d’interférence à côté.</p>
<a class="reference external image-reference" href="../_images/two-signals.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/two-signals.svg" class="align-center" src="../_images/two-signals.svg" /></a>
<p>Le concept de masquage est très utilisé en programmation, alors utilisons-le ici. Et si nous pouvions créer le masque ci-dessous, et le multiplier par le signal ci-dessus afin de masquer celui que nous ne voulons pas ?</p>
<a class="reference external image-reference" href="../_images/masking.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/masking.svg" class="align-center" src="../_images/masking.svg" /></a>
<p>Nous effectuons généralement des opérations de traitement numérique des signaux dans le domaine temporel, alors utilisons la propriété de convolution pour voir comment nous pouvons effectuer ce masquage dans le domaine temporel. Disons que x(t) est notre signal reçu. Soit Y(f) le masque que nous voulons appliquer dans le domaine des fréquences. Cela signifie que y(t) est la représentation dans le domaine temporel de notre masque, et que si nous le convolvons avec x(t), nous pouvons “filtrer” le signal que nous ne voulons pas.</p>
<a class="reference internal image-reference" href="../_images/masking-equation.png"><img alt="../_images/masking-equation.png" class="align-center" src="../_images/masking-equation.png" style="width: 327.0px; height: 134.0px;" /></a>
<p>Lorsque nous aborderons le filtrage, la propriété de convolution prendra tout son sens.</p>
<ol class="arabic simple">
<li>Convolution en propriété de fréquence:</li>
</ol>
<p>Enfin, je tiens à souligner que la propriété de convolution fonctionne en sens inverse, même si nous ne l’utiliserons pas autant que la convolution dans le domaine temporel :</p>
<div class="math">
<p><img src="../_images/math/4d0228bed6205664ca7c69fc28ff975676f0e932.svg" alt="x(t)y(t)  \leftrightarrow  \int X(g) Y(f-g) dg"/></p>
</div><p>Il existe d’autres propriétés, mais les cinq ci-dessus sont, à mon avis, les plus importantes à comprendre. Même si nous n’avons pas démontré chaque propriété, le fait est que nous utilisons les propriétés mathématiques pour comprendre ce qui arrive aux signaux réels lorsque nous les analysons et les traitons. Ne vous attardez pas sur les équations. Assurez-vous de bien comprendre la description de chaque propriété.</p>
</div>
<div class="section" id="transformee-de-fourier-rapide-fft">
<h2>Transformée de Fourier rapide (FFT)<a class="headerlink" href="#transformee-de-fourier-rapide-fft" title="Permalink to this headline">¶</a></h2>
<p>Revenons maintenant à la Transformée de Fourier. Je vous ai montré l’équation de la transformée de Fourier discrète, mais ce que vous utiliserez en codant 99,9% du temps sera la fonction <em>fft()</em>. La transformée de Fourier rapide (FFT pour <em>Fast Fourier Transform</em>) est simplement un algorithme permettant de calculer la transformée de Fourier discrète. Il a été développé il y a plusieurs dizaines d’années, et même s’il existe plusieurs variations dans son implémentation, il reste le principal algorithme de calcul de la transformée de Fourier discrète. Une chance pour nous, vu qu’ils ont utilisé le mot “rapide” dans le nom.</p>
<p>La FFT est donc une fonction avec une seul entrée et une seul sortie. Elle convertit un signal temporel en sa représentation fréquentielle:</p>
<a class="reference external image-reference" href="../_images/fft-block-diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fft-block-diagram.svg" class="align-center" src="../_images/fft-block-diagram.svg" /></a>
<p>Dans ce manuel, nous ne traiterons que des FFT à une dimension (la 2D est utilisée pour le traitement des images et d’autres applications). Pour nos besoins, considérez la fonction FFT comme ayant une entrée: un vecteur d’échantillons, et une sortie: la version dans le domaine fréquentiel de ce vecteur d’échantillons. La taille de la sortie est toujours la même que celle de l’entrée. Si j’introduis 1024 échantillons dans la FFT, j’obtiendrai 1024 échantillons en sortie. Ce qui est déroutant, c’est que la sortie sera toujours dans le domaine des fréquences, et donc l’intervalle de l’axe des x si nous devions la tracer ne change pas en fonction du nombre d’échantillons dans le domaine temporel de l’entrée. Visualisons cela en regardant les tableaux d’entrée et de sortie, ainsi que les unités de leurs indices:</p>
<a class="reference external image-reference" href="../_images/fft-io.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fft-io.svg" class="align-center" src="../_images/fft-io.svg" /></a>
<p>La sortie étant dans le domaine fréquentiel, l’intervalle de l’axe des x est basé sur le taux d’échantillonnage, que nous aborderons au chapitre suivant. Lorsque nous utilisons plus d’échantillons pour le vecteur d’entrée, nous obtenons une meilleure résolution dans le domaine fréquentiel (en plus de traiter plus d’échantillons à la fois). Nous ne “voyons” pas réellement plus de fréquences en ayant une entrée plus grande. Le seul moyen serait d’augmenter la fréquence d’échantillonnage (c-à-d diminuer la période d’échantillonnage <img class="math" src="../_images/math/39bb0cf165301516f1e7396af7393a5b3f6c733e.svg" alt="\Delta t"/>).</p>
<p>Comment faire pour tracer cette sortie? Imaginons par exemple que notre fréquence d’échantillonnage soit de 1 million d’échantillons par seconde (1 MHz). Comme nous l’apprendrons au chapitre suivant, cela signifie que nous ne pouvons voir que les signaux jusqu’à 0.5 MHz, quel que soit le nombre d’échantillons introduits dans la FFT.  La façon dont la sortie de la FFT est représentée est la suivante :</p>
<a class="reference external image-reference" href="../_images/negative-frequencies.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/negative-frequencies.svg" class="align-center" src="../_images/negative-frequencies.svg" /></a>
<p>La sortie de la FFT montrera toujours <img class="math" src="../_images/math/cb05020c98608fb3c62ed9132b03cb70bfeac2d4.svg" alt="\text{-} f_s/2"/> à <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/> où <img class="math" src="../_images/math/7daaccc7c28018a253e53d5cde99a13764df9a8d.svg" alt="f_s"/> est la fréquence d’échantillonnage. C’est-à-dire que la sortie aura toujours une partie négative et une partie positive. Si l’entrée est complexe, les portions négative et positive seront différentes, mais si elle est réelle, elles seront identiques.</p>
<p>En ce qui concerne l’intervalle de fréquence, chaque case correspond à <img class="math" src="../_images/math/da39ae114c94fb9dc38f7c6bbe66183011c21dc3.svg" alt="f_s/N"/> Hz, c’est-à-dire que si vous ajoutez plus d’échantillons à chaque FFT, vous obtiendrez une meilleure résolution dans votre sortie. Un détail très mineur qui peut vous être inconnu si vous êtes nouveau: mathématiquement, le tout dernier indice ne correspond pas <em>exactement</em> à <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/>, mais plutôt à <img class="math" src="../_images/math/85b4914ed3d51eb47935368044def8b2299898e1.svg" alt="f_s/2 - f_s/N"/> qui, pour un grand <img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/>, sera approximativement <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/>.</p>
</div>
<div class="section" id="frequences-negatives">
<h2>Fréquences négatives<a class="headerlink" href="#frequences-negatives" title="Permalink to this headline">¶</a></h2>
<p>Qu’est-ce qu’une fréquence négative? Pour l’instant, sachez simplement qu’il s’agit de l’utilisation de nombres complexes (nombres imaginaires) - il n’existe pas vraiment de “fréquence négative” lorsqu’il s’agit de transmettre/recevoir des signaux RF, c’est juste une représentation que nous utilisons.  Voici une façon intuitive d’y penser. Imaginons que nous demandions à notre SDR de se régler sur 100 MHz (la bande radio FM) et d’échantillonner à une fréquence de 10 MHz.  En d’autres termes, nous allons visualiser le spectre de 95 MHz à 105 MHz.  Peut-être y a-t-il trois signaux présents:</p>
<a class="reference external image-reference" href="../_images/negative-frequencies2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/negative-frequencies2.svg" class="align-center" src="../_images/negative-frequencies2.svg" /></a>
<p>Maintenant, quand le SDR nous donne les échantillons, cela apparaîtra comme ceci:</p>
<a class="reference external image-reference" href="../_images/negative-frequencies3.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/negative-frequencies3.svg" class="align-center" src="../_images/negative-frequencies3.svg" /></a>
<p>Rappelez-vous que nous avons réglé le SDR sur 100 MHz. Ainsi, le signal qui était à environ 97.5 MHz apparaît à -2.5 MHz lorsque nous le représentons numériquement, ce qui est techniquement une fréquence négative. En réalité, il s’agit simplement d’une fréquence inférieure à la fréquence centrale. Cela prendra tout son sens lorsque nous en saurons plus sur l’échantillonnage et que nous aurons acquis de l’expérience avec nos SDR.</p>
</div>
<div class="section" id="l-ordre-dans-le-domaine-temporel-n-a-pas-d-importance">
<h2>L’ordre dans le domaine temporel n’a pas d’importance<a class="headerlink" href="#l-ordre-dans-le-domaine-temporel-n-a-pas-d-importance" title="Permalink to this headline">¶</a></h2>
<p>Une dernière propriété avant de passer aux FFT. La fonction FFT “mélange” en quelque sorte le signal d’entrée pour former la sortie, qui a une échelle et des unités différentes. Après tout, nous ne sommes plus dans le domaine temporel. Une bonne façon de comprendre cette différence entre les domaines est de réaliser que le fait de changer l’ordre des choses dans le domaine temporel ne change pas les composantes de fréquence du signal.  Par exemple, la FFT des deux signaux suivants présentera les deux mêmes pics parce que le signal n’est que deux ondes sinusoïdales à des fréquences différentes. Le fait de changer l’ordre dans lequel les ondes sinusoïdales se produisent ne change pas le fait qu’il s’agit de deux ondes sinusoïdales à des fréquences différentes.</p>
<a class="reference internal image-reference" href="../_images/fft_signal_order.png"><img alt="../_images/fft_signal_order.png" class="align-center" src="../_images/fft_signal_order.png" style="width: 634.0px; height: 224.0px;" /></a>
<p>Techniquement, la phase des valeurs de la FFT change en raison du décalage temporel des sinusoïdes. Cependant, dans les premiers chapitres de ce manuel, nous nous intéresserons principalement à la magnitude de la FFT.</p>
</div>
<div class="section" id="fft-en-python">
<h2>FFT en Python<a class="headerlink" href="#fft-en-python" title="Permalink to this headline">¶</a></h2>
<p>Maintenant que nous avons appris ce qu’est une FFT et comment le résultat est représenté, regardons un peu de code Python et utilisons la fonction FFT de Numpy, np.fft.fft(). Il est recommandé d’utiliser une console/IDE Python complète sur votre ordinateur, mais en cas de besoin, vous pouvez utiliser la console Python en ligne sur le Web dont le lien se trouve en bas de la barre de navigation à gauche.</p>
<p>Tout d’abord, nous devons créer un signal dans le domaine temporel.  N’hésitez pas à suivre avec votre propre console Python. Pour garder les choses simples, nous allons créer une simple onde sinusoïdale à 0.15Hz.  Nous utiliserons également une fréquence d’échantillonnage de 1Hz, ce qui signifie que dans le temps, nous échantillonnons à 0, 1, 2, 3 secondes etc.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.15</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Si nous traçons <code class="code docutils literal notranslate"><span class="pre">s</span></code> cela ressemble à:</p>
<a class="reference internal image-reference" href="../_images/fft-python1.png"><img alt="../_images/fft-python1.png" class="align-center" src="../_images/fft-python1.png" style="width: 477.4px; height: 282.79999999999995px;" /></a>
<p>Utilisons ensuite la fonction FFT de Numpy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Si nous regardons <code class="code docutils literal notranslate"><span class="pre">S</span></code>, nous voyons que c’est un tableau de nombres complexes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span>  <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.01865008</span> <span class="o">+</span><span class="mf">0.00000000e+00</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01171553</span> <span class="o">-</span><span class="mf">2.79073782e-01</span><span class="n">j</span><span class="p">,</span><span class="mf">0.02526446</span> <span class="o">-</span><span class="mf">8.82681208e-01</span><span class="n">j</span><span class="p">,</span>  <span class="mf">3.50536075</span> <span class="o">-</span><span class="mf">4.71354150e+01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.15045671</span> <span class="o">+</span><span class="mf">1.31884375e+00</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.10769903</span> <span class="o">+</span><span class="mf">7.10452463e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.09435855</span> <span class="o">+</span><span class="mf">5.01303240e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08808671</span> <span class="o">+</span><span class="mf">3.92187956e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08454414</span> <span class="o">+</span><span class="mf">3.23828386e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08231753</span> <span class="o">+</span><span class="mf">2.76337148e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08081535</span> <span class="o">+</span><span class="mf">2.41078885e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.07974909</span> <span class="o">+</span><span class="mf">2.13663710e-01</span><span class="n">j</span><span class="p">,</span><span class="o">...</span>
</pre></div>
</div>
<p>Conseil: indépendamment de ce que vous faites, si vous rencontrez des nombres complexes, essayez de calculer la magnitude et la phase et voyez si elles ont plus de sens. Faisons exactement cela et traçons la magnitude et la phase. Dans la plupart des langages, abs() est la fonction pour le module d’un nombre complexe. La fonction pour obtenir la phase varie, mais en Python c’est <code class="code docutils literal notranslate"><span class="pre">np.angle()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">S_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">S_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S_mag</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S_phase</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/fft-python2.png"><img alt="../_images/fft-python2.png" class="align-center" src="../_images/fft-python2.png" style="width: 526.4px; height: 465.6px;" /></a>
<p>Pour l’instant, nous ne fournissons pas d’axe x aux graphiques, il s’agit simplement de l’index du tableau (en comptant à partir de 0). Pour des raisons mathématiques, la sortie de la FFT a le format suivant:</p>
<a class="reference external image-reference" href="../_images/fft-python3.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fft-python3.svg" class="align-center" src="../_images/fft-python3.svg" /></a>
<p>Mais nous voulons 0Hz (DC) au centre et les fréquences négatives à gauche (c’est ainsi que nous aimons classiquement visualiser les choses).  Ainsi, chaque fois que nous effectuons une FFT, nous devons effectuer un “décalage FFT”, qui n’est qu’une simple opération de réarrangement de tableau, un peu comme un décalage circulaire, mais plus du type “mettez ceci ici et cela là”. Le diagramme ci-dessous définit entièrement ce que fait l’opération de décalage FFT :</p>
<a class="reference external image-reference" href="../_images/fft-python4.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fft-python4.svg" class="align-center" src="../_images/fft-python4.svg" /></a>
<p>Pour notre confort, Numpy possède une fonction de décalage FFT, <code class="code docutils literal notranslate"><span class="pre">np.fft.fftshift()</span></code>. Remplacez la ligne np.fft.fft() par :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<p>Nous devons également déterminer les valeurs/labels de l’axe des x.  Rappelez-vous que nous avons utilisé une fréquence d’échantillonnage de 1Hz pour garder les choses simples. Cela signifie que le bord gauche du graphique du domaine fréquentiel sera de -0.5Hz et le bord droit de 0.5Hz. Si cela n’a pas de sens, cela en aura après avoir lu le chapitre sur <a class="reference internal" href="../content-nl/sampling.html#sampling-chapter"><span class="std std-ref">IQ-sampling</span></a>.  Restons-en à l’hypothèse que notre fréquence d’échantillonnage était de 1Hz, et traçons la magnitude et la phase de la sortie de la FFT avec un label approprié sur l’axe des x. Voici la version finale de cet exemple Python ainsi que sa sortie:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">Fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Hz</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># le nombre de points à simuler, et la taille de notre FFT</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># parce que notre taux d&#39;échantillonnage est de 1 Hz</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.15</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="n">S_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">S_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Fs</span><span class="o">/-</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">S_mag</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">S_phase</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/fft-python5.png"><img alt="../_images/fft-python5.png" class="align-center" src="../_images/fft-python5.png" style="width: 518.4px; height: 442.40000000000003px;" /></a>
<p>Notez que nous voyons notre pic à 0.15Hz, qui est la fréquence que nous avons utilisée pour créer l’onde sinusoïdale. Cela signifie donc que notre FFT a fonctionné! Si nous ne connaissions pas le code utilisé pour générer cette onde sinusoïdale, mais qu’on nous donnait simplement la liste des échantillons, nous pourrions utiliser la FFT pour déterminer la fréquence. La raison pour laquelle nous voyons également un pic à -0.15 Hz est liée au fait qu’il s’agissait d’un signal réel, non complexe, et nous y reviendrons plus tard.</p>
</div>
<div class="section" id="fenetrage">
<h2>Fenêtrage<a class="headerlink" href="#fenetrage" title="Permalink to this headline">¶</a></h2>
<p>Lorsque nous utilisons une FFT pour mesurer les composantes de fréquence de notre signal, la FFT suppose qu’on lui fournit un morceau de signal <em>périodique</em>. Elle se comporte comme si le morceau de signal que nous avons fourni continuait à se répéter indéfiniment. C’est comme si le dernier échantillon de la tranche était relié au premier échantillon. Cela découle de la théorie de la transformation de Fourier. Cela signifie que nous voulons éviter les transitions soudaines entre le premier et le dernier échantillon, car les transitions soudaines dans le domaine temporel ressemblent à la somme de nombreuses hautes fréquences, alors qu’en réalité, c’est juste notre dernier échantillon qui ne se “connecte” pas à notre premier échantillon. Pour dire plus simplemenet: si nous faisons une FFT de 100 échantillons, en utilisant <code class="code docutils literal notranslate"><span class="pre">np.fft.fft(x)</span></code>, nous voulons que <code class="code docutils literal notranslate"><span class="pre">x[0]</span></code> et <code class="code docutils literal notranslate"><span class="pre">x[99]</span></code> soient égaux ou proches en valeur.</p>
<p>La façon dont nous compensons cette propriété cyclique est le “fenêtrage”.  Juste avant la FFT, nous multiplions la tranche de signal par une fonction de fenêtrage, c’est-à-dire n’importe quelle fonction qui se tend vers zéro aux deux extrémités. Cela garantit que la tranche de signal commencera et finira à zéro, formant ainsi une transition lisse. Les fonctions de fenêtre courantes sont Hamming, Hanning, Blackman et Kaiser. Lorsque vous n’appliquez aucun fenêtrage, on dit que vous utilisez une fenêtre “rectangulaire” car cela revient à multiplier par un rectangle de uns.   Voici à quoi ressemblent plusieurs fonctions de fenêtrage :</p>
<a class="reference external image-reference" href="../_images/windows.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/windows.svg" class="align-center" src="../_images/windows.svg" /></a>
<p>Une approche simple pour les débutants est de s’en tenir à une fenêtre de Hamming, qui peut être créée en Python avec <code class="code docutils literal notranslate"><span class="pre">np.hamming(N)</span></code> où N est le nombre d’éléments du tableau, qui est tout simplement la taille de votre FFT. Dans l’exercice ci-dessus, nous appliquerons la fenêtre juste avant la FFT. Après la 2ème ligne de code, nous insérons :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Si vous avez peur de choisir la mauvaise fenêtre, ne le soyez pas. Les différences entre les fenêtres de Hamming, Hanning, Blackman et Kaiser sont très minimes par rapport à l’absence totale de fenêtre, car elles tendent toutes à zéro des deux côtés et résolvent le problème de discontinuité.</p>
</div>
<div class="section" id="taille-de-la-fft">
<h2>Taille de la FFT<a class="headerlink" href="#taille-de-la-fft" title="Permalink to this headline">¶</a></h2>
<p>La dernière chose à pointer est la taille de la FFT. La meilleure taille de FFT est toujours une puissance de 2 en raison de la façon dont la FFT est implémentée. Vous pouvez utiliser une taille qui n’est pas d’un ordre de 2, mais elle ne sera plus rapide. Les tailles courantes se situent entre 128 et 4 096, mais vous pouvez certainement aller plus loin. Dans la pratique, nous pouvons être amenés à traiter des signaux de plusieurs millions ou milliards d’échantillons, ce qui nous oblige à décomposer le signal et à effectuer de nombreuses FFT. Cela signifie que nous obtiendrons de nombreuses sorties. Nous pouvons soit en faire la moyenne, soit les tracer dans le temps (en particulier lorsque notre signal évolue dans le temps).  Il n’est pas nécessaire de soumettre <em>chaque</em> échantillon d’un signal à une FFT pour obtenir une bonne représentation du domaine fréquentiel de ce dernier. Par exemple, vous pouvez ne soumettre à la FFT que 1024 échantillons sur 100k d’un signal et le résultat sera probablement satisfaisant, à condition que le signal soit toujours présent.</p>
</div>
<div class="section" id="spectrogramme">
<h2>Spectrogramme<a class="headerlink" href="#spectrogramme" title="Permalink to this headline">¶</a></h2>
<p>Un spectrogramme est le graphique qui montre l’évolution des fréquences en fonction du temps. Il s’agit simplement d’un ensemble de FFT empilées ensemble (verticalement, si vous voulez que la fréquence soit sur l’axe horizontal).  On peut aussi le visualiser en temps réel. L’analyseur de spectre est l’appareil qui permet d’afficher ce spectrogramme. Voici un exemple de spectrogramme, avec la fréquence sur l’axe horizontal et le temps sur l’axe vertical. Le bleu représente l’amplitude la plus faible et le rouge la plus élevée. Nous pouvons voir qu’il y a un pic fort à DC (0 Hz) au centre avec un signal variable autour de lui.  Le bleu représente notre plancher de bruit.</p>
<a class="reference internal image-reference" href="../_images/waterfall.png"><img alt="../_images/waterfall.png" class="align-center" src="../_images/waterfall.png" style="width: 463.2px; height: 297.59999999999997px;" /></a>
<p>Comme exercice, essayez d’écrire le code Python nécessaire pour produire un spectrogramme. N’oubliez pas qu’il s’agit simplement de “rangées” de FFT empilées les unes sur les autres, chaque rangée représentant une FFT.  Veillez à découper votre signal d’entrée en tranches de la taille de votre FFT (par exemple, 1024 échantillons par tranche). Pour simplifier les choses, vous pouvez rentrer un signal réel et éliminer simplement la moitié négative des fréquences avant de tracer le spectrogramme.  Voici un exemple de signal que vous pouvez utiliser, il s’agit simplement d’un tonnalité dans un bruit blanc:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span>

<span class="c1"># Générer une tonnalité plus un bruit</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># vecteur de temps</span>
<span class="n">f</span> <span class="o">=</span> <span class="mf">50e3</span> <span class="c1"># fréquence de la tonnalité</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>Voici à quoi cela ressemble dans le domaine temporel (200 premiers échantillons) :</p>
<a class="reference external image-reference" href="../_images/spectrogram_time.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/spectrogram_time.svg" class="align-center" src="../_images/spectrogram_time.svg" /></a>
<details>
<summary>Exemple de code de spectrogramme (essayez d'abord de l'écrire vous-même !)</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># simuler le signal ci-dessus, ou utiliser votre propre signal</span>

<span class="n">fft_size</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">num_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">fft_size</span><span class="p">))</span>
<span class="n">spectrogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">fft_size</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rows</span><span class="p">):</span>
    <span class="n">spectrogram</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">fft_size</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">fft_size</span><span class="p">])))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">spectrogram</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">[:,</span><span class="n">fft_size</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span> <span class="c1"># se débarrasser des fréquences négatives parce que nous avons simulé un signal réel</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">spectrogram</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [MHz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Time [s]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Ce qui devrait produire le spectrogramme suivant, qui n’est pas le plus intéressant car il n’y a pas de comportement variable dans le temps.  Comme exercice supplémentaire, essayez d’ajouter un comportement variable dans le temps, par exemple en faisant en sorte que la tonnalité commence et s’arrête.</p>
<a class="reference external image-reference" href="../_images/spectrogram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/spectrogram.svg" class="align-center" src="../_images/spectrogram.svg" /></a>
</details></div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="intro.html" title="Previous document"><span class="section-number">1. </span>Introduction</a>
        </li>
        <li>
          <a href="sampling.html" title="Next document"><span class="section-number">3. </span>échantillonnage IQ</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>