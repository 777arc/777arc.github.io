
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5. PlutoSDR en Python &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. USRP en Python" href="usrp.html" />
    <link rel="prev" title="4. Modulation numérique" href="digital_modulation.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. PlutoSDR en Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation-de-logiciels-pilotes">Installation de logiciels/pilotes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reception">Réception</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transmettre">Transmettre</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transmettre-et-recevoir-simultanement">Transmettre et recevoir simultanément</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercices-python">Exercices Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="digital_modulation.html" title="previous chapter"><span class="section-number">4. </span>Modulation numérique</a></li>
      <li>Next: <a href="usrp.html" title="next chapter"><span class="section-number">6. </span>USRP en Python</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="digital_modulation.html" title="Previous document"><span class="section-number">4. </span>Modulation numérique</a>
        </li>
        <li>
          <a href="usrp.html" title="Next document"><span class="section-number">6. </span>USRP en Python</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="plutosdr-en-python">
<span id="pluto-chapter"></span><h1><span class="section-number">5. </span>PlutoSDR en Python<a class="headerlink" href="#plutosdr-en-python" title="Permalink to this headline">¶</a></h1>
<a class="reference internal image-reference" href="../_images/pluto.png"><img alt="../_images/pluto.png" class="align-center" src="../_images/pluto.png" style="width: 323.5px; height: 250.0px;" /></a>
<p>Dans ce chapitre, nous apprenons à utiliser l’API Python pour le <a class="reference external" href="https://www.analog.com/en/design-center/evaluation-hardware-and-software/evaluation-boards-kits/adalm-pluto.html" rel="noopener noreferrer" target="_blank">PlutoSDR</a>, qui est une radio SDR à faible coût d’Analog Devices.  Nous couvrirons les étapes d’installation du PlutoSDR afin de faire fonctionner les pilotes et le logiciel, puis nous discuterons de la transmission et de la réception avec le PlutoSDR en Python.</p>
<div class="section" id="installation-de-logiciels-pilotes">
<h2>Installation de logiciels/pilotes<a class="headerlink" href="#installation-de-logiciels-pilotes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuration-de-la-vm">
<h3>Configuration de la VM<a class="headerlink" href="#configuration-de-la-vm" title="Permalink to this headline">¶</a></h3>
<p>Bien que le code Python fourni dans ce manuel devrait fonctionner sous Windows, Mac et Linux, les instructions d’installation ci-dessous sont spécifiques à Ubuntu 18. Si vous avez des difficultés à installer le logiciel sur votre OS en suivant <a class="reference external" href="https://wiki.analog.com/university/tools/pluto/users/quick_start" rel="noopener noreferrer" target="_blank">les instructions fournies par Analog Devices</a>, je vous recommande d’installer une VM Ubuntu 18 et d’essayer les instructions ci-dessous.</p>
<ol class="arabic simple">
<li>Installez et ouvrez <a class="reference external" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener noreferrer" target="_blank">VirtualBox</a>.</li>
<li>Créez une nouvelle VM.  Pour la taille de la mémoire, je recommande d’utiliser 50% de la RAM de votre ordinateur.</li>
<li>Créez le disque dur virtuel, choisissez VDI, et allouez dynamiquement la taille.  15 Go devraient suffire. Si vous voulez être vraiment sûr, vous pouvez utiliser plus.</li>
<li>Téléchargez Ubuntu 18 Desktop .iso- <a class="reference external" href="http://releases.ubuntu.com/18.04/" rel="noopener noreferrer" target="_blank">http://releases.ubuntu.com/18.04/</a></li>
<li>Démarrez la VM. Il vous demandera le support d’installation. Choisissez le fichier .iso du bureau Ubuntu 18.  Choisissez “installer ubuntu”, utilisez les options par défaut, et une fenêtre pop-up vous avertira des changements que vous êtes sur le point d’effectuer. Cliquez sur continuer.  Choisissez le nom/mot de passe et attendez que la VM finisse de s’initialiser.  Après avoir terminé, la VM va redémarrer, mais vous devez éteindre la VM après le redémarrage.</li>
<li>Allez dans les paramètres de la VM (l’icône de l’engrenage).</li>
<li>Sous système &gt; processeur &gt; choisissez au moins 3 processeurs.  Si vous avez une carte vidéo réelle, alors dans affichage &gt; mémoire vidéo &gt; choisissez quelque chose de beaucoup plus élevé.</li>
<li>Démarrez votre VM.</li>
<li>Je recommande d’installer des addons d’invités VM. Dans la VM, allez dans Devices &gt; Insert Guest Additions CD &gt; cliquez sur run quand une boîte apparaît.  Suivez les instructions. Redémarrez la VM.  Le presse-papiers partagé peut être activé via Dispositifs &gt; Presse-papiers partagé &gt; Bidirectionnel.</li>
</ol>
</div>
<div class="section" id="connecter-la-plutosdr">
<h3>Connecter la PlutoSDR<a class="headerlink" href="#connecter-la-plutosdr" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Si vous utilisez OSX, dans OSX, et non dans la VM, dans les préférences système, activez “kernel extensions”.  Puis installez HoRNDIS (vous devrez peut-être redémarrer après).</li>
<li>Si vous utilisez Windows, installez ce pilote : <a class="reference external" href="https://github.com/analogdevicesinc/plutosdr-m2k-drivers-win/releases/download/v0.7/PlutoSDR-M2k-USB-Drivers.exe" rel="noopener noreferrer" target="_blank">https://github.com/analogdevicesinc/plutosdr-m2k-drivers-win/releases/download/v0.7/PlutoSDR-M2k-USB-Drivers.exe</a></li>
<li>Si vous utilisez Linux, vous ne devriez pas avoir à faire quoi que ce soit de spécial.</li>
<li>Branchez Pluto sur la machine hôte via le port USB. Veillez à utiliser le port USB central de Pluto, car l’autre ne sert qu’à l’alimentation.  Le branchement de Pluto devrait créer une carte réseau virtuelle, c’est-à-dire que Pluto apparaît comme un adaptateur Ethernet USB.</li>
<li>Sur la machine hôte (pas la VM), ouvrez un terminal ou votre outil ping préféré et effectuez un ping sur 192.168.2.1.  Si cela ne fonctionne pas, arrêtez et déboguez l’interface réseau.</li>
<li>Dans la VM, ouvrez un nouveau terminal</li>
<li>Effectuez un Ping sur 192.168.2.1.  Si cela ne fonctionne pas, arrêtez ici et déboguez.  Si cela continue, c’est que quelque chose d’autre à cette adresse IP est sur le réseau, et vous devrez changer l’IP du Pluto (ou de l’autre appareil) avant de continuer.</li>
<li>Notez l’adresse IP du Pluto car vous en aurez besoin lorsque nous commencerons à utiliser la Pluto en Python.</li>
</ol>
</div>
<div class="section" id="installation-du-pilote-plutosdr">
<h3>Installation du pilote PlutoSDR<a class="headerlink" href="#installation-du-pilote-plutosdr" title="Permalink to this headline">¶</a></h3>
<p>Les commandes de terminal ci-dessous devraient construire et installer la dernière version de :</p>
<ol class="arabic simple">
<li><strong>libiio</strong>, la bibliothèque “multiplateforme” d’Analog Device pour l’interfaçage du matériel.</li>
<li><strong>libad9361-iio</strong>, AD9361 est la puce RF spécifique du PlutoSDR.</li>
<li><strong>pyadi-iio</strong>, l’API Python du Pluto, <em>c’est notre objectif final</em>, mais il dépend des deux bibliothèques précédentes.</li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>build-essential<span class="w"> </span>git<span class="w"> </span>libxml2-dev<span class="w"> </span>bison<span class="w"> </span>flex<span class="w"> </span>libcdk5-dev<span class="w"> </span>cmake<span class="w"> </span>python3-pip<span class="w"> </span>libusb-1.0-0-dev<span class="w"> </span>libavahi-client-dev<span class="w"> </span>libavahi-common-dev<span class="w"> </span>libaio-dev
<span class="nb">cd</span><span class="w"> </span>~
git<span class="w"> </span>clone<span class="w"> </span>--branch<span class="w"> </span>v0.23<span class="w"> </span>https://github.com/analogdevicesinc/libiio.git
<span class="nb">cd</span><span class="w"> </span>libiio
mkdir<span class="w"> </span>build
<span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>-DPYTHON_BINDINGS<span class="o">=</span>ON<span class="w"> </span>..
make<span class="w"> </span>-j<span class="k">$(</span>nproc<span class="k">)</span>
sudo<span class="w"> </span>make<span class="w"> </span>install
sudo<span class="w"> </span>ldconfig

<span class="nb">cd</span><span class="w"> </span>~
git<span class="w"> </span>clone<span class="w"> </span>https://github.com/analogdevicesinc/libad9361-iio.git
<span class="nb">cd</span><span class="w"> </span>libad9361-iio
mkdir<span class="w"> </span>build
<span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>..
make<span class="w"> </span>-j<span class="k">$(</span>nproc<span class="k">)</span>
sudo<span class="w"> </span>make<span class="w"> </span>install

<span class="nb">cd</span><span class="w"> </span>~
git<span class="w"> </span>clone<span class="w"> </span>https://github.com/analogdevicesinc/pyadi-iio.git
<span class="nb">cd</span><span class="w"> </span>pyadi-iio
pip3<span class="w"> </span>install<span class="w"> </span>--upgrade<span class="w"> </span>pip
pip3<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements.txt
sudo<span class="w"> </span>python3<span class="w"> </span>setup.py<span class="w"> </span>install
</pre></div>
</div>
</div>
<div class="section" id="test-des-pilotes-plutosdr">
<h3>Test des pilotes PlutoSDR<a class="headerlink" href="#test-des-pilotes-plutosdr" title="Permalink to this headline">¶</a></h3>
<p>Ouvrez un nouveau terminal (dans votre VM) et tapez les commandes suivantes :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3
import<span class="w"> </span>adi
<span class="nv">sdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>adi.Pluto<span class="o">(</span><span class="s1">&#39;ip:192.168.2.1&#39;</span><span class="o">)</span><span class="w"> </span><span class="c1"># ou quel que soit l&#39;IP de votre Pluton</span>
sdr.sample_rate<span class="w"> </span><span class="o">=</span><span class="w"> </span>int<span class="o">(</span><span class="m">2</span>.5e6<span class="o">)</span>
sdr.rx<span class="o">()</span>
</pre></div>
</div>
<p>Si vous parvenez à ce stade sans erreur, passez aux étapes suivantes.</p>
</div>
<div class="section" id="changer-l-adresse-ip-de-pluton">
<h3>Changer l’adresse IP de Pluton<a class="headerlink" href="#changer-l-adresse-ip-de-pluton" title="Permalink to this headline">¶</a></h3>
<p>Si, pour une raison quelconque, l’IP par défaut de 192.168.2.1 ne fonctionne pas parce que vous avez déjà un sous-réseau 192.168.2.0, ou parce que vous voulez que plusieurs Pluto soient connectés en même temps, vous pouvez changer l’IP en suivant les étapes suivantes :</p>
<ol class="arabic simple">
<li>Modifiez le fichier config.txt sur le périphérique de stockage de masse PlutoSDR (c’est-à-dire le dispositif ressemblant à une clé USB qui apparaît après avoir branché la Pluto).  Entrez la nouvelle IP que vous voulez.</li>
<li>Ejectez le périphérique de stockage de masse (ne débranchez pas la Pluto !). Dans Ubuntu 18, il y a un symbole d’éjection à côté du périphérique PlutoSDR, lorsque vous regardez l’explorateur de fichiers.</li>
<li>Attendez quelques secondes, puis faites un cycle d’alimentation en débranchant le Pluto et en le rebranchant.  Retournez dans le config.txt pour déterminer si votre ou vos modifications ont été enregistrées.</li>
</ol>
<p>Notez que cette procédure est également utilisée pour flasher une image de firmware différente sur la Pluto. Pour plus de détails, voir <a class="reference external" href="https://wiki.analog.com/university/tools/pluto/users/firmware" rel="noopener noreferrer" target="_blank">https://wiki.analog.com/university/tools/pluto/users/firmware</a>.</p>
</div>
<div class="section" id="hacker-plutosdr-pour-augmenter-la-plage-rf">
<h3>“Hacker” PlutoSDR pour augmenter la plage RF<a class="headerlink" href="#hacker-plutosdr-pour-augmenter-la-plage-rf" title="Permalink to this headline">¶</a></h3>
<p>Les PlutoSDR sont livrés avec une gamme de fréquences centrales et un taux d’échantillonnage limités, mais la puce sous-jacente est capable de fréquences beaucoup plus élevées.  Suivez ces étapes pour débloquer la gamme de fréquences complète de la puce.  S’il vous plaît garder à l’esprit que ce processus est fourni par Analog Devices, il est donc aussi faible risque que vous pouvez obtenir.  La limitation de fréquence du PlutoSDR est due au fait qu’Analog Devices utilisant l’AD9364 sur la base d’exigences strictes de performance à des fréquences plus élevées. …. En tant que passionnés de SDR et expérimentateurs, nous ne sommes pas trop concernés par ces exigences de performance.</p>
<p>Il est temps de pirater ! Ouvrez un terminal (hôte ou VM, peu importe) :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ssh<span class="w"> </span>root@192.168.2.1
</pre></div>
</div>
<p>Le mot de passe par défaut est analogique.</p>
<p>Vous devriez voir l’écran de bienvenue de PlutoSDR. Vous avez maintenant SSH dans le CPU ARM sur la Pluto elle-même !
Si vous avez une Pluto avec la version 0.31 ou inférieure du firmware, tapez les commandes suivantes :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fw_setenv<span class="w"> </span>attr_name<span class="w"> </span>compatible
fw_setenv<span class="w"> </span>attr_val<span class="w"> </span>ad9364
reboot
</pre></div>
</div>
<p>Et pour l’utilisation de 0.32 et plus :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fw_setenv<span class="w"> </span>compatible<span class="w"> </span>ad9364
reboot
</pre></div>
</div>
<p>Vous devriez maintenant être en mesure de tuner jusqu’à 6 GHz et de descendre jusqu’à 70 MHz, sans oublier d’utiliser une fréquence d’échantillonnage jusqu’à 56 MHz !  Bravo !</p>
</div>
</div>
<div class="section" id="reception">
<h2>Réception<a class="headerlink" href="#reception" title="Permalink to this headline">¶</a></h2>
<p>L’échantillonnage en utilisant l’API Python du PlutoSDR est simple.  Avec n’importe quelle application SDR, nous savons que nous devons lui indiquer la fréquence centrale, la fréquence d’échantillonnage et le gain (ou si nous voulons utiliser le contrôle automatique du gain).  Il peut y avoir d’autres détails, mais ces trois paramètres sont nécessaires pour que le SDR ait suffisamment d’informations pour recevoir des échantillons.  Certains SDR ont une commande pour leur indiquer de commencer à échantillonner, tandis que d’autres, comme la Pluto, commencent à échantillonner dès que vous l’initialisez. Une fois que le tampon interne du SDR se remplit, les échantillons les plus anciens sont abandonnés.  Toutes les API SDR ont une sorte de fonction “recevoir des échantillons”, et pour la Pluto c’est rx(), qui renvoie un lot d’échantillons.  Le nombre spécifique d’échantillons par lot est défini par la taille du tampon définie au préalable.</p>
<p>Le code ci-dessous suppose que vous avez installé l’API Python du Pluto.  Ce code initialise le Pluto, fixe la fréquence d’échantillonnage à 1 MHz, fixe la fréquence centrale à 100 MHz et fixe le gain à 70 dB avec le contrôle automatique du gain désactivé.  Notez que l’ordre dans lequel vous définissez la fréquence centrale, le gain et la fréquence d’échantillonnage n’a généralement pas d’importance.  Dans l’extrait de code ci-dessous, nous indiquons à la Pluto que nous voulons qu’elle nous donne 10 000 échantillons par appel à rx().  Nous affichons les 10 premiers échantillons.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">adi</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># Hz</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">100e6</span> <span class="c1"># Hz</span>
<span class="n">num_samps</span> <span class="o">=</span> <span class="mi">10000</span> <span class="c1"># nombre d&#39;échantillons retournés par appel à rx()</span>

<span class="n">sdr</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">Pluto</span><span class="p">()</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">gain_control_mode_chan0</span> <span class="o">=</span> <span class="s1">&#39;manual&#39;</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_hardwaregain_chan0</span> <span class="o">=</span> <span class="mf">70.0</span> <span class="c1"># dB</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="c1"># largeur du filtre, il suffit de le mettre au même niveau que la fréquence d&#39;échantillonnage pour l&#39;instant.</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">num_samps</span>

<span class="n">samples</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">rx</span><span class="p">()</span> <span class="c1"># recevoir des échantillons de la Pluton</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
<p>Pour l’instant, nous n’allons rien faire d’intéressant avec ces échantillons, mais le reste de ce manuel est rempli de code Python qui fonctionne sur des échantillons de QI comme ceux que nous avons reçus ci-dessus.</p>
<div class="section" id="gain-de-reception">
<h3>Gain de réception<a class="headerlink" href="#gain-de-reception" title="Permalink to this headline">¶</a></h3>
<p>La Pluto peut être configuré pour avoir un gain de réception fixe ou automatique. Un contrôle automatique de gain (CAG) ajustera automatiquement le gain de réception pour maintenir un niveau de signal fort (-12dBFS pour ceux qui sont curieux).  L’AGC ne doit pas être confondu avec le convertisseur analogique-numérique (CAN) qui numérise le signal.  Techniquement parlant, l’AGC est un circuit de rétroaction en boucle fermée qui contrôle le gain de l’amplificateur en réponse au signal reçu.  Son objectif est de maintenir un niveau de puissance de sortie constant malgré un niveau de puissance d’entrée variable.  En général, le CAG ajuste le gain pour éviter de saturer le récepteur (c’est-à-dire d’atteindre la limite supérieure de la plage du CAN) tout en permettant au signal de “remplir” autant de bits CAN que possible.</p>
<p>Le circuit intégré de radiofréquence, ou RFIC, à l’intérieur de la PlutoSDR possède un module CAG avec quelques réglages différents.  (Un RFIC est une puce qui fonctionne comme un émetteur-récepteur : il émet et reçoit des ondes radio).  Tout d’abord, notez que le gain de réception sur la Pluto a une gamme de 0 à 74.5 dB.  En mode CAG “manuel”, le CAG est désactivé, et vous devez indiquer au Pluto le gain de réception à utiliser, par exemple :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sdr</span><span class="o">.</span><span class="n">gain_control_mode_chan0</span> <span class="o">=</span> <span class="s2">&quot;manual&quot;</span> <span class="c1"># désactiver l&#39;AGC</span>
<span class="n">gain</span> <span class="o">=</span> <span class="mf">50.0</span> <span class="c1"># allowable range is 0 to 74.5 dB</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_hardwaregain_chan0</span> <span class="o">=</span> <span class="n">gain</span> <span class="c1"># la gamme permise est de 0 à 74.5 dB</span>
</pre></div>
</div>
<p>Si vous voulez activer le CAG, vous devez choisir l’un des deux modes suivants :</p>
<ol class="arabic simple">
<li><code class="code docutils literal notranslate"><span class="pre">sdr.gain_control_mode_chan0</span> <span class="pre">=</span> <span class="pre">&quot;slow_attack&quot;</span></code></li>
<li><code class="code docutils literal notranslate"><span class="pre">sdr.gain_control_mode_chan0</span> <span class="pre">=</span> <span class="pre">&quot;fast_attack&quot;</span></code></li>
</ol>
<p>Et avec le CAG activé, vous ne devez pas fournir une valeur à <code class="code docutils literal notranslate"><span class="pre">rx_hardwaregain_chan0</span></code>. Elle sera ignorée car le Pluto ajuste lui-même le gain du signal. La Pluto a deux modes pour le CAG : attaque rapide et attaque lente, comme indiqué dans le code ci-dessus. La différence entre les deux est intuitive, si vous y pensez. Le mode d’attaque rapide réagit plus rapidement aux signaux.  En d’autres termes, la valeur du gain change plus rapidement lorsque le signal reçu change de niveau.  L’ajustement aux niveaux de puissance des signaux peut être important, notamment pour les systèmes avec mutliplexage temporelle (TDD) qui utilisent la même fréquence pour émettre et recevoir. Le réglage de la commande de gain en mode d’attaque rapide pour ce scénario limite l’atténuation du signal.  Dans l’un ou l’autre de ces modes, si aucun signal n’est présent et qu’il n’y a que du bruit, la commande automatique de gain maximisera le réglage du gain ; lorsqu’un signal apparaît, il saturera brièvement le récepteur, jusqu’à ce que la commande automatique de gain puisse réagir et réduire le gain.  Vous pouvez toujours vérifier le niveau de gain actuel en temps réel avec :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sdr</span><span class="o">.</span><span class="n">_get_iio_attr</span><span class="p">(</span><span class="s1">&#39;voltage0&#39;</span><span class="p">,</span><span class="s1">&#39;hardwaregain&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Pour plus de détails sur la commande automatique de gain (CAG) de la Pluto, notamment sur la manière de modifier les paramètres CAG avancés, reportez-vous à la rubrique <a class="reference external" href="https://wiki.analog.com/resources/tools-software/linux-drivers/iio-transceiver/ad9361" rel="noopener noreferrer" target="_blank">the “RX Gain Control” section of this page</a>.</p>
</div>
</div>
<div class="section" id="transmettre">
<h2>Transmettre<a class="headerlink" href="#transmettre" title="Permalink to this headline">¶</a></h2>
<p>Avant de transmettre un signal avec votre Pluto, assurez-vous de connecter un câble SMA entre le port TX de la Pluto et l’appareil qui servira de récepteur.  Il est important de toujours commencer par transmettre sur un câble, en particulier lorsque vous apprenez <em>comment</em> transmettre, pour vous assurer que la SDR se comporte comme vous le souhaitez.  Maintenez toujours une puissance d’émission extrêmement faible, afin de ne pas surcharger le récepteur, car le câble n’atténue pas le signal comme le fait le canal sans fil.  Si vous possédez un atténuateur (par exemple 30 dB), c’est le bon moment pour l’utiliser.  Si vous ne disposez pas d’un autre SDR ou d’un analyseur de spectre pour faire office de récepteur, vous pouvez en théorie utiliser le port RX sur la même Pluto, mais cela peut devenir compliqué.  Je vous recommanderais de vous procurer un RTL-SDR à 10$ pour faire office de SDR de réception.</p>
<p>Transmettre est très similaire à recevoir, sauf qu’au lieu de dire au SDR de recevoir un certain nombre d’échantillons, nous lui donnerons un certain nombre d’échantillons à transmettre.  Au lieu de <code class="code docutils literal notranslate"><span class="pre">rx_lo</span></code>, nous allons définir <code class="code docutils literal notranslate"><span class="pre">tx_lo</span></code>, pour spécifier sur quelle fréquence porteuse émettre.  Le taux d’échantillonnage est partagé entre le RX et le TX, donc nous allons le régler comme d’habitude.  Un exemple complet de transmission est montré ci-dessous, où nous générons une sinusoïde à +100 kHz, puis transmettons le signal complexe à une fréquence porteuse de 915 MHz, ce qui fait que le récepteur voit une porteuse à 915,1 MHz.  Il n’y a pas vraiment de raison pratique de faire cela, nous aurions pu simplement régler la center_freq sur 915.1e6 et transmettre un tableau de 1, mais nous voulions générer des échantillons complexes à des fins de démonstration.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">adi</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># Hz</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">915e6</span> <span class="c1"># Hz</span>

<span class="n">sdr</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">Pluto</span><span class="p">(</span><span class="s2">&quot;ip:192.168.2.1&quot;</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="c1"># la coupure du filtre, il suffit de la régler sur la même fréquence d&#39;échantillonnage.</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_hardwaregain_chan0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">50</span> <span class="c1"># Augmenter pour augmenter la puissance tx, la plage valide est de -90 à 0 dB</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">10000</span> <span class="c1"># nombre d&#39;échantillons à transmettre en une seule fois</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span>
<span class="n">samples</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">2.0</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">100e3</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># Simulez une sinusoïde de 100 kHz, qui devrait apparaître à 915,1 MHz au niveau du récepteur.</span>
<span class="n">samples</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">14</span> <span class="c1"># Le PlutoSDR s&#39;attend à ce que les échantillons soient compris entre -2^14 et +2^14, et non -1 et +1 comme certaines SDRs.</span>

<span class="c1"># Transmettez notre lot d&#39;échantillons 100 fois, ce qui devrait représenter 1 seconde d&#39;échantillons au total, si l&#39;USB peut suivre.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">sdr</span><span class="o">.</span><span class="n">tx</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="c1"># transmettre le lot d&#39;échantillons une fois</span>
</pre></div>
</div>
<p>Voici quelques notes sur ce code.  Tout d’abord, vous voulez simuler vos échantillons IQ pour qu’ils soient entre -1 et 1, mais avant de les transmettre, nous devons les mettre à l’échelle par 2^14 à cause de la façon dont Analog Devices a implémenté la fonction <code class="code docutils literal notranslate"><span class="pre">tx()</span></code>.  Si vous n’êtes pas sûr des valeurs min/max, imprimez-les simplement avec <code class="code docutils literal notranslate"><span class="pre">print(np.min(samples),</span> <span class="pre">np.max(samples))</span></code> ou écrivez une instruction if pour vous assurer qu’elles ne sont jamais supérieures à 1 ou inférieures à -1 (en supposant que ce code vienne avant la mise à l’échelle de 2^14).  En ce qui concerne le gain d’émission, la gamme est de -90 à 0 dB, donc 0 dB est la puissance d’émission la plus élevée.  Nous voulons toujours commencer à une faible puissance d’émission, puis augmenter si nécessaire, donc nous avons réglé le gain à -50 dB par défaut, ce qui est vers le bas.  Ne vous contentez pas de le régler sur 0 dB simplement parce que votre signal n’apparaît pas; il y a peut-être un autre problème et vous ne voulez pas griller votre récepteur.</p>
<div class="section" id="transmettre-des-echantillons-en-repetition">
<h3>Transmettre des échantillons en répétition<a class="headerlink" href="#transmettre-des-echantillons-en-repetition" title="Permalink to this headline">¶</a></h3>
<p>Si vous voulez transmettre continuellement le même ensemble d’échantillons de manière répétée, au lieu d’utiliser une boucle for/while dans Python comme nous l’avons fait ci-dessus, vous pouvez dire au Pluto de le faire en utilisant une seule ligne :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sdr</span><span class="o">.</span><span class="n">tx_cyclic_buffer</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Activer les tampons cycliques</span>
</pre></div>
</div>
<p>Vous transmettez alors vos échantillons comme d’habitude : <code class="code docutils literal notranslate"><span class="pre">sdr.tx(samples)</span></code> une seule fois, et la Pluto continuera à transmettre le signal indéfiniment, jusqu’à ce que le destructeur de l’objet sdr soit appelé.  Pour changer les échantillons qui sont transmis en continu, vous ne pouvez pas simplement appeler <code class="code docutils literal notranslate"><span class="pre">sdr.tx(samples)</span></code> à nouveau avec un nouveau jeu d’échantillons, vous devez d’abord appeler <code class="code docutils literal notranslate"><span class="pre">sdr.tx_destroy_buffer()</span></code>, puis appeler <code class="code docutils literal notranslate"><span class="pre">sdr.tx(samples)</span></code>.</p>
</div>
<div class="section" id="transmettre-par-voie-hertzienne-en-toute-legalite">
<h3>Transmettre par voie hertzienne en toute légalité<a class="headerlink" href="#transmettre-par-voie-hertzienne-en-toute-legalite" title="Permalink to this headline">¶</a></h3>
<p>D’innombrables fois, des étudiants m’ont demandé sur quelles fréquences ils étaient autorisés à émettre avec une antenne (aux États-Unis).  La réponse courte est aucune, pour autant que je sache.  Généralement, lorsque les gens font référence à des réglementations spécifiques qui parlent de limites de puissance d’émission, ils se réfèrent aux fréquences suivantes <a class="reference external" href="https://www.ecfr.gov/cgi-bin/text-idx?SID=7ce538354be86061c7705af3a5e17f26&amp;mc=true&amp;node=pt47.1.15&amp;rgn=div5" rel="noopener noreferrer" target="_blank">the FCC’s “Title 47, Part 15” (47 CFR 15) regulations</a>.  Mais il s’agit de réglementations pour les fabricants qui construisent et vendent des appareils fonctionnant dans les bandes ISM, et ces réglementations traitent de la manière dont ils doivent être testés.  Un appareil de la partie 15 est un appareil pour lequel une personne n’a pas besoin de licence pour le faire fonctionner dans le spectre qu’il utilise, mais l’appareil lui-même doit être autorisé/certifié pour montrer qu’il fonctionne conformément aux réglementations de la FCC avant d’être commercialisé et vendu.  Les réglementations de la partie 15 spécifient les niveaux de puissance maximum d’émission et de réception pour les différents éléments du spectre, mais rien de tout cela ne s’applique réellement à une personne transmettant un signal avec une radio SDR ou une radio de fabrication artisanale.  Les seules réglementations que j’ai pu trouver concernant les radios qui ne sont pas réellement des produits vendus étaient spécifiques à l’exploitation d’une station radio AM ou FM de faible puissance dans les bandes AM/FM.  Il y a également une section sur les “appareils de fabrication artisanale”, mais il est spécifiquement dit qu’elle ne s’applique pas à tout ce qui est construit à partir d’un kit, et il serait exagéré de dire qu’une plate-forme d’émission utilisant une radio logicielle est un appareil de fabrication artisanale.  En résumé, les réglementations de la FCC ne sont pas aussi simples que “vous pouvez transmettre à ces fréquences uniquement sous ces niveaux de puissance”, mais il s’agit plutôt d’un énorme ensemble de règles destinées aux tests et à la conformité.</p>
<p>Une autre façon de voir les choses serait de dire “bien, ce ne sont pas des appareils de la Partie 15, mais suivons les règles de la Partie 15 comme s’ils l’étaient”.  Pour la bande ISM de 915 MHz, les règles sont les suivantes : “L’intensité de champ de toute émission rayonnée dans la bande de fréquence spécifiée ne doit pas dépasser 500 microvolts/mètre à 30 mètres. La limite d’émission dans ce paragraphe est basée sur un instrument de mesure employant un détecteur moyen.”  Donc, comme vous pouvez le voir, ce n’est pas aussi simple qu’une puissance d’émission maximale en watts.</p>
<p>Maintenant, si vous avez votre licence de radio amateur (ham), la FCC vous permet d’utiliser certaines bandes réservées à la radio amateur.  Il y a toujours des directives à suivre et des puissances d’émission maximales, mais au moins ces chiffres sont spécifiés en watts de puissance rayonnée effective.  <a class="reference external" href="http://www.arrl.org/files/file/Regulatory/Band%20Chart/Band%20Chart%20-%2011X17%20Color.pdf" rel="noopener noreferrer" target="_blank">Ce graphique</a> indique quelles bandes sont disponibles en fonction de votre catégorie de licence (Technicien, Général et Extra).  Je recommande à toute personne intéressée par la transmission avec des SDRs d’obtenir sa licence de radioamateur, cf. <a class="reference external" href="http://www.arrl.org/getting-licensed" rel="noopener noreferrer" target="_blank">ARRL’s Getting Licensed page</a> pour plus d’info.</p>
<p>Si quelqu’un a plus de détails sur ce qui est autorisé ou non, veuillez m’envoyer un email.</p>
</div>
</div>
<div class="section" id="transmettre-et-recevoir-simultanement">
<h2>Transmettre et recevoir simultanément<a class="headerlink" href="#transmettre-et-recevoir-simultanement" title="Permalink to this headline">¶</a></h2>
<p>En utilisant l’astuce tx_cyclic_buffer, vous pouvez facilement recevoir et émettre en même temps, en déclenchant l’émetteur, puis la réception.
Le code suivant montre un exemple fonctionnel de transmission d’un signal QPSK dans la bande 915 MHz, de réception et d’affichage de la DSP.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">adi</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># Hz</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">915e6</span> <span class="c1"># Hz</span>
<span class="n">num_samps</span> <span class="o">=</span> <span class="mi">100000</span> <span class="c1"># nombre d&#39;échantillons par appel à rx()</span>

<span class="n">sdr</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">Pluto</span><span class="p">(</span><span class="s2">&quot;ip:192.168.2.1&quot;</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>

<span class="c1"># Config Tx</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="c1"># la coupure du filtre, il suffit de la régler sur la même fréquence d&#39;échantillonnage.</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_hardwaregain_chan0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">50</span> <span class="c1"># Augmenter pour augmenter la puissance tx, la plage valide est de -90 à 0 dB</span>

<span class="c1"># Configurer Rx</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">num_samps</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">gain_control_mode_chan0</span> <span class="o">=</span> <span class="s1">&#39;manual&#39;</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_hardwaregain_chan0</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># dB, augmenter pour augmenter le gain de réception, mais attention à ne pas saturer le CAN</span>

<span class="c1"># Créer une forme d&#39;onde de transmission (QPSK, 16 échantillons par symbole)</span>
<span class="n">num_symbols</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">x_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num_symbols</span><span class="p">)</span> <span class="c1"># 0 to 3</span>
<span class="n">x_degrees</span> <span class="o">=</span> <span class="n">x_int</span><span class="o">*</span><span class="mi">360</span><span class="o">/</span><span class="mf">4.0</span> <span class="o">+</span> <span class="mi">45</span> <span class="c1"># 45, 135, 225, 315 degrees</span>
<span class="n">x_radians</span> <span class="o">=</span> <span class="n">x_degrees</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span> <span class="c1"># sin() et cos() avec des angles en radians</span>
<span class="n">x_symbols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x_radians</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x_radians</span><span class="p">)</span> <span class="c1"># ce qui produit nos symboles complexes QPSK</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x_symbols</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="c1"># 16 échantillons par symbole (impulsions rectangulaires)</span>
<span class="n">samples</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">14</span> <span class="c1"># Le PlutoSDR s&#39;attend à ce que les échantillons soient compris entre -2^14 et +2^14, et non entre -1 et +1 comme certains SDRs.</span>

<span class="c1"># Start the transmitter</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_cyclic_buffer</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Activer les tampons cycliques</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="c1"># début de la transmission</span>

<span class="c1"># Effacer le tampon juste pour être sûr</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">rx</span><span class="p">()</span>

<span class="c1"># Recevoir des échantillons</span>
<span class="n">rx_samples</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">rx</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rx_samples</span><span class="p">)</span>

<span class="c1"># Arrêter la transmission</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">tx_destroy_buffer</span><span class="p">()</span>

<span class="c1"># Calculer la densité spectrale de puissance (version du signal dans le domaine de la fréquence)</span>
<span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">rx_samples</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span>
<span class="n">psd_dB</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">/-</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">psd</span><span class="p">))</span>

<span class="c1"># Tracer le domaine temporel</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">rx_samples</span><span class="p">[::</span><span class="mi">100</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">rx_samples</span><span class="p">[::</span><span class="mi">100</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;temps&quot;</span><span class="p">)</span>

<span class="c1"># Tracer le domaine freq</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">psd_dB</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequences [MHz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;DSP&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Vous devriez voir quelque chose qui ressemble à ceci, en supposant que vous avez des antennes appropriées ou un câble connecté :</p>
<img alt="../_images/pluto_tx_rx.svg" class="align-center" src="../_images/pluto_tx_rx.svg" /><p>C’est un bon exercice que de régler lentement <code class="code docutils literal notranslate"><span class="pre">sdr.tx_hardwaregain_chan0</span></code> et <code class="code docutils literal notranslate"><span class="pre">sdr.rx_hardwaregain_chan0</span></code> pour s’assurer que le signal reçu devient plus faible/fort comme prévu.</p>
</div>
<div class="section" id="exercices-python">
<h2>Exercices Python<a class="headerlink" href="#exercices-python" title="Permalink to this headline">¶</a></h2>
<p>Au lieu de vous fournir du code à exécuter, j’ai créé plusieurs exercices où 95 % du code est fourni et où le code restant est du Python assez simple à créer.  Les exercices ne sont pas censés être difficiles. Il leur manque juste assez de code pour vous faire réfléchir.</p>
<div class="section" id="exercice-1-determiner-le-debit-de-votre-usb">
<h3>Exercice 1 : Déterminer le débit de votre USB<a class="headerlink" href="#exercice-1-determiner-le-debit-de-votre-usb" title="Permalink to this headline">¶</a></h3>
<p>Essayons de recevoir des échantillons du PlutoSDR, et dans le processus, voyons combien d’échantillons par seconde nous pouvons pousser à travers la connexion USB 2.0.</p>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>Votre tâche consiste à créer un script Python qui détermine le taux de réception des échantillons en Python, c’est-à-dire compter les échantillons reçus et suivre le temps pour déterminer le taux.  Ensuite, essayez d’utiliser différents taux d’échantillonnage et tailles de tampon pour voir comment cela affecte le taux le plus élevé réalisable.</p>
<p>Gardez à l’esprit que si vous recevez moins d’échantillons par seconde que le taux d’échantillonnage spécifié, cela signifie que vous perdez/supprimez une certaine fraction d’échantillons, ce qui se produira probablement à des taux d’échantillonnage élevés. La Pluto utilise uniquement l’USB 2.0.</p>
<p>Le code suivant servira de point de départ mais contient les instructions dont vous avez besoin pour accomplir cette tâche.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">adi</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">10e6</span> <span class="c1"># Hz</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">100e6</span> <span class="c1"># Hz</span>

<span class="n">sdr</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">Pluto</span><span class="p">(</span><span class="s2">&quot;ip:192.168.2.1&quot;</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_rf_bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span> <span class="c1"># la fréquence de coupure du filtre, il suffit de la régler sur la même fréquence d&#39;échantillonnage.</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
<span class="n">sdr</span><span class="o">.</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="mi">1024</span> <span class="c1"># c&#39;est le tampon que le Pluto utilise pour mettre en mémoire tampon les échantillons</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">rx</span><span class="p">()</span> <span class="c1"># recevoir des échantillons au large de Pluton</span>
</pre></div>
</div>
<p>En outre, afin de déterminer la durée d’une opération, vous pouvez utiliser le code suivant :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="c1"># faire des chodes</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;secondes écoulées:&#39;</span><span class="p">,</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
</pre></div>
</div>
<p>Voici quelques conseils pour vous aider à démarrer.</p>
<p>Conseil 1 : Vous devrez placer la ligne “samples = sdr.rx()” dans une boucle qui s’exécute plusieurs fois (par exemple, 100 fois). Vous devez compter combien d’échantillons vous obtenez à chaque appel à sdr.rx() tout en suivant le temps qui s’est écoulé.</p>
<p>Astuce 2 : Le fait que vous calculiez des échantillons par seconde ne signifie pas que vous devez effectuer exactement 1 seconde de réception d’échantillons. Vous pouvez diviser le nombre d’échantillons reçus par le temps écoulé.</p>
<p>Conseil 3 : Commencez avec sample_rate = 10e6 comme le montre le code car ce taux est bien plus que ce que l’USB 2.0 peut supporter. Vous serez en mesure de voir combien de données sont transmises.  Ensuite vous pouvez modifier rx_buffer_size. Faites-le beaucoup plus grand et voyez ce qui se passe.  Une fois que vous avez un script fonctionnel et que vous avez modifié rx_buffer_size, essayez d’ajuster sample_rate. Déterminez jusqu’où vous devez descendre pour être capable de recevoir 100 % des échantillons en Python (c’est-à-dire échantillonner à un cycle de service de 100 %).</p>
<p>Conseil 4 : Dans votre boucle où vous appelez sdr.rx(), essayez d’en faire le moins possible afin de ne pas ajouter de délai supplémentaire dans le temps d’exécution. Ne faites rien d’intensif comme afficher à l’intérieur de la boucle.</p>
<p>Dans le cadre de cet exercice, vous aurez une idée du débit maximal de l’USB 2.0. Vous pouvez vérifier vos résultats en ligne.</p>
<p>En bonus, essayez de changer la fréquence centrale et la largeur de bande rx_rf_bandwidth pour voir si cela a un impact sur la vitesse à laquelle vous pouvez recevoir des échantillons du Pluto.</p>
</div>
<div class="section" id="exercice-2-creer-un-spectrogramme">
<h3>Exercice 2 : créer un spectrogramme<a class="headerlink" href="#exercice-2-creer-un-spectrogramme" title="Permalink to this headline">¶</a></h3>
<p>Pour cet exercice, vous allez créer un spectrogramme, comme nous l’avons appris à la fin du chapitre <a class="reference internal" href="../content-nl/frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a>.  Un spectrogramme est simplement un ensemble de FFT affichées empilées les unes sur les autres. En d’autres termes, c’est une image avec un axe représentant la fréquence et l’autre axe représentant le temps.</p>
<p>Dans le chapitre <a class="reference internal" href="../content-nl/frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a> nous avons appris le code Python pour effectuer une FFT.  Pour cet exercice, vous pouvez utiliser les extraits de code de l’exercice précédent, ainsi qu’un peu de code Python de base.</p>
<p>Indices:</p>
<ol class="arabic simple">
<li>Essayez de définir sdr.rx_buffer_size à la taille de la FFT de sorte que vous exécutez toujours 1 FFT pour chaque appel à <cite>sdr.rx()</cite>.</li>
<li>Construisez un tableau 2d pour contenir tous les résultats de la FFT où chaque ligne représente 1 FFT.  Un tableau 2d rempli de zéros peut être créé avec : <cite>np.zeros((num_rows, fft_size))</cite>.  Accédez à la ligne i du tableau avec : <cite>waterfall_2darray[i, :]</cite>.</li>
<li><cite>plt.imshow()</cite> est un moyen pratique d’afficher un tableau 2d. La couleur est mise à l’échelle automatiquement.</li>
</ol>
<p>Comme but ultime, faire la mise à jour du spectrogramme en direct.</p>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="digital_modulation.html" title="Previous document"><span class="section-number">4. </span>Modulation numérique</a>
        </li>
        <li>
          <a href="usrp.html" title="Next document"><span class="section-number">6. </span>USRP en Python</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>