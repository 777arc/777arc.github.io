
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4. Modulation numérique &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. PlutoSDR en Python" href="pluto.html" />
    <link rel="prev" title="3. échantillonnage IQ" href="sampling.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/nl/index-nl.html">Dutch</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Modulation numérique</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#symboles">Symboles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symboles-sans-fils">Symboles sans fils</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modulation-par-deplacement-d-amplitude">Modulation par déplacement d’amplitude</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modulation-par-deplacement-de-phase">Modulation par déplacement de phase</a></li>
<li class="toctree-l2"><a class="reference internal" href="#diagrammes-iq-constellations">Diagrammes IQ/Constellations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modulation-d-amplitude-en-quadrature">Modulation d’amplitude en quadrature</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modulation-par-deplacement-de-frequence">Modulation par déplacement de fréquence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#codage-differentiel">Codage différentiel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exemple-python">Exemple Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="sampling.html" title="previous chapter"><span class="section-number">3. </span>échantillonnage IQ</a></li>
      <li>Next: <a href="pluto.html" title="next chapter"><span class="section-number">5. </span>PlutoSDR en Python</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="sampling.html" title="Previous document"><span class="section-number">3. </span>échantillonnage IQ</a>
        </li>
        <li>
          <a href="pluto.html" title="Next document"><span class="section-number">5. </span>PlutoSDR en Python</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="modulation-numerique">
<span id="modulation-chapitre"></span><h1><span class="section-number">4. </span>Modulation numérique<a class="headerlink" href="#modulation-numerique" title="Permalink to this headline">¶</a></h1>
<p>Dans ce chapitre, nous aborderons la transmission <em>réelle de données</em> à l’aide de la modulation numérique et des symboles sans fil!  Nous concevrons des signaux qui transmettent des “informations”, par exemple des 1 et des 0, en utilisant des schémas de modulation comme ASK, PSK, QAM et FSK.  Nous aborderons également les diagrammes et constellations IQ et terminerons le chapitre par quelques exemples Python.</p>
<p>L’objectif principal de la modulation est de faire rentrer le maximum de données dans le moins de spectre possible.  Techniquement parlant, nous voulons maximiser “l’efficacité spectrale” en unités bits/sec/Hz.  Transmettre des 1 et des 0 plus rapidement augmentera la largeur de bande de notre signal (rappelons les propriétés de Fourier), ce qui signifie que davantage de spectre est utilisé. Nous allons également examiner d’autres techniques que la transmission plus rapide.  Il y aura de nombreux compromis à faire pour décider de la façon de moduler, mais il y aura aussi de la place pour la créativité.</p>
<div class="section" id="symboles">
<h2>Symboles<a class="headerlink" href="#symboles" title="Permalink to this headline">¶</a></h2>
<p>Alerte au nouveau terme!  Notre signal de transmission va être composé de “symboles”.  Chaque symbole transporte un certain nombre de bits d’information, et nous transmettons des symboles les uns après les autres, par milliers, voire par millions.</p>
<p>Pour simplifier, disons que nous avons un fil et que nous envoyons des 1 et des 0 en utilisant des niveaux de tension élevés et faibles.  Un symbole est l’un de ces 1 ou 0:</p>
<a class="reference internal image-reference" href="../_images/symbols.png"><img alt="../_images/symbols.png" class="align-center" src="../_images/symbols.png" style="width: 602.4px; height: 102.0px;" /></a>
<p>Dans l’exemple ci-dessus, chaque symbole représente un bit.  Comment pouvons-nous transmettre plus d’un bit par symbole?  Étudions les signaux qui circulent dans les câbles Ethernet, définis par une norme IEEE appelée IEEE 802.3 1000BASE-T.  Le mode de fonctionnement commun d’Ethernet utilise une modulation d’amplitude à 4 niveaux (2 bits par symbole) avec des symboles de 8 ns.</p>
<a class="reference external image-reference" href="../_images/ethernet.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/ethernet.svg" class="align-center" src="../_images/ethernet.svg" /></a>
<p>Prenez un moment pour essayer de répondre à ces questions :</p>
<ol class="arabic simple">
<li>Combien de bits par seconde sont transmis dans l’exemple ci-dessus ?</li>
<li>Combien de paires de ces fils de données seraient nécessaires pour transmettre 1 gigabit/seconde ?</li>
<li>Si un schéma de modulation comporte 16 niveaux différents, combien de bits par symbole cela représente-t-il ?</li>
<li>Avec 16 niveaux différents et des symboles de 8 ns, combien de bits par seconde cela représente-t-il ?</li>
</ol>
<details>
<summary>Réponses</summary><ol class="arabic simple">
<li>250 Mbps - (1/8e-9)*2</li>
<li>Quatre (ce qui est le cas des câbles ethernet)</li>
<li>4 bits par symbole - log_2(16)</li>
<li>0,5 Gbps - (1/8e-9)*4</li>
</ol>
</details></div>
<div class="section" id="symboles-sans-fils">
<h2>Symboles sans fils<a class="headerlink" href="#symboles-sans-fils" title="Permalink to this headline">¶</a></h2>
<p>Question : Pourquoi ne pouvons-nous pas transmettre directement le signal Ethernet illustré dans la figure ci-dessus?  Il y a de nombreuses raisons, les deux plus importantes étant :</p>
<ol class="arabic simple">
<li>Les basses fréquences nécessitent des antennes <em>énormes</em>.</li>
<li>Les ondes carrées prennent une quantité excessive de spectre pour les bits par seconde - rappelez-vous du chapitre <a class="reference internal" href="../content-nl/frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a> que les changements brusques dans le domaine temporel utilisent une grande quantité de bande/spectre :</li>
</ol>
<a class="reference external image-reference" href="../_images/square-wave.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/square-wave.svg" class="align-center" src="../_images/square-wave.svg" /></a>
<p>Pour les signaux sans fil, nous commençons par une porteuse, qui est juste une sinusoïde.  Par exemple, la radio FM utilise une porteuse comme 101,1 MHz ou 100,3 MHz.  Nous modulons cette porteuse d’une manière ou d’une autre (il y en a plusieurs).  Pour la radio FM, il s’agit d’une modulation analogique, et non numérique, mais c’est le même concept que la modulation numérique.</p>
<p>De quelles manières pouvons-nous moduler la porteuse?  Autre façon de poser la même question: quelles sont les différentes propriétés d’une sinusoïde?</p>
<ol class="arabic simple">
<li>Amplitude</li>
<li>Phase</li>
<li>Fréquence</li>
</ol>
<p>Nous pouvons moduler nos données sur une porteuse en modifiant l’un (ou plusieurs) de ces trois éléments.</p>
</div>
<div class="section" id="modulation-par-deplacement-d-amplitude">
<h2>Modulation par déplacement d’amplitude<a class="headerlink" href="#modulation-par-deplacement-d-amplitude" title="Permalink to this headline">¶</a></h2>
<p>Modulation par déplacement d’amplitude (ou ASK en anglais pour Amplitude Shift Keying) est le premier schéma de modulation numérique que nous allons aborder car la modulation d’amplitude est la plus simple à visualiser parmi les trois propriétés des sinusoïdes.  Nous modulons littéralement l’ <strong>amplitude</strong> de la porteuse.  Voici un exemple de modulation par déplacement d’amplitude à deux niveaux, appelé 2-ASK:</p>
<a class="reference external image-reference" href="../_images/ASK.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/ASK.svg" class="align-center" src="../_images/ASK.svg" /></a>
<p>Notez que la valeur moyenne est égale à zéro, ce que nous préférons dans la mesure du possible.</p>
<p>Nous pouvons utiliser plus de deux niveaux, ce qui permet d’avoir plus de bits par symbole.  L’exemple ci-dessous montre un exemple de 4-ASK.  Dans ce cas, chaque symbole porte 2 bits d’information.</p>
<a class="reference external image-reference" href="../_images/ask2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/ask2.svg" class="align-center" src="../_images/ask2.svg" /></a>
<p>Question: Combien de symboles sont représentés dans l’extrait de signal ci-dessus?  Combien de bits sont représentés au total?</p>
<details>
<summary>Réponse</summary><p>20 symboles, donc 40 bits d’information</p>
</details><p>Comment créer réellement ce signal numériquement, par le biais d’un code?  Tout ce que nous avons à faire est de créer un vecteur avec N échantillons par symbole, puis de multiplier ce vecteur par une sinusoïde.  Cela module le signal sur une porteuse (la sinusoïde agit comme cette porteuse).  L’exemple ci-dessous montre un 2-ASK avec 10 échantillons par symbole.</p>
<a class="reference external image-reference" href="../_images/ask3.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/ask3.svg" class="align-center" src="../_images/ask3.svg" /></a>
<p>Le graphique du haut montre les échantillons discrets représentés par des points rouges, c’est-à-dire notre signal numérique.  Le graphique du bas montre à quoi ressemble le signal modulé résultant, qui pourrait être transmis par voie aérienne.  Dans les systèmes réels, la fréquence de la porteuse est généralement beaucoup plus élevée que la vitesse à laquelle les symboles changent.  Dans cet exemple, il n’y a que trois cycles de la sinusoïde dans chaque symbole, mais dans la pratique, il peut y en avoir des milliers, en fonction de la hauteur du spectre dans lequel le signal est transmis.</p>
</div>
<div class="section" id="modulation-par-deplacement-de-phase">
<h2>Modulation par déplacement de phase<a class="headerlink" href="#modulation-par-deplacement-de-phase" title="Permalink to this headline">¶</a></h2>
<p>Envisageons maintenant de moduler la phase de la même manière que nous l’avons fait pour l’amplitude.  La forme la plus simple est la modulation PSK binaire, aussi appelée BPSK, où il y a deux niveaux de phase:</p>
<ol class="arabic simple">
<li>Pas de changement de phase</li>
<li>Changement de phase à 180 degrés</li>
</ol>
<p>Exemple de BPSK (notez les changements de phase):</p>
<a class="reference external image-reference" href="../_images/bpsk.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/bpsk.svg" class="align-center" src="../_images/bpsk.svg" /></a>
<p>Ce n’est pas très amusant de regarder des graphiques comme celui-ci:</p>
<a class="reference external image-reference" href="../_images/bpsk2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/bpsk2.svg" class="align-center" src="../_images/bpsk2.svg" /></a>
<p>Au lieu de cela, nous représentons habituellement la phase dans le plan complexe.</p>
</div>
<div class="section" id="diagrammes-iq-constellations">
<h2>Diagrammes IQ/Constellations<a class="headerlink" href="#diagrammes-iq-constellations" title="Permalink to this headline">¶</a></h2>
<p>Vous avez déjà vu des diagrammes IQ dans la sous-section sur les nombres complexes du chapitre <a class="reference internal" href="../content-nl/sampling.html#sampling-chapter"><span class="std std-ref">IQ-sampling</span></a>, mais maintenant nous allons les utiliser d’une manière nouvelle et amusante.  Pour un symbole donné, nous pouvons montrer l’amplitude et la phase sur un diagramme IQ.  Pour l’exemple BPSK, nous avons dit que nous avions des phases de 0 et 180 degrés. Traçons ces deux points sur le diagramme IQ. Nous supposerons que l’amplitude est de 1. Dans la pratique, l’amplitude utilisée n’a pas vraiment d’importance; une valeur plus élevée signifie un signal plus puissant, mais vous pouvez également augmenter le gain de l’amplificateur.</p>
<a class="reference internal image-reference" href="../_images/bpsk_iq.png"><img alt="../_images/bpsk_iq.png" class="align-center" src="../_images/bpsk_iq.png" style="width: 384.0px; height: 316.0px;" /></a>
<p>Le diagramme IQ ci-dessus montre ce que nous allons transmettre, ou plutôt l’ensemble des symboles à partir desquels nous allons transmettre.  Il ne montre pas la porteuse, vous pouvez donc considérer qu’il représente les symboles en bande de base.  Lorsque nous montrons l’ensemble des symboles possibles pour un schéma de modulation donné, nous l’appelons la “constellation”.  De nombreux schémas de modulation peuvent être définis par leur constellation.</p>
<p>Pour recevoir et décoder la BPSK, nous pouvons utiliser l’échantillonnage IQ, comme nous l’avons appris au chapitre précédent, et examiner où les points aboutissent sur le diagramme IQ.  Cependant, il y aura une rotation de phase aléatoire due au canal sans fil car le signal aura un certain retard aléatoire lorsqu’il passe dans l’air entre les antennes.  La rotation de phase aléatoire peut être inversée à l’aide de diverses méthodes que nous verrons plus tard.  Voici un exemple de différentes façons dont un signal BPSK peut apparaître dans le récepteur (sans tenir compte du bruit) :</p>
<a class="reference internal image-reference" href="../_images/bpsk3.png"><img alt="../_images/bpsk3.png" class="align-center" src="../_images/bpsk3.png" style="width: 732.6px; height: 217.79999999999998px;" /></a>
<p>Retour au PSK.  Et si nous voulions quatre niveaux de phase différents?  C’est-à-dire 0, 90, 180 et 270 degrés.  Dans ce cas, cela serait représenté comme suit sur le diagramme IQ, et cela forme un schéma de modulation que nous appelons modulation par déplacement de phase en quadrature (ou QPSK en anglais pour <em>Quadrature Phase Shift Keying</em>):</p>
<a class="reference internal image-reference" href="../_images/qpsk.png"><img alt="../_images/qpsk.png" class="align-center" src="../_images/qpsk.png" style="width: 706.1999999999999px; height: 240.0px;" /></a>
<p>Pour la PSK, nous avons toujours N phases différentes, également espacées sur 360 degrés pour obtenir les meilleurs résultats.  Nous montrons souvent le cercle unitaire pour souligner que tous les points ont la même magnitude:</p>
<a class="reference internal image-reference" href="../_images/psk_set.png"><img alt="../_images/psk_set.png" class="align-center" src="../_images/psk_set.png" style="width: 733.1999999999999px; height: 246.6px;" /></a>
<p>Question: Qu’y a-t-il de mal à utiliser un schéma PSK comme celui de l’image ci-dessous? S’agit-il d’un schéma de modulation PSK valide?</p>
<a class="reference internal image-reference" href="../_images/weird_psk.png"><img alt="../_images/weird_psk.png" class="align-center" src="../_images/weird_psk.png" style="width: 216.6px; height: 225.6px;" /></a>
<details>
<summary>Réponse</summary><p>Il n’y a rien d’invalide dans ce schéma PSK. Vous pouvez certainement l’utiliser, mais, comme les symboles ne sont pas uniformément espacés, ce schéma n’est pas aussi efficace qu’il pourrait l’être. L’efficacité du schéma deviendra claire lorsque nous aborderons l’impact du bruit sur nos symboles.  En résumé, nous voulons laisser le plus d’espace possible entre les symboles, au cas où il y aurait du bruit, afin qu’un symbole ne soit pas interprété par le récepteur comme l’un des autres symboles (incorrects).  Nous ne voulons pas qu’un 0 soit reçu comme un 1.</p>
</details><p>Revenons un instant sur ASK.  Notez que nous pouvons montrer l’ASK sur le diagramme IQ tout comme pour la PSK.  Voici le tracé IQ de 2-ASK, 4-ASK, et 8-ASK, dans la configuration bipolaire, ainsi que 2-ASK et 4-ASK dans la configuration unipolaire.</p>
<a class="reference internal image-reference" href="../_images/ask_set.png"><img alt="../_images/ask_set.png" class="align-center" src="../_images/ask_set.png" style="width: 642.5px; height: 370.0px;" /></a>
<p>Comme vous l’avez peut-être remarqué, 2-ASK bipolaire et BPSK sont identiques. Un déphasage de 180 degrés équivaut à multiplier la sinusoïde par -1.  Nous l’appelons BPSK, probablement parce que la BPSK est beaucoup plus utilisée que l’ASK.</p>
</div>
<div class="section" id="modulation-d-amplitude-en-quadrature">
<h2>Modulation d’amplitude en quadrature<a class="headerlink" href="#modulation-d-amplitude-en-quadrature" title="Permalink to this headline">¶</a></h2>
<p>Et si nous combinions ASK et PSK?  Nous appelons ce schéma de modulation modulation d’amplitude en quadrature (ou QAM en anglais pour <a href="#id1"><span class="problematic" id="id2">*</span></a>Quadrature Amplitude Modulation <a href="#id3"><span class="problematic" id="id4">*</span></a>). La QAM ressemble généralement à ceci :</p>
<a class="reference internal image-reference" href="../_images/64qam.png"><img alt="../_images/64qam.png" class="align-center" src="../_images/64qam.png" style="width: 276.3px; height: 282.6px;" /></a>
<p>Voici d’autres exemples de QAM:</p>
<a class="reference internal image-reference" href="../_images/qam.png"><img alt="../_images/qam.png" class="align-center" src="../_images/qam.png" style="width: 695.5px; height: 236.5px;" /></a>
<p>Pour un schéma de modulation QAM, nous pouvons techniquement placer des points où nous le souhaitons sur le diagramme IQ puisque la phase <em>et</em> l’amplitude sont modulées.  Les “paramètres” d’un schéma QAM donné sont mieux définis en montrant la constellation QAM. Vous pouvez également indiquer les valeurs I et Q pour chaque point, comme ci-dessous pour la QPSK :</p>
<a class="reference internal image-reference" href="../_images/qpsk_list.png"><img alt="../_images/qpsk_list.png" class="align-center" src="../_images/qpsk_list.png" style="width: 308.8px; height: 215.20000000000002px;" /></a>
<p>Notez que la plupart des schémas de modulation, à l’exception des diverses ASK et BPSK, sont assez difficiles à “voir” dans le domaine temporel.  Pour prouver mon propos, voici un exemple de QAM dans le domaine temporel. Pouvez-vous distinguer la phase de chaque symbole dans l’image ci-dessous ? C’est difficile.</p>
<a class="reference internal image-reference" href="../_images/qam_time_domain.png"><img alt="../_images/qam_time_domain.png" class="align-center" src="../_images/qam_time_domain.png" style="width: 658.0px; height: 148.0px;" /></a>
<p>Étant donné la difficulté de discerner les schémas de modulation dans le domaine temporel, nous préférons utiliser des diagrammes IQ plutôt que d’afficher le signal dans le domaine temporel.  Nous pouvons néanmoins montrer le signal dans le domaine temporel s’il y a une certaine structure de paquets ou si la séquence des symboles est importante.</p>
</div>
<div class="section" id="modulation-par-deplacement-de-frequence">
<h2>Modulation par déplacement de fréquence<a class="headerlink" href="#modulation-par-deplacement-de-frequence" title="Permalink to this headline">¶</a></h2>
<p>La dernière sur la liste est la modulation par déplacement de fréquence (ou FSK en anglais pour <em>Frequency Shift Keying</em>).  La FSK est assez simple à comprendre: nous nous déplaçons simplement entre N fréquences, chaque fréquence représentant un symbole possible.  Cependant, comme nous modulons une porteuse, il s’agit en fait de notre fréquence porteuse +/- ces N fréquences. Par exemple, nous pourrions être sur une porteuse de 1.2 GHz et nous déplacer entre ces quatre fréquences :</p>
<ol class="arabic simple">
<li>1.2005 GHz</li>
<li>1.2010 GHz</li>
<li>1.1995 GHz</li>
<li>1.1990 GHz</li>
</ol>
<p>L’exemple ci-dessus serait une 4-FSK, et il y aurait deux bits par symbole.  Un signal 4-FSK dans le domaine fréquenciel pourrait ressembler à ceci :</p>
<a class="reference external image-reference" href="../_images/fsk.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fsk.svg" class="align-center" src="../_images/fsk.svg" /></a>
<p>Si vous utilisez le FSK, vous devez vous poser une question essentielle: Quel doit être l’espacement entre les fréquences?  Nous désignons souvent cet espacement par <img class="math" src="../_images/math/32174248216c37ca883a89a6883863fa3225d71e.svg" alt="\Delta f"/> en Hz. Nous voulons éviter le chevauchement dans le domaine des fréquences, donc <img class="math" src="../_images/math/32174248216c37ca883a89a6883863fa3225d71e.svg" alt="\Delta f"/> doit être suffisamment grand.  La largeur de chaque porteuse en fréquence est fonction de notre débit de symboles.  Plus de symboles par seconde signifie des symboles plus courts, ce qui signifie une largeur de bande plus large (rappelez-vous la relation inverse entre l’échelle de temps et de fréquence).  Plus nous transmettons de symboles, plus chaque porteuse sera large, et par conséquent plus nous devrons augmenter <img class="math" src="../_images/math/32174248216c37ca883a89a6883863fa3225d71e.svg" alt="\Delta f"/> pour éviter le chevauchement des porteuses.  Nous n’entrerons pas dans les détails de la conception de la FSK dans ce manuel.</p>
<p>Les diagrammes IQ ne peuvent pas être utilisés pour montrer des fréquences différentes. Ils montrent la magnitude et la phase.  Bien qu’il soit possible de représenter la FSK dans le domaine temporel, il est difficile de distinguer les symboles s’il y a plus de deux fréquences :</p>
<a class="reference external image-reference" href="../_images/fsk2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fsk2.svg" class="align-center" src="../_images/fsk2.svg" /></a>
<p>En passant, notez que la radio FM utilise la modulation de fréquence (FM) qui est comme une version analogique de la FSK.  Au lieu d’avoir des fréquences discrètes entre lesquelles nous sautons, la radio FM utilise un signal audio continu pour moduler la fréquence de la porteuse.  Vous trouverez ci-dessous un exemple de modulation FM et AM où le “signal” en haut est le signal audio modulé sur la porteuse.</p>
<a class="reference external image-reference" href="../_images/Carrier_Mod_AM_FM.webp" rel="noopener noreferrer" target="_blank"><img alt="../_images/Carrier_Mod_AM_FM.webp" class="align-center" src="../_images/Carrier_Mod_AM_FM.webp" /></a>
<p>Dans ce manuel, nous nous intéressons principalement aux formes numériques de modulation.</p>
</div>
<div class="section" id="codage-differentiel">
<h2>Codage différentiel<a class="headerlink" href="#codage-differentiel" title="Permalink to this headline">¶</a></h2>
<p>Dans de nombreux protocoles de communication sans fil (et filaires), vous êtes susceptible de rencontrer ce que l’on appelle le codage différentiel.  Pour démontrer son utilité, considérons la réception d’un signal BPSK.  Lorsque le signal se déplace dans l’air, il subit un retard aléatoire entre l’émetteur et le récepteur, ce qui entraîne une rotation aléatoire de la constellation, comme nous l’avons mentionné précédemment.  Lorsque le récepteur se synchronise sur ce signal et aligne la BPSK sur l’axe “I”, il n’a aucun moyen de savoir si elle est déphasée de 180 degrés ou non, car la constellation a la même apparence.  Ainsi, au lieu de devoir envoyer des symboles pilotes pour lui faire savoir quelle groupe représente 1 et quelle groupe représente 0, il peut choisir d’utiliser le codage différentiel et ne pas s’en soucier. L’utilisation du codage différentiel nous permet également d’utiliser un récepteur non cohérent qui est plus simple que les récepteurs cohérents.</p>
<p>Dans sa forme la plus élémentaire, qui est celle utilisée pour la BPSK, le codage différentiel consiste à transmettre un 0 lorsque le bit d’entrée est le même que le bit de sortie précédent, et à transmettre un 1 lorsqu’ils diffèrent.  Nous transmettons donc toujours le même nombre de bits (sauf qu’un bit supplémentaire est nécessaire au début pour commencer la séquence de sortie), mais nous n’avons plus à nous soucier de l’ambiguïté de phase de 180 degrés.  Pour démontrer comment cela fonctionne, considérons la transmission de la séquence de bits [1, 1, 0, 0, 0, 1, 0] en utilisant la BPSK. Supposons que nous commencions la séquence de sortie par 1; en fait, peu importe que vous utilisiez 1 ou 0. Après avoir appliqué le codage différentiel, nous transmettrions finalement [1, 0, 1, 1, 1, 1, 0, 0].  Les 1 et les 0 sont toujours associés aux symboles positifs et négatifs dont nous avons parlé précédemment. Il est peut-être plus facile de visualiser les séquences d’entrée et de sortie empilées comme ceci:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]</span>   <span class="c1"># avant codage différentiel (données originales)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]</span>  <span class="c1"># après le codage différentiel (ce que nous transmettons)</span>
</pre></div>
</div>
<p>Le gros inconvénient de l’utilisation du codage différentiel est que si vous avez une erreur de bit, cela entraînera deux erreurs de bit.  L’alternative à l’utilisation du codage différentiel pour la BPSK est d’ajouter périodiquement des symboles pilotes, qui sont des symboles déjà connus du récepteur, et celui-ci peut utiliser les valeurs connues pour non seulement déterminer quel cluster est 1 et lequel est 0, mais aussi inverser les trajets multiples causés par le canal.  Un problème avec les symboles pilotes est que le canal sans fil peut changer très rapidement, de l’ordre de dizaines ou de centaines de symboles s’il s’agit d’un récepteur et/ou d’un émetteur en mouvement, de sorte qu’il faudrait des symboles pilotes suffisamment fréquents pour refléter l’évolution du canal.  Ainsi, si un protocole sans fil met l’accent sur la réduction de la complexité du récepteur, comme le RDS que nous étudions dans le chapitre <a class="reference internal" href="../content-nl/rds.html#rds-chapter"><span class="std std-ref">Compleet voorbeeld</span></a>, il peut choisir d’utiliser le codage différentiel.</p>
</div>
<div class="section" id="exemple-python">
<h2>Exemple Python<a class="headerlink" href="#exemple-python" title="Permalink to this headline">¶</a></h2>
<p>À titre d’exemple Python, générons une QPSK en bande de base et traçons la constellation.</p>
<p>Bien que nous puissions générer les symboles complexes directement, partons du principe que la QPSK possède quatre symboles à des intervalles de 90 degrés autour du cercle unitaire.  Nous utiliserons 45, 135, 225 et 315 degrés pour nos points.  Tout d’abord, nous allons générer des nombres aléatoires entre 0 et 3 et effectuer des calculs pour obtenir les degrés souhaités avant de les convertir en radians.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">num_symbols</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="n">x_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num_symbols</span><span class="p">)</span> <span class="c1"># 0 à 3</span>
<span class="n">x_degrees</span> <span class="o">=</span> <span class="n">x_int</span><span class="o">*</span><span class="mi">360</span><span class="o">/</span><span class="mf">4.0</span> <span class="o">+</span> <span class="mi">45</span> <span class="c1"># 45, 135, 225, 315 degrés</span>
<span class="n">x_radians</span> <span class="o">=</span> <span class="n">x_degrees</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span> <span class="c1"># sin() et cos() sont pris en radians</span>
<span class="n">x_symbols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x_radians</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x_radians</span><span class="p">)</span> <span class="c1"># ceci produit nos symboles complexes QPSK</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x_symbols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x_symbols</span><span class="p">),</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/qpsk_python.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/qpsk_python.svg" class="align-center" src="../_images/qpsk_python.svg" /></a>
<p>Observez comment tous les symboles que nous avons générés se chevauchent. Comme il n’y a pas de bruit, les symboles ont tous la même valeur. Ajoutons un peu de bruit:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_symbols</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_symbols</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># bruit addifitve blanc Gaussien avec une puissance unitaire</span>
<span class="n">noise_power</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">x_symbols</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/qpsk_python2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/qpsk_python2.svg" class="align-center" src="../_images/qpsk_python2.svg" /></a>
<p>Considérez comment le bruit blanc gaussien additif (ou AWGN en anglais pour <em>additive white Gaussian Noise</em>) produit un étalement uniforme autour de chaque point de la constellation.  S’il y a trop de bruit, les symboles commencent à passer la limite (les quatre quadrants) et seront interprétés par le récepteur comme un symbole incorrect.  Essayez d’augmenter <code class="code docutils literal notranslate"><span class="pre">noise_power</span></code> jusqu’à ce que cela se produise.</p>
<p>Pour ceux qui souhaitent simuler le bruit de phase, qui pourrait résulter de la gigue de phase dans l’oscillateur local (LO), remplacez le <code class="code docutils literal notranslate"><span class="pre">r</span></code> par :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">phase_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_symbols</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="c1"># ajuster le multiplicateur pour la &quot;force&quot; du bruit de phase</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">x_symbols</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase_noise</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/phase_jitter.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/phase_jitter.svg" class="align-center" src="../_images/phase_jitter.svg" /></a>
<p>Vous pourriez même combiner le bruit de phase avec l’AWGN pour obtenir l’expérience complète:</p>
<a class="reference external image-reference" href="../_images/phase_jitter_awgn.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/phase_jitter_awgn.svg" class="align-center" src="../_images/phase_jitter_awgn.svg" /></a>
<p>Nous allons nous arrêter à ce point.  Si nous voulions voir à quoi ressemble le signal QPSK dans le domaine temporel, nous devrions générer plusieurs échantillons par symbole (dans cet exercice, nous avons juste fait un échantillon par symbole). Vous apprendrez pourquoi vous devez générer plusieurs échantillons par symbole lorsque nous aborderons la mise en forme des impulsions.  L’exercice Python du chapitre <a class="reference internal" href="../content-nl/pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a> reprendra là où nous nous sommes arrêtés ici.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="sampling.html" title="Previous document"><span class="section-number">3. </span>échantillonnage IQ</a>
        </li>
        <li>
          <a href="pluto.html" title="Next document"><span class="section-number">5. </span>PlutoSDR en Python</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>