
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>15. Exemple bout en bout &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="16. A propos de l’auteur" href="about_author.html" />
    <link rel="prev" title="14. Synchronisation" href="sync.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<div style="float: right; padding-bottom: 0;">
  PySDR is now available in:&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/us.svg" alt="English Version" width="20"><a href="https://pysdr.org/index.html">English</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/nl.svg" alt="Dutch Version" width="20"><a href="https://pysdr.org/nl/index-nl.html">Dutch</a>&nbsp;&nbsp;
  <img src="https://pysdr.org/_static/fr.svg" alt="French Version" width="20"><a href="https://pysdr.org/fr/index-fr.html">French</a>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">15. Exemple bout en bout</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-a-la-radio-fm-et-au-rds">Introduction à la radio FM et au RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#le-signal-rds">Le signal RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#acquisition-d-un-signal">Acquisition d’un signal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#demodulation-fm">Démodulation FM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deplacement-de-frequence">Déplacement de fréquence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filtrer-pour-isoler-le-rds">Filtrer pour isoler le RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#decimer-par-10">Decimer par 10</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reechantillonnage-a-19-khz">Rééchantillonnage à 19 kHz</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filtre-passe-bande">Filtre passe-bande</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronisation-en-temps-niveau-symbole">Synchronisation en temps (niveau symbole)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronisation-fine-de-la-frequence">Synchronisation fine de la fréquence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#demoduler-le-bpsk">Démoduler le BPSK</a></li>
<li class="toctree-l2"><a class="reference internal" href="#decodage-differentiel">Décodage différentiel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#decodage-rds">Décodage RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#analyse-du-rds">Analyse du RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recapitulation-et-code-final">Récapitulation et code final</a></li>
<li class="toctree-l2"><a class="reference internal" href="#remerciements">Remerciements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aller-plus-loin">Aller plus loin</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="sync.html" title="previous chapter"><span class="section-number">14. </span>Synchronisation</a></li>
      <li>Next: <a href="about_author.html" title="next chapter"><span class="section-number">16. </span>A propos de l’auteur</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="sync.html" title="Previous document"><span class="section-number">14. </span>Synchronisation</a>
        </li>
        <li>
          <a href="about_author.html" title="Next document"><span class="section-number">16. </span>A propos de l’auteur</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="exemple-bout-en-bout">
<span id="rds-chapter"></span><h1><span class="section-number">15. </span>Exemple bout en bout<a class="headerlink" href="#exemple-bout-en-bout" title="Permalink to this headline">¶</a></h1>
<p>Dans ce chapitre, nous regroupons un grand nombre des concepts que nous avons appris précédemment et nous présentons un exemple complet de réception et de décodage d’un signal numérique réel.  Nous allons étudier le système de données radio (RDS pour <em>Radio Data System</em> en anglais), qui est un protocole de communication permettant d’intégrer de petites quantités d’informations dans les émissions de radio FM, comme le nom de la station et de la chanson.  Nous devrons démoduler la FM, décaler la fréquence, filtrer, décimer, rééchantillonner, synchroniser, décoder et analyser les octets.  Un exemple de fichier IQ est fourni à des fins de test ou si vous n’avez pas de SDR sous la main.</p>
<div class="section" id="introduction-a-la-radio-fm-et-au-rds">
<h2>Introduction à la radio FM et au RDS<a class="headerlink" href="#introduction-a-la-radio-fm-et-au-rds" title="Permalink to this headline">¶</a></h2>
<p>Pour comprendre le RDS, nous devons d’abord examiner les émissions de radio FM et la façon dont leurs signaux sont structurés.  Vous connaissez probablement la partie audio des signaux FM, qui sont simplement des signaux audio modulés en fréquence et transmis à des fréquences centrales correspondant au nom de la station, par exemple, “Sud Radio” est centré à exactement 101.8 MHz à Toulouse.  En plus de la partie audio, chaque émission FM contient d’autres composants qui sont modulés en fréquence en même temps que l’audio.  Au lieu de rechercher la structure du signal sur Google, examinons la densité spectrale de puissance (DSP) d’un exemple de signal FM, <em>après</em> la démodulation FM. Nous ne voyons que la partie positive car la sortie de la démodulation FM est un signal réel, même si l’entrée est complexe (nous verrons bientôt le code pour effectuer cette démodulation).</p>
<a class="reference external image-reference" href="../_images/fm_psd.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fm_psd.svg" class="align-center" src="../_images/fm_psd.svg" /></a>
<p>En regardant le signal dans le domaine de la fréquence, nous remarquons les signaux individuels suivants :</p>
<ol class="arabic simple">
<li>Un signal de forte puissance entre 0 - 17 kHz</li>
<li>Un signal sonore à 19 kHz</li>
<li>Centré à 38 kHz et d’une largeur d’environ 30 kHz, nous voyons un signal symétrique intéressant.</li>
<li>Signal en forme de double lobe centré à 57 kHz.</li>
<li>Signal en forme de lobe unique centré à 67 kHz.</li>
</ol>
<p>C’est essentiellement tout ce que nous sommes en mesure de déterminer en regardant la DSP, et rappelez-vous que c’est <em>après</em> la démodulation FM.  La DSP avant la démodulation FM ressemble à ce qui suit, ce qui ne nous dit pas grand-chose.</p>
<a class="reference external image-reference" href="../_images/fm_before_demod.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fm_before_demod.svg" class="align-center" src="../_images/fm_before_demod.svg" /></a>
<p>Ceci étant dit, il est important de comprendre que lorsque vous modulez un signal en FM, une fréquence plus élevée dans le signal de données entraînera une fréquence plus élevée dans le signal FM résultant.  Donc, ce signal centré à 67 kHz qui est présent augmente la largeur de bande totale occupée par le signal FM transmis, car la composante de fréquence maximale est maintenant autour de 75 kHz comme le montre le premier PSD ci-dessus.  La règle de la largeur de bande de <a class="reference external" href="https://fr.wikipedia.org/wiki/Règle_de_Carson" rel="noopener noreferrer" target="_blank">Carson</a> appliquée à la FM nous indique que les stations FM occupent environ 250 kHz du spectre, ce qui explique pourquoi nous échantillonnons généralement à 250 kHz (rappelez-vous que lorsque vous utilisez un échantillonnage en quadrature/IQ, votre largeur de bande reçue est égale à votre taux d’échantillonnage).</p>
<p>En guise d’aparté, certains lecteurs ont peut-être l’habitude d’observer la bande FM à l’aide d’une SDR ou d’un analyseur de spectre et de voir le spectrogramme suivant, et de penser que les signaux en forme de blocs adjacents à certaines des stations FM sont des données RDS.</p>
<a class="reference internal image-reference" href="../_images/fm_band_psd.png"><img alt="../_images/fm_band_psd.png" class="align-center" src="../_images/fm_band_psd.png" style="width: 696.8000000000001px; height: 201.60000000000002px;" /></a>
<p>Il s’avère que ces signaux en forme de blocs sont en fait la Radio HD, une version numérique du même signal radio FM (même contenu audio).  Cette version numérique permet d’obtenir un signal audio de meilleure qualité au niveau du récepteur car la FM analogique comprendra toujours un certain bruit après démodulation, puisqu’il s’agit d’un schéma analogique, mais le signal numérique peut être démodulé/décodé avec un bruit nul, en supposant qu’il n’y ait aucune erreur de bit.</p>
<p>Revenons aux cinq signaux que nous avons découverts dans notre DSP; le diagramme suivant indique à quoi sert chaque signal.</p>
<a class="reference internal image-reference" href="../_images/fm_components.png"><img alt="../_images/fm_components.png" class="align-center" src="../_images/fm_components.png" style="width: 625.6px; height: 380.8px;" /></a>
<p>Je passe en revue chacun de ces signaux sans ordre particulier:</p>
<p>Les signaux audio mono et stéréo transportent simplement le signal audio, dans un schéma où leur addition et leur soustraction vous donnent les canaux gauche et droit.</p>
<p>La tonalité pilote de 19 kHz est utilisée pour démoduler le signal audio stéréo.  Si vous doublez la tonalité, elle sert de référence de fréquence et de phase, puisque le signal audio stéréo est centré à 38 kHz.  Doubler la tonalité peut être fait en élevant simplement les échantillons au carré, en se rappelant la propriété de Fourier de décalage de fréquence que nous avons apprise dans le chapitre <a class="reference internal" href="../content-nl/frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Het Frequentiedomein</span></a>.</p>
<p>DirectBand était un réseau de diffusion de données sans fil en Amérique du Nord, détenu et exploité par Microsoft, également appelé “MSN Direct” sur les marchés grand public. DirectBand transmettait des informations à des appareils tels que des récepteurs GPS portables, des montres-bracelets et des stations météorologiques domestiques.  Il permettait même aux utilisateurs de recevoir des messages courts de Windows Live Messenger.  L’une des applications les plus réussies de DirectBand était l’affichage en temps réel de données sur le trafic local sur les récepteurs GPS Garmin, qui étaient utilisés par des millions de personnes avant que les smartphones ne deviennent omniprésents.  Le service DirectBand a été fermé en janvier 2012, ce qui soulève la question suivante: pourquoi le voit-on dans nos signaux FM enregistrés après 2012?  Ma seule hypothèse est que la plupart des émetteurs FM ont été conçus et construits bien avant 2012, et que même sans “alimentation” DirectBand active, ils transmettent toujours quelque chose, peut-être des symboles de pilotage.</p>
<p>Enfin, nous en arrivons au RDS, qui est l’objet du reste de ce chapitre.  Comme nous pouvons le voir dans notre premier PSD, le RDS a une largeur de bande d’environ 4 kHz (avant d’être modulé en FM), et se situe entre le signal audio stéréo et le signal DirectBand.  Il s’agit d’un protocole de communication numérique à faible débit de données qui permet aux stations FM d’inclure l’identification de la station, des informations sur le programme, l’heure et d’autres informations diverses à côté du signal audio.  La norme RDS est publiée sous le nom de norme IEC 62106 et peut être trouvée <a class="reference external" href="http://www.interactive-radio-system.com/docs/EN50067_RDS_Standard.pdf" rel="noopener noreferrer" target="_blank">ici</a>.</p>
</div>
<div class="section" id="le-signal-rds">
<h2>Le signal RDS<a class="headerlink" href="#le-signal-rds" title="Permalink to this headline">¶</a></h2>
<p>Dans ce chapitre, nous allons utiliser Python pour recevoir RDS, mais pour mieux comprendre comment le recevoir, nous devons d’abord apprendre comment le signal est formé et transmis.</p>
<div class="section" id="cote-emission">
<h3>Côté émission<a class="headerlink" href="#cote-emission" title="Permalink to this headline">¶</a></h3>
<p>Les informations RDS à transmettre par la station FM (par exemple, le nom de la piste, etc.) sont codées en jeux de 8 octets.  Chaque ensemble de 8 octets, qui correspond à 64 bits, est combiné à 40 “bits de contrôle” pour former un seul “groupe”.  Ces 104 bits sont transmis ensemble, mais il n’y a pas d’intervalle de temps entre les groupes. Ainsi, du point de vue du récepteur, il reçoit ces bits sans interruption et doit déterminer la limite entre les groupes de 104 bits. Nous verrons plus de détails sur le codage et la structure du message lorsque nous nous plongerons dans la partie réception.</p>
<p>Pour transmettre ces bits sans fil, le RDS utilise la modulation par déplacement de phase (BPSK), qui, comme nous l’avons appris dans le chapitre <a class="reference internal" href="digital_modulation.html#modulation-chapitre"><span class="std std-ref">Modulation numérique</span></a>, est un schéma de modulation numérique simple utilisé pour associer des 1 et des 0 à la phase d’une porteuse.  Comme de nombreux protocoles basés sur la BPSK, le RDS utilise le codage différentiel, ce qui signifie simplement que les 1 et les 0 des données sont codés dans les changements de 1 et de 0, ce qui vous permet de ne plus vous soucier de savoir si vous êtes déphasé de 180 degrés (nous y reviendrons plus tard).  Les symboles BPSK sont transmis à 1187,5 symboles par seconde, et comme la BPSK transporte un bit par symbole, cela signifie que le RDS a un débit de données brut d’environ 1,2 kbps (y compris l’overhead). Le RDS ne contient aucun codage de canal (ou correction d’erreur), bien que les paquets de données contiennent un contrôle de redondance cyclique (CRC) pour savoir si une erreur s’est produite. L’utilisateur expérimenté de la BPSK peut se demander pourquoi nous avons vu un signal en forme de double lobe dans la première DSP; la BPSK a généralement un lobe principal.  Il s’avère que RDS prend le signal BPSK et le duplique sur la fréquence centrale de 57 kHz, pour plus de robustesse.  Lorsque nous nous plongerons dans le code Python utilisé pour recevoir le RDS, l’une de nos étapes consistera à filtrer pour isoler un seul de ces signaux BPSK.</p>
<p>Le signal final “double BPSK” est ensuite décalé en fréquence jusqu’à 57 kHz et ajouté à toutes les autres composantes du signal FM, avant d’être modulé en FM et transmis sur les ondes à la fréquence de la station.  Les signaux radio FM sont transmis à une puissance extrêmement élevée par rapport à la plupart des autres communications sans fil, jusqu’à 80 kW!  C’est pourquoi de nombreux utilisateurs de la radio logicielle ont un filtre de rejet de la FM (c’est-à-dire un filtre coupe-bande) avec leur antenne, afin que la FM n’ajoute pas d’interférences à ce qu’ils essaient de recevoir.</p>
<p>Il ne s’agissait là que d’un bref aperçu de l’aspect transmission, mais nous entrerons dans les détails lorsque nous aborderons la réception du RDS.</p>
</div>
<div class="section" id="cote-recepteur">
<h3>Côté récepteur<a class="headerlink" href="#cote-recepteur" title="Permalink to this headline">¶</a></h3>
<p>Afin de démoduler et de décoder le RDS, nous allons effectuer les étapes suivantes, dont beaucoup sont des étapes de transmission en sens inverse (pas besoin de mémoriser cette liste, nous allons parcourir chaque étape individuellement ci-dessous):</p>
<ol class="arabic simple">
<li>Recevoir un signal radio FM centré sur la fréquence de la station (ou lu dans un enregistrement IQ), généralement à une fréquence d’échantillonnage de 250 kHz</li>
<li>Démodulez la FM en utilisant ce qu’on appelle la “démodulation en quadrature”.</li>
<li>Décalage de fréquence de 57 kHz pour que le signal RDS soit centré à 0 Hz.</li>
<li>Filtre passe-bas, pour filtrer tout ce qui n’est pas RDS.</li>
<li>Décimation par 10 pour pouvoir travailler à un taux d’échantillonnage plus faible, puisque nous avons de toute façon filtré les hautes fréquences.</li>
<li>Rééchantillonnage à 19 kHz, ce qui nous donnera un nombre entier d’échantillons par symbole.</li>
<li>Isolez l’un des deux signaux RDS BPSK avec un filtre passe-bande.</li>
<li>Synchronisation temporelle au niveau du symbole, en utilisant Mueller et Muller dans cet exemple.</li>
<li>Synchronisation fine de la fréquence en utilisant une boucle de Costas</li>
<li>Démodulation du BPSK en 1 et 0.</li>
<li>Décodage différentiel, pour annuler l’encodage différentiel qui a été appliqué.</li>
<li>Décodage des 1 et 0 en groupes d’octets.</li>
<li>Analyse des groupes d’octets dans notre sortie finale.</li>
</ol>
<p>Bien que cela puisse sembler beaucoup d’étapes, RDS est en fait l’un des protocoles de communication numérique sans fil les plus simples qui soient. Un protocole sans fil moderne comme le WiFi ou la 5G nécessite un manuel entier pour couvrir uniquement les informations de haut niveau de la couche PHY/MAC.</p>
<p>Nous allons maintenant nous plonger dans le code Python utilisé pour recevoir le RDS.  Ce code a été testé pour fonctionner en utilisant un enregistrement radio FM que vous pouvez trouver <a class="reference external" href="https://github.com/777arc/498x/blob/master/fm_rds_250k_1Msamples.iq?raw=true" rel="noopener noreferrer" target="_blank">ici</a>, bien que vous devriez être en mesure d’introduire votre propre signal tant qu’il est reçu à un SNR assez élevé, il suffit de régler la fréquence centrale de la station et d’échantillonner à un taux de 250 kHz.  Dans cette section, nous présenterons de petites portions du code individuellement, avec une discussion, mais le même code est fourni à la fin de ce chapitre en un grand bloc. Chaque section présentera un bloc de code, puis expliquera ce qu’il fait.</p>
</div>
</div>
<div class="section" id="acquisition-d-un-signal">
<h2>Acquisition d’un signal<a class="headerlink" href="#acquisition-d-un-signal" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">resample_poly</span><span class="p">,</span> <span class="n">firwin</span><span class="p">,</span> <span class="n">bilinear</span><span class="p">,</span> <span class="n">lfilter</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Lire le signal</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;/home/marc/Downloads/fm_rds_250k_1Msamples.iq&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">250e3</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">99.5e6</span>
</pre></div>
</div>
<p>Nous avons lu notre enregistrement de test, qui a été échantillonné à 250 kHz et centré sur une station FM reçue à un SNR élevé.  Veillez à mettre à jour le chemin du fichier pour refléter votre système et l’endroit où vous avez sauvegardé l’enregistrement.  Si vous avez un SDR déjà configuré et fonctionnant depuis Python, n’hésitez pas à recevoir un signal en direct, bien qu’il soit utile d’avoir d’abord testé l’ensemble du code avec un <a class="reference external" href="https://github.com/777arc/498x/blob/master/fm_rds_250k_1Msamples.iq?raw=true" rel="noopener noreferrer" target="_blank">enregistrement de QI connu pour fonctionner</a>.  Tout au long de ce code, nous utiliserons <code class="code docutils literal notranslate"><span class="pre">x</span></code> pour stocker le signal à manipuler.</p>
</div>
<div class="section" id="demodulation-fm">
<h2>Démodulation FM<a class="headerlink" href="#demodulation-fm" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Démodulation en quadrature</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="c1"># see https://wiki.gnuradio.org/index.php/Quadrature_Demod</span>
</pre></div>
</div>
<p>Comme nous l’avons vu au début de ce chapitre, plusieurs signaux individuels sont combinés en fréquence et modulés en FM pour créer ce qui est réellement transmis dans l’air.  La première étape consiste donc à annuler cette modulation FM.  Une autre façon de voir les choses est que l’information est stockée dans la variation de fréquence du signal que nous recevons, et nous voulons le démoduler pour que l’information soit maintenant dans l’amplitude et non dans la fréquence.  Notez que la sortie de cette démodulation est un signal réel, même si nous avons introduit un signal complexe.</p>
<p>Ce que fait cette simple ligne de Python, c’est d’abord calculer le produit de notre signal avec une version retardée et conjuguée de notre signal.  Ensuite, elle trouve la phase de chaque échantillon dans ce résultat, qui est le moment où il passe de complexe à réel. Pour nous prouver que cela nous donne l’information contenue dans les variations de fréquence, considérons un son à la fréquence <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> avec une phase arbitraire <img class="math" src="../_images/math/f41d2a61cd1827c3e57537176609abab588ccc27.svg" alt="\phi"/>, que nous pouvons représenter comme <img class="math" src="../_images/math/aeac5aa1d2208522259f5d0cd24b363631ecce9a.svg" alt="e^{j2 \pi (f t + \phi)}"/>. En temps discret, on utilise un entier <img class="math" src="../_images/math/f7a9f3c7a45b9df2dac17c2a197dd82e66e4a44a.svg" alt="n"/> au lieu de <img class="math" src="../_images/math/de24e9d9b4f685051e7f51c8931d4f7f53a37457.svg" alt="t"/>, cela devient <img class="math" src="../_images/math/607c18b46862d6504e95efda4552d5a4a9346485.svg" alt="e^{j2 \pi (f n + \phi)}"/>.  La version conjuguée et retardée est <img class="math" src="../_images/math/ed969a9f9a6f32e3a84981843e060acfd3d09bea.svg" alt="e^{-j2 \pi (f (n-1) + \phi)}"/>.  En multipliant les deux, on obtient <img class="math" src="../_images/math/4c10af995bdc4051fc71891f029058db0b888e64.svg" alt="e^{j2 \pi f}"/>, ce qui est génial car <img class="math" src="../_images/math/f41d2a61cd1827c3e57537176609abab588ccc27.svg" alt="\phi"/> a disparu, et quand on calcule la phase de cette expression, il ne reste que <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/>.</p>
<p>Un effet secondaire pratique de la modulation FM est que les variations d’amplitude du signal reçu ne modifient pas réellement le volume de l’audio, contrairement à la radio AM.</p>
</div>
<div class="section" id="deplacement-de-frequence">
<h2>Déplacement de fréquence<a class="headerlink" href="#deplacement-de-frequence" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># décalage de freq</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">f_o</span> <span class="o">=</span> <span class="o">-</span><span class="mf">57e3</span> <span class="c1"># valeur du décalage</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># vecteur de temps</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f_o</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># décalage de freq</span>
</pre></div>
</div>
<p>Ensuite, nous décalons la fréquence de 57 kHz vers le bas, en utilisant l’astuce <img class="math" src="../_images/math/75b1957b6af6705b15dad8edeed42a40232645cb.svg" alt="e^{j2 \pi f_ot}"/> que nous avons apprise dans le chapitre <a class="reference internal" href="../content-nl/sync.html#sync-chapter"><span class="std std-ref">Synchronisatie</span></a> où <code class="code docutils literal notranslate"><span class="pre">f_o</span></code> est le décalage de fréquence en Hz et <code class="code docutils literal notranslate"><span class="pre">t</span></code> est juste un vecteur temps, le fait qu’il commence à 0 n’est pas important, ce qui compte c’est qu’il utilise la bonne période d’échantillonnage (qui est l’inverse du taux d’échantillonnage).  Par ailleurs, comme il s’agit d’un signal réel, il n’est pas important d’utiliser une fréquence de -57 ou +57 kHz car les fréquences négatives correspondent aux positives, donc dans tous les cas, notre RDS sera décalé à 0 Hz.</p>
</div>
<div class="section" id="filtrer-pour-isoler-le-rds">
<h2>Filtrer pour isoler le RDS<a class="headerlink" href="#filtrer-pour-isoler-le-rds" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># filtre passe bas</span>
<span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">7.5e3</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Maintenant, nous devons filtrer tout ce qui n’est pas RDS. Puisque nous avons un RDS centré à 0 Hz, cela signifie qu’un filtre passe-bas est celui que nous voulons.  Nous utilisons <code class="code docutils literal notranslate"><span class="pre">firwin()</span></code> pour concevoir un filtre FIR (c’est-à-dire, trouver les taps), qui a juste besoin de savoir combien de taps nous voulons pour le filtre, et la fréquence de coupure.  La fréquence d’échantillonnage doit également être fournie, sinon la fréquence de coupure n’a pas de sens pour firwin.  Le résultat est un filtre passe-bas symétrique, donc nous savons que les taps seront des nombres réels, et nous pouvons appliquer le filtre à notre signal en utilisant une convolution. Nous choisissons <code class="code docutils literal notranslate"><span class="pre">'valid'</span></code> pour nous débarrasser des effets de bord de la convolution, bien que dans ce cas, cela n’ait pas vraiment d’importance parce que nous introduisons un signal si long que quelques échantillons bizarres sur l’un ou l’autre des bords ne vont rien gâcher.</p>
</div>
<div class="section" id="decimer-par-10">
<h2>Decimer par 10<a class="headerlink" href="#decimer-par-10" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Décimer par 10, maintenant que nous avons filtré et qu&#39;il n&#39;y aura pas de repliement.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="mi">10</span><span class="p">]</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">25e3</span>
</pre></div>
</div>
<p>Chaque fois que vous filtrez jusqu’à une petite fraction de votre bande passante (par exemple, nous avons commencé avec 125 kHz de bande passante <em>réelle</em> et n’avons sauvegardé que 7.5 kHz de celle-ci), il est logique de décimer.  Rappelez-vous le début du chapitre <a class="reference internal" href="../content-nl/sampling.html#sampling-chapter"><span class="std std-ref">IQ-sampling</span></a> où nous avons appris le taux de Nyquist et la possibilité de stocker entièrement des informations à bande limitée tant que nous échantillonnions à deux fois la fréquence la plus élevée. Maintenant que nous avons utilisé notre filtre passe-bas, notre fréquence la plus élevée est d’environ 7.5 kHz, donc nous n’avons besoin que d’une fréquence d’échantillonnage de 15 kHz.  Par sécurité, nous allons ajouter un peu de marge et utiliser une nouvelle fréquence d’échantillonnage de 25 kHz (ce qui s’avère être une bonne solution mathématique par la suite).</p>
<p>Nous effectuons la décimation en éliminant simplement 9 échantillons sur 10, puisque nous étions précédemment à un taux d’échantillonnage de 250 kHz et que nous voulons qu’il soit maintenant à 25 kHz.  Cela peut sembler déroutant au premier abord, car en éliminant 90% des échantillons, on a l’impression de perdre de l’information, mais si vous relisez le chapitre <a class="reference internal" href="../content-nl/sampling.html#sampling-chapter"><span class="std std-ref">IQ-sampling</span></a>, vous verrez pourquoi nous ne perdons rien en fait, car nous avons filtré correctement (ce qui a agi comme notre filtre anti-repliement) et réduit notre fréquence maximale et donc la largeur de bande du signal.</p>
<p>Du point de vue du code, c’est probablement l’étape la plus simple de toutes, mais assurez-vous de mettre à jour votre variable <code class="code docutils literal notranslate"><span class="pre">sample_rate</span></code> pour refléter le nouveau taux d’échantillonnage.</p>
</div>
<div class="section" id="reechantillonnage-a-19-khz">
<h2>Rééchantillonnage à 19 kHz<a class="headerlink" href="#reechantillonnage-a-19-khz" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Rééchantillonnage à 19 kHz</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="c1"># up, down</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">19e3</span>
</pre></div>
</div>
<p>Dans le chapitre <a class="reference internal" href="../content-nl/pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Pulse Shaping</span></a> nous avons solidifié le concept “d’échantillons par symbole”, et appris la commodité d’avoir un nombre entier d’échantillons par symbole (une valeur fractionnaire est valide, mais pas pratique). Comme nous l’avons mentionné précédemment, le RDS utilise une BPSK transmettant 1187.5 symboles par seconde.  Si nous continuons à utiliser notre signal tel quel, échantillonné à 25 kHz, nous aurons 21.052631579 échantillons par symbole (faites une pause et réfléchissez au calcul si cela n’a pas de sens).  Ce que nous voulons vraiment, c’est une fréquence d’échantillonnage qui soit un multiple entier de 1187.5 Hz, mais nous ne pouvons pas aller trop bas ou nous ne serons pas en mesure de “stocker” toute la largeur de bande de notre signal. Dans la sous-section précédente, nous avons expliqué que nous avions besoin d’une fréquence d’échantillonnage de 15 kHz ou plus, et nous avons choisi 25 kHz juste pour nous donner une certaine marge.</p>
<p>Trouver la meilleure fréquence d’échantillonnage pour rééchantillonner se résume à savoir combien d’échantillons par symbole nous voulons.  Hypothétiquement, envisageons de viser 10 échantillons par symbole.  Le taux de symbole RDS de 1187.5 multiplié par 10 nous donnerait un taux d’échantillonnage de 11.875 kHz, ce qui n’est malheureusement pas assez élevé pour Nyquist. Que diriez-vous de 13 échantillons par symbole? 1187.5 multiplié par 13 nous donne 15437.5 Hz, ce qui est supérieur à 15 kHz, mais un nombre assez inégal.  Que diriez-vous de la puissance de 2 suivante, soit 16 échantillons par symbole? 1187.5 multiplié par 16 est exactement 19 kHz! Le nombre pair est moins une coïncidence qu’un choix de conception du protocole.</p>
<p>Pour rééchantillonner de 25 kHz à 19 kHz, nous utilisons <code class="code docutils literal notranslate"><span class="pre">resample_poly()</span></code> qui suréchantillonne par une valeur entière, filtre, puis sous-échantillonne par une valeur entière.  C’est pratique car au lieu d’entrer 25000 et 19000, nous pouvons utiliser 25 et 19.  Si nous avions utilisé 13 échantillons par symbole en utilisant une fréquence d’échantillonnage de 15437.5 Hz, nous ne pourrions pas utiliser <code class="code docutils literal notranslate"><span class="pre">resample_poly()</span></code> et le processus de rééchantillonnage serait beaucoup plus compliqué.</p>
<p>Encore une fois, n’oubliez jamais de mettre à jour votre variable <code class="code docutils literal notranslate"><span class="pre">sample_rate</span></code> lorsque vous effectuez une opération qui la modifie.</p>
</div>
<div class="section" id="filtre-passe-bande">
<h2>Filtre passe-bande<a class="headerlink" href="#filtre-passe-bande" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Filtre passe-bande pour isoler un signal RDS BPSK</span>
<span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="mi">501</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="p">[</span><span class="mf">0.05e3</span><span class="p">,</span> <span class="mf">2e3</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Rappelons que le RDS contient deux signaux BPSK identiques, d’où la forme que nous avons vue dans la PSD au début. Nous devons en choisir un, donc nous allons arbitrairement décider de garder le positif avec un filtre passe-bande. Nous utilisons <code class="code docutils literal notranslate"><span class="pre">firwin()</span></code> à nouveau, mais notez le <code class="code docutils literal notranslate"><span class="pre">pass_zero=False</span></code> qui indique que vous voulez un filtre passe-bande plutôt qu’un filtre passe-bas, et il y a deux fréquences de coupure pour définir la bande. Le signal s’étend approximativement de 0 Hz à 2 kHz mais vous ne pouvez pas spécifier une fréquence de départ de 0 Hz donc nous utilisons 0.05 kHz.  Enfin, nous devons augmenter le nombre de taps, pour obtenir une réponse en fréquence plus abrupte.  Nous pouvons vérifier que ces chiffres ont fonctionné en examinant notre filtre dans le domaine temporel (en traçant les taps) et dans le domaine fréquentiel (en prenant la FFT des taps).  Notez comment dans le domaine fréquentiel, nous atteignons une réponse proche de zéro à environ 0 Hz.</p>
<a class="reference external image-reference" href="../_images/bandpass_filter_taps.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/bandpass_filter_taps.svg" class="align-center" src="../_images/bandpass_filter_taps.svg" /></a>
<a class="reference external image-reference" href="../_images/bandpass_filter_freq.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/bandpass_filter_freq.svg" class="align-center" src="../_images/bandpass_filter_freq.svg" /></a>
<p>Remarque: à un moment ou à un autre, je mettrai à jour le filtre ci-dessus pour utiliser un filtre adapté (le root-raised cosine, je crois que c’est ce que RDS utilise), pour des raisons conceptuelles, mais j’ai obtenu les mêmes taux d’erreur en utilisant l’approche firwin() que le filtre adapté de GNU Radio, donc ce n’est clairement pas une exigence stricte.</p>
</div>
<div class="section" id="synchronisation-en-temps-niveau-symbole">
<h2>Synchronisation en temps (niveau symbole)<a class="headerlink" href="#synchronisation-en-temps-niveau-symbole" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Synchronisation des symboles, en utilisant ce que nous avons fait dans le chapitre sur la synchronisation.</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># comme dans le chapitre de la synchronisation</span>
<span class="n">samples_interpolated</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># Nous utiliserons 32 comme facteur d&#39;interpolation, choisi arbitrairement.</span>
<span class="n">sps</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># estimation initiale de la phase de l&#39;échantillon</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">out_rail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span> <span class="c1"># stocke les valeurs, à chaque itération nous avons besoin des 2 valeurs précédentes plus la valeur actuelle.</span>
<span class="n">i_in</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># index des échantillons d&#39;entrée</span>
<span class="n">i_out</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># indice de sortie (les deux premières sorties sont 0)</span>
<span class="k">while</span> <span class="n">i_out</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i_in</span><span class="o">+</span><span class="mi">32</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_interpolated</span><span class="p">[</span><span class="n">i_in</span><span class="o">*</span><span class="mi">32</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="mi">32</span><span class="p">)]</span> <span class="c1"># prendre ce que nous pensons être le &quot;meilleur&quot; échantillon</span>
    <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">+=</span> <span class="n">sps</span> <span class="o">+</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">mm_val</span>
    <span class="n">i_in</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="c1"># arrondir à l&#39;entier le plus proche puisque nous l&#39;utilisons comme un index</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="c1"># supprimer la partie entière de mu</span>
    <span class="n">i_out</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># incrémenter l&#39;indice de sortie</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">i_out</span><span class="p">]</span> <span class="c1"># supprimer les deux premiers, et tout ce qui suit i_out (qui n&#39;a jamais été rempli)</span>
</pre></div>
</div>
<p>Nous sommes enfin prêts pour notre synchronisation temps symbole, ici nous utiliserons exactement le même code de synchronisation de Mueller et Muller du chapitre <a class="reference internal" href="../content-nl/sync.html#sync-chapter"><span class="std std-ref">Synchronisatie</span></a>, rendez-vous y si vous voulez en savoir plus sur son fonctionnement.  Nous avons fixé l’échantillon par symbole (<code class="code docutils literal notranslate"><span class="pre">sps</span></code>) à 16 comme discuté précédemment. Une valeur de gain de 0.01 a été trouvée par expérimentation pour fonctionner correctement. La sortie devrait maintenant être un échantillon par symbole, c’est-à-dire que notre sortie est nos “symboles souples”, avec un éventuel décalage de fréquence inclus.  L’animation suivante de la constellation est utilisée pour vérifier que nous obtenons des symboles BPSK (avec un décalage de fréquence provoquant une rotation) :</p>
<a class="reference internal image-reference" href="../_images/constellation-animated.gif"><img alt="../_images/constellation-animated.gif" class="align-center" src="../_images/constellation-animated.gif" style="width: 409.6px; height: 307.20000000000005px;" /></a>
<p>Si vous utilisez votre propre signal FM et que vous n’obtenez pas deux groupes distincts d’échantillons complexes à ce stade, cela signifie que la synchronisation du symbole ci-dessus n’a pas réussi à atteindre la synchronisation, ou qu’il y a un problème avec l’une des étapes précédentes. Vous n’avez pas besoin d’animer la constellation, mais si vous la tracez, veillez à ne pas tracer tous les échantillons, car cela ressemblera à un cercle. Si vous ne tracez que 100 ou 200 échantillons à la fois, vous aurez une meilleure idée de la présence ou non de deux groupes de points, même si elles tournent.</p>
</div>
<div class="section" id="synchronisation-fine-de-la-frequence">
<h2>Synchronisation fine de la fréquence<a class="headerlink" href="#synchronisation-fine-de-la-frequence" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Synchronisation fine de la fréquence</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># comme dans le chapitre de la synchro</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Ces deux paramètres suivants sont ce qu&#39;il faut ajuster, pour rendre la boucle de rétroaction plus rapide ou plus lente (ce qui a un impact sur la stabilité).</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">8.0</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.002</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">freq_log</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="c1"># ajuster l&#39;échantillon d&#39;entrée par l&#39;inverse du décalage de phase estimé</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># Voici la formule d&#39;erreur pour une boucle de Costas de 2ème ordre (par exemple pour BPSK)</span>

    <span class="c1"># Avancer la boucle (recalculer la phase et le décalage de fréquence)</span>
    <span class="n">freq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">freq_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="c1"># convertir de la vitesse angulaire en Hz pour les logs</span>
    <span class="n">phase</span> <span class="o">+=</span> <span class="n">freq</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>

    <span class="c1"># Facultatif : Ajustez la phase pour qu&#39;elle soit toujours comprise entre 0 et 2pi, rappelez-vous que la phase tourne autour 2pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">out</span>
</pre></div>
</div>
<p>Nous allons également copier le code Python de synchronisation fine de fréquence du chapitre <a class="reference internal" href="../content-nl/sync.html#sync-chapter"><span class="std std-ref">Synchronisatie</span></a>, qui utilise une boucle de Costas pour supprimer tout décalage de fréquence résiduel, ainsi que pour aligner notre BPSK sur l’axe réel (I), en forçant Q à être aussi proche de zéro que possible. Tout ce qui reste dans Q est probablement dû au bruit du signal, en supposant que la boucle de Costas a été réglée correctement. Juste pour le plaisir, regardons la même animation que ci-dessus, mais après que la synchronisation de fréquence ait été effectuée (plus de rotation !) :</p>
<a class="reference internal image-reference" href="../_images/constellation-animated-postcostas.gif"><img alt="../_images/constellation-animated-postcostas.gif" class="align-center" src="../_images/constellation-animated-postcostas.gif" style="width: 409.6px; height: 307.20000000000005px;" /></a>
<p>De plus, nous pouvons regarder l’erreur de fréquence estimée dans le temps pour voir le fonctionnement de la boucle de Costas, notez comment nous l’avons enregistrée dans le code ci-dessus. Il semble qu’il y avait environ 13 Hz de décalage de fréquence, soit à cause de l’oscillateur local (LO) de l’émetteur qui était éteint, soit à cause de l’OL du récepteur (plus probablement le récepteur).  Si vous utilisez votre propre signal FM, vous devrez peut-être modifier <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> et <code class="code docutils literal notranslate"><span class="pre">beta</span></code> jusqu’à ce que la courbe soit similaire, elle devrait atteindre la synchronisation assez rapidement (par exemple, quelques centaines de symboles) et la maintenir avec un minimum d’oscillations. Le modèle que vous voyez ci-dessous après qu’il ait trouvé son état stable est une gigue de fréquence, pas une oscillation.</p>
<a class="reference internal image-reference" href="../_images/freq_error.png"><img alt="../_images/freq_error.png" class="align-center" src="../_images/freq_error.png" style="width: 442.0px; height: 292.40000000000003px;" /></a>
</div>
<div class="section" id="demoduler-le-bpsk">
<h2>Démoduler le BPSK<a class="headerlink" href="#demoduler-le-bpsk" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Demodulation BPSK</span>
<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># 1s et 0s</span>
</pre></div>
</div>
<p>La démodulation du BPSK à ce stade est très facile, rappelez-vous que chaque échantillon représente un symbole souple, donc tout ce que nous avons à faire est de vérifier si chaque échantillon est au-dessus ou au-dessous de 0. Le <code class="code docutils literal notranslate"><span class="pre">.astype(int)</span></code> est juste pour que nous puissions travailler avec un tableau d’entiers au lieu d’un tableau de booléens. Vous pouvez vous demander si au-dessus ou au-dessous de zéro représente un 1 ou un 0. Comme vous le verrez à l’étape suivante, cela n’a pas d’importance!</p>
</div>
<div class="section" id="decodage-differentiel">
<h2>Décodage différentiel<a class="headerlink" href="#decodage-differentiel" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Décodage différentiel, de sorte qu&#39;il importe peu que notre BPSK ait subi une rotation de 180 degrés sans que nous nous en rendions compte.</span>
<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="c1"># decodage</span>
</pre></div>
</div>
<p>Le signal BPSK a utilisé un codage différentiel lors de sa création, ce qui signifie que chaque 1 et 0 des données d’origine a été transformé de telle sorte qu’un changement de 1 à 0 ou de 0 à 1 a été mis en correspondance avec un 1, et aucun changement n’a été mis en correspondance avec un 0.  L’avantage de l’utilisation du codage différentiel est que vous n’avez pas à vous soucier des rotations de 180 degrés lors de la réception de la BPSK, car le fait que nous considérions qu’un 1 est supérieur ou inférieur à zéro n’a plus d’impact, ce qui compte c’est le changement entre 1 et 0. Ce concept peut être plus facile à comprendre en regardant un exemple de données, ci-dessous les 10 premiers symboles avant et après le décodage différentiel :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># avant le décodage différentiel</span>
<span class="p">[</span><span class="o">-</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># après le décodage différentiel</span>
</pre></div>
</div>
</div>
<div class="section" id="decodage-rds">
<h2>Décodage RDS<a class="headerlink" href="#decodage-rds" title="Permalink to this headline">¶</a></h2>
<p>Nous avons enfin nos bits d’information, et nous sommes prêts à décoder leur signification! L’énorme bloc de code fourni ci-dessous est ce que nous allons utiliser pour décoder les 1 et les 0 en groupes d’octets. Cette partie aurait beaucoup plus de sens si nous avions d’abord créé la partie émetteur du RDS, mais pour l’instant, sachez simplement qu’en RDS, les octets sont regroupés en groupes de 12 octets, où les 8 premiers représentent les données et les 4 derniers servent de mot de synchronisation (appelés “mots de décalage”). Les 4 derniers octets ne sont pas nécessaires à l’étape suivante (l’analyseur syntaxique), nous ne les incluons donc pas dans la sortie. Ce bloc de code prend les 1 et 0 créés ci-dessus (sous la forme d’un tableau 1D d’uint8) et produit une liste de listes d’octets (une liste de 8 octets où ces 8 octets sont dans une liste). Ceci est pratique pour l’étape suivante, qui va itérer à travers la liste de 8 octets, un groupe de 8 à la fois.</p>
<p>La plupart du code de décodage ci-dessous tourne autour de la synchronisation (au niveau de l’octet, pas du symbole) et de la vérification des erreurs.  Il fonctionne par blocs de 104 bits, chaque bloc est soit reçu correctement soit en erreur (en utilisant le CRC pour vérifier), et tous les 50 blocs il vérifie si plus de 35 d’entre eux ont été reçus avec une erreur, auquel cas il réinitialise tout et tente de se synchroniser à nouveau. Le CRC est effectué en utilisant une vérification sur 10 bits, avec le polynôme <img class="math" src="../_images/math/721b9d55493e992ca626c983d273b567a24c1ae5.svg" alt="x^{10}+x^8+x^7+x^5+x^4+x^3+1"/>; cela se produit lorsque <code class="code docutils literal notranslate"><span class="pre">reg</span></code> est <em>xor</em> avec 0x5B9 qui est l’équivalent binaire de ce polynôme.  En Python, les opérateurs binaires pour [and, or, not, xor] sont <code class="code docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">|</span> <span class="pre">~</span> <span class="pre">^</span></code> respectivement, exactement comme en C++. Un décalage de bit gauche est <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">y</span></code> (comme la multiplication de x par 2**y), et un décalage de bit droit est <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> (comme la division de x par 2**y), également comme en C++.</p>
<p>Notez que vous n’avez <strong>pas</strong> besoin de parcourir tout ce code, ou une partie de celui-ci, surtout si vous vous concentrez sur l’apprentissage de la couche physique (PHY) du DSP et de la SDR, car cela ne représente <em>pas</em> le traitement du signal. Ce code est simplement une implémentation d’un décodeur RDS, et essentiellement rien de ce code ne peut être réutilisé pour d’autres protocoles, car il est tellement spécifique à la façon dont le RDS fonctionne.  Si vous êtes déjà un peu épuisé par ce chapitre, sentez-vous libre de sauter cet énorme bloc de code qui a un travail assez simple mais qui le fait d’une manière complexe.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Constantes</span>
<span class="n">syndrome</span> <span class="o">=</span> <span class="p">[</span><span class="mi">383</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">303</span><span class="p">,</span> <span class="mi">663</span><span class="p">,</span> <span class="mi">748</span><span class="p">]</span>
<span class="n">offset_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">offset_word</span> <span class="o">=</span> <span class="p">[</span><span class="mi">252</span><span class="p">,</span> <span class="mi">408</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">436</span><span class="p">,</span> <span class="mi">848</span><span class="p">]</span>

<span class="c1"># regardez Annex B, page 64 du standard</span>
<span class="k">def</span> <span class="nf">calc_syndrome</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
    <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">plen</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)):</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">^</span> <span class="mh">0x5B9</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)):</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">^</span> <span class="mh">0x5B9</span>
    <span class="k">return</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># sélectionner les plen bits de reg les plus bas</span>

<span class="c1"># Initialiser toutes les variables de travail dont nous aurons besoin pendant la boucle.</span>
<span class="n">synced</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">group_good_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># était unsigned long en C++ (64 bits) mais numpy ne supporte pas les opérations bit à bit de uint64, je ne pense pas qu&#39;il atteigne cette valeur de toute façon.</span>
<span class="n">lastseen_offset_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lastseen_offset</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># le processus de synchronisation est décrit dans l&#39;annexe C, page 66 de la norme */</span>
<span class="n">bytes_out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)):</span>
    <span class="c1"># en C++, reg n&#39;est pas initié, il sera donc aléatoire au début, pour le nôtre, il s&#39;agit de 0.</span>
    <span class="c1"># C&#39;était aussi un unsigned long  mais il ne semblait pas s&#39;approcher de la valeur maximale.</span>
    <span class="c1"># les bits sont soit 0 soit 1</span>
    <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># reg contient les 26 derniers bits de RDS. Ce sont tous deux des opérations par bit.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">synced</span><span class="p">:</span>
        <span class="n">reg_syndrome</span> <span class="o">=</span> <span class="n">calc_syndrome</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reg_syndrome</span> <span class="o">==</span> <span class="n">syndrome</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">presync</span><span class="p">:</span>
                    <span class="n">lastseen_offset</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">lastseen_offset_counter</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">presync</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">block_distance</span> <span class="o">=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">block_distance</span> <span class="o">=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">block_distance</span><span class="o">*</span><span class="mi">26</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">lastseen_offset_counter</span><span class="p">):</span>
                        <span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Etat de la synchronisation détecté&#39;</span><span class="p">)</span>
                        <span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">block_bit_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">block_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
                        <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">synced</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span> <span class="c1"># syndrome trouvé, plus de cycles</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># SYNCHRONISÉ</span>
        <span class="c1"># attendre que 26 bits entrent dans le tampon */</span>
        <span class="k">if</span> <span class="n">block_bit_counter</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">:</span>
            <span class="n">block_bit_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dataword</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span>
            <span class="n">block_calculated_crc</span> <span class="o">=</span> <span class="n">calc_syndrome</span><span class="p">(</span><span class="n">dataword</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
            <span class="n">checkword</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span>
            <span class="k">if</span> <span class="n">block_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># gérer le cas particulier du mot de décalage C ou C&#39;.</span>
                <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="n">block_number</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">):</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">):</span>
                        <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">wrong_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="n">block_number</span><span class="p">]</span> <span class="c1"># xor binaire</span>
                <span class="k">if</span> <span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">:</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wrong_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Vérification du CRC terminée</span>
            <span class="k">if</span> <span class="n">block_number</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">good_block</span><span class="p">:</span>
                <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">group_good_blocks_counter</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="nb">bytes</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># 8 octets remplis de 0</span>
            <span class="k">if</span> <span class="n">group_assembly_started</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">good_block</span><span class="p">:</span>
                    <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># octets de données brutes, tels que reçus du RDS. 8 octets d&#39;information, suivis de 4 caractères de décalage RDS : ABCD/ABcD/EEEE (aux Etats-Unis) que nous laissons de côté ici.</span>
                    <span class="c1"># Mots d&#39;information RDS</span>
                    <span class="c1"># le numéro de bloc est soit 0,1,2,3 donc c&#39;est comme ça qu&#39;on remplit les 8 octets</span>
                    <span class="nb">bytes</span><span class="p">[</span><span class="n">block_number</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataword</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span>
                    <span class="nb">bytes</span><span class="p">[</span><span class="n">block_number</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataword</span> <span class="o">&amp;</span> <span class="mi">255</span>
                    <span class="n">group_good_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1">#print(&#39;group_good_blocks_counter:&#39;, group_good_blocks_counter)</span>
                <span class="k">if</span> <span class="n">group_good_blocks_counter</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="c1">#print(bytes)</span>
                    <span class="n">bytes_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span> <span class="c1"># liste de listes d&#39;octets de longueur 8</span>
            <span class="n">block_bit_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">block_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
            <span class="n">blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">blocks_counter</span> <span class="o">==</span> <span class="mi">50</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">wrong_blocks_counter</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">:</span> <span class="c1"># Autant de blocs erronés doivent signifier que nous avons perdu la synchronisation.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Perte de synchronisation (obtient &quot;</span><span class="p">,</span> <span class="n">wrong_blocks_counter</span><span class="p">,</span> <span class="s2">&quot; mauvais blocs sur &quot;</span><span class="p">,</span> <span class="n">blocks_counter</span><span class="p">,</span> <span class="s2">&quot; en total)&quot;</span><span class="p">)</span>
                    <span class="n">synced</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Toujours synchronisé (obtient &quot;</span><span class="p">,</span> <span class="n">wrong_blocks_counter</span><span class="p">,</span> <span class="s2">&quot; mauvais blocs sur &quot;</span><span class="p">,</span> <span class="n">blocks_counter</span><span class="p">,</span> <span class="s2">&quot; en total)&quot;</span><span class="p">)</span>
                <span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Vous trouverez ci-dessous un exemple de sortie de cette étape de décodage. Notez que dans cet exemple, la synchronisation est assez rapide, mais qu’elle est perdue plusieurs fois pour une raison quelconque, bien qu’elle soit toujours capable d’analyser toutes les données comme nous le verrons.  Si vous utilisez le fichier d’échantillons téléchargeable de 1M échantillons, vous ne verrez que les premières lignes ci-dessous.  Le contenu réel de ces octets ressemble à des nombres/caractères aléatoires selon la façon dont vous les affichez, mais dans l’étape suivante, nous allons les analyser en informations lisibles par l’homme!</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Etat de la synchronisation détecté</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   1  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   5  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   26  mauvais blocs sur  50 en total)</span>
<span class="go">Perte de synchronisation (obtient 50 mauvais blocs sur  50 en total)</span>
<span class="go">Etat de la synchronisation détecté</span>
<span class="go">Toujours synchronisé (obtient   3  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   0  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   2  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   1  mauvais blocs sur  50 en total)</span>
<span class="go">Toujours synchronisé (obtient   20  mauvais blocs sur  50 en total)</span>
<span class="go">Perte de synchronisation (obtient 47 mauvais blocs sur  50 en total)</span>
<span class="go">Etat de la synchronisation détecté</span>
<span class="go">Toujours synchronisé (obtient   32 mauvais blocs sur  50 en total)</span>
</pre></div>
</div>
</div>
<div class="section" id="analyse-du-rds">
<h2>Analyse du RDS<a class="headerlink" href="#analyse-du-rds" title="Permalink to this headline">¶</a></h2>
<p>Maintenant que nous avons des octets, par groupes de 8, nous pouvons extraire les données finales, c’est-à-dire la sortie finale qui est compréhensible par l’homme. C’est ce qu’on appelle l’analyse des octets, et tout comme le décodeur de la section précédente, il s’agit simplement d’une mise en œuvre du protocole RDS, et il n’est pas vraiment important de le comprendre. Heureusement, ce n’est pas une tonne de code, si vous n’incluez pas les deux tables définies au début, qui sont simplement les tables de recherche pour le type de canal FM et la zone de couverture.</p>
<p>Pour ceux qui veulent apprendre comment ce code fonctionne, je vais fournir quelques informations supplémentaires. Le protocole utilise le concept de drapeau A/B, ce qui signifie que certains messages sont marqués A et d’autres B, et que l’analyse syntaxique change en fonction de ces derniers (le fait qu’il s’agisse de A ou de B est stocké dans le troisième bit du deuxième octet). Il utilise également différents types de “groupes” qui sont analogues au type de message, et dans ce code, nous n’analysons que le type de message 2, qui est le type de message contenant le texte de la radio, qui est la partie intéressante, c’est le texte qui défile sur l’écran de votre voiture. Nous serons toujours en mesure d’analyser le type de chaîne et la région, car ils sont stockés dans chaque message. Enfin, notez que <code class="code docutils literal notranslate"><span class="pre">radiotext</span></code> est une chaîne qui est initialisée à tous les espaces, se remplit lentement au fur et à mesure que les octets sont analysés, puis se réinitialise à tous les espaces si un ensemble spécifique d’octets est reçu. Si vous êtes curieux de savoir quels autres types de messages existent, la liste est la suivante : [“BASIC”, “PIN/SL”, “RT”, “AID”, “CT”, “TDC”, “IH”, “RP”, “TMC”, “EWS”, “EON”]. Le message “RT” est un radiotexte qui est le seul que nous décodons. Le bloc RDS GNU Radio décode aussi “BASIC”, mais pour les stations que j’ai utilisées pour les tests, il ne contenait pas beaucoup d’informations intéressantes, et aurait ajouté beaucoup de lignes au code ci-dessous.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Annexe F de la norme RBDS Tableau F.1 (Amérique du Nord) et Tableau F.2 (Europe)</span>
<span class="c1">#              Europe                   Amérique du Nord</span>
<span class="n">pty_table</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;Undefined&quot;</span><span class="p">,</span>             <span class="s2">&quot;Undefined&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;News&quot;</span><span class="p">,</span>                  <span class="s2">&quot;News&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Current Affairs&quot;</span><span class="p">,</span>       <span class="s2">&quot;Information&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Information&quot;</span><span class="p">,</span>           <span class="s2">&quot;Sports&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Sport&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Education&quot;</span><span class="p">,</span>             <span class="s2">&quot;Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Drama&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Classic Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Culture&quot;</span><span class="p">,</span>               <span class="s2">&quot;Adult Hits&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Science&quot;</span><span class="p">,</span>               <span class="s2">&quot;Soft Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Varied&quot;</span><span class="p">,</span>                <span class="s2">&quot;Top 40&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Pop Music&quot;</span><span class="p">,</span>             <span class="s2">&quot;Country&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Rock Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Oldies&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Easy Listening&quot;</span><span class="p">,</span>        <span class="s2">&quot;Soft&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Light Classical&quot;</span><span class="p">,</span>       <span class="s2">&quot;Nostalgia&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Serious Classical&quot;</span><span class="p">,</span>     <span class="s2">&quot;Jazz&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Other Music&quot;</span><span class="p">,</span>           <span class="s2">&quot;Classical&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Weather&quot;</span><span class="p">,</span>               <span class="s2">&quot;Rhythm &amp; Blues&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Finance&quot;</span><span class="p">,</span>               <span class="s2">&quot;Soft Rhythm &amp; Blues&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Children’s Programmes&quot;</span><span class="p">,</span> <span class="s2">&quot;Language&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Social Affairs&quot;</span><span class="p">,</span>        <span class="s2">&quot;Religious Music&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Religion&quot;</span><span class="p">,</span>              <span class="s2">&quot;Religious Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Phone-In&quot;</span><span class="p">,</span>              <span class="s2">&quot;Personality&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Travel&quot;</span><span class="p">,</span>                <span class="s2">&quot;Public&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Leisure&quot;</span><span class="p">,</span>               <span class="s2">&quot;College&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Jazz Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Spanish Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Country Music&quot;</span><span class="p">,</span>         <span class="s2">&quot;Spanish Music&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;National Music&quot;</span><span class="p">,</span>        <span class="s2">&quot;Hip Hop&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Oldies Music&quot;</span><span class="p">,</span>          <span class="s2">&quot;Unassigned&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Folk Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Unassigned&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Documentary&quot;</span><span class="p">,</span>           <span class="s2">&quot;Weather&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Alarm Test&quot;</span><span class="p">,</span>            <span class="s2">&quot;Emergency Test&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Alarm&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Emergency&quot;</span><span class="p">]]</span>
<span class="n">pty_locale</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># mis à 0 pour l&#39;Europe qui utilisera la première colonne à la place.</span>

<span class="c1"># page 72, Annex D, table D.2 in the standard</span>
<span class="n">coverage_area_codes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Local&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;International&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;National&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Supra-regional&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 1&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 2&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 3&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 4&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 5&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 6&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 7&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 8&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 9&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 10&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 11&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 12&quot;</span><span class="p">]</span>

<span class="n">radiotext_AB_flag</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">radiotext</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">65</span>
<span class="n">first_time</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">for</span> <span class="nb">bytes</span> <span class="ow">in</span> <span class="n">bytes_out</span><span class="p">:</span>
    <span class="n">group_0</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_1</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_2</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_3</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>

    <span class="n">group_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span> <span class="c1"># voici ce que chacun signifie, par exemple RT est radiotexte qui est le seul que nous décodons ici : [&quot;BASIC&quot;, &quot;PIN/SL&quot;, &quot;RT&quot;, &quot;AID&quot;, &quot;CT&quot;, &quot;TDC&quot;, &quot;IH&quot;, &quot;RP&quot;, &quot;TMC&quot;, &quot;EWS&quot;, &quot;___&quot;, &quot;___&quot;, &quot;___&quot;, &quot;___&quot;, &quot;EON&quot;, &quot;___&quot;]</span>
    <span class="n">AB</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="c1"># b si 1, a si 0</span>

    <span class="c1">#print(&quot;group_type:&quot;, group_type) # il s&#39;agit essentiellement du type de message, je ne vois que les types 0 et 2 dans mon enregistrement.</span>
    <span class="c1">#print(&quot;AB:&quot;, AB)</span>

    <span class="n">program_identification</span> <span class="o">=</span> <span class="n">group_0</span>     <span class="c1"># &quot;PI&quot;</span>

    <span class="n">program_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span> <span class="c1"># &quot;PTY&quot;</span>
    <span class="n">pty</span> <span class="o">=</span> <span class="n">pty_table</span><span class="p">[</span><span class="n">program_type</span><span class="p">][</span><span class="n">pty_locale</span><span class="p">]</span>

    <span class="n">pi_area_coverage</span> <span class="o">=</span> <span class="p">(</span><span class="n">program_identification</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
    <span class="n">coverage_area</span> <span class="o">=</span> <span class="n">coverage_area_codes</span><span class="p">[</span><span class="n">pi_area_coverage</span><span class="p">]</span>

    <span class="n">pi_program_reference_number</span> <span class="o">=</span> <span class="n">program_identification</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="c1"># juste un entier</span>

    <span class="k">if</span> <span class="n">first_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PTY:&quot;</span><span class="p">,</span> <span class="n">pty</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;program:&quot;</span><span class="p">,</span> <span class="n">pi_program_reference_number</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;coverage_area:&quot;</span><span class="p">,</span> <span class="n">coverage_area</span><span class="p">)</span>
        <span class="n">first_time</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">group_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># lorsque le flag A/B est activé, effacez votre radiotexte actuel.</span>
        <span class="k">if</span> <span class="n">radiotext_AB_flag</span> <span class="o">!=</span> <span class="p">((</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">):</span>
            <span class="n">radiotext</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">65</span>
        <span class="n">radiotext_AB_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span>
        <span class="n">text_segment_address_code</span> <span class="o">=</span> <span class="n">group_1</span> <span class="o">&amp;</span> <span class="mh">0x0f</span>
        <span class="k">if</span> <span class="n">AB</span><span class="p">:</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">2</span>    <span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_3</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span><span class="mi">4</span>     <span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_2</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_2</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_3</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">radiotext</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1">#print(&quot;group_type non supporté:&quot;, group_type)</span>
</pre></div>
</div>
<p>L’exemple ci-dessous montre la sortie de l’étape d’analyse syntaxique pour une station FM. Notez comment il doit construire la chaîne de radiotexte sur plusieurs messages, puis il efface périodiquement la chaîne et recommence. Si vous utilisez l’exemple de fichier téléchargé de 1M, vous ne verrez que les premières lignes ci-dessous.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">PTY: Top 40</span>
<span class="go">program: 29</span>
<span class="go">coverage_area: Regional 4</span>
<span class="go">            ing.</span>
<span class="go">            ing. Upb</span>
<span class="go">            ing. Upbeat.</span>
<span class="go">            ing. Upbeat. Rea</span>

<span class="go">WAY-</span>
<span class="go">WAY-FM U</span>
<span class="go">WAY-FM Uplif</span>
<span class="go">WAY-FM Uplifting</span>
<span class="go">WAY-FM Uplifting. Up</span>
<span class="go">WAY-FM Uplifting. Upbeat</span>
<span class="go">WAY-FM Uplifting. Upbeat. Re</span>

<span class="go">WayF</span>
<span class="go">WayFM Up</span>
<span class="go">WayFM Uplift</span>
<span class="go">WayFM Uplifting.</span>
<span class="go">WayFM Uplifting. Upb</span>
<span class="go">WayFM Uplifting. Upbeat.</span>
<span class="go">WayFM Uplifting. Upbeat. Rea</span>
</pre></div>
</div>
</div>
<div class="section" id="recapitulation-et-code-final">
<h2>Récapitulation et code final<a class="headerlink" href="#recapitulation-et-code-final" title="Permalink to this headline">¶</a></h2>
<p>Vous l’avez fait! Ci-dessous se trouve tout le code ci-dessus, concaténé, il devrait fonctionner avec <a class="reference external" href="https://github.com/777arc/498x/blob/master/fm_rds_250k_1Msamples.iq?raw=true" rel="noopener noreferrer" target="_blank">l’enregistrement radio FM test que vous pouvez trouver ici</a>, bien que vous devriez être en mesure d’alimenter votre propre signal tant que son SNR reçu est assez élevé, il suffit de régler la fréquence centrale de la station et d’échantillonner à un taux de 250 kHz.  Si vous trouvez que vous avez dû faire des ajustements pour le faire fonctionner avec votre propre enregistrement ou SDR en direct, faites-moi savoir ce que vous avez dû faire, vous pouvez le soumettre comme un PR GitHub à <a class="reference external" href="https://github.com/777arc/textbook" rel="noopener noreferrer" target="_blank">la page GitHub du manuel</a>.  Vous pouvez également trouver une version de ce code avec des dizaines de tracés/graphes de débogage inclus, que j’ai utilisé à l’origine pour faire ce chapitre, <a class="reference external" href="https://github.com/777arc/textbook/blob/master/figure-generating-scripts/rds_demo.py" rel="noopener noreferrer" target="_blank">ici</a>.</p>
<details>
<summary>Final Code</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">resample_poly</span><span class="p">,</span> <span class="n">firwin</span><span class="p">,</span> <span class="n">bilinear</span><span class="p">,</span> <span class="n">lfilter</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Lire le signal</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;/home/marc/Downloads/fm_rds_250k_1Msamples.iq&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">250e3</span>
<span class="n">center_freq</span> <span class="o">=</span> <span class="mf">99.5e6</span>

<span class="c1"># Démodulation en quadrature</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="c1"># see https://wiki.gnuradio.org/index.php/Quadrature_Demod</span>

<span class="c1"># décalage de freq</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">f_o</span> <span class="o">=</span> <span class="o">-</span><span class="mf">57e3</span> <span class="c1"># valeur du décalage</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># vecteur de temps</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f_o</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># décalage de freq</span>

<span class="c1"># filtre passe bas</span>
<span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">7.5e3</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>

<span class="c1"># Décimer par 10, maintenant que nous avons filtré et qu&#39;il n&#39;y aura pas de repliement.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="mi">10</span><span class="p">]</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">25e3</span>

<span class="c1"># Rééchantillonnage à 19 kHz</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="c1"># up, down</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">19e3</span>

<span class="c1"># Filtre passe-bande pour isoler un signal RDS BPSK</span>
<span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="mi">501</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="p">[</span><span class="mf">0.05e3</span><span class="p">,</span> <span class="mf">2e3</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>

 <span class="c1"># Synchronisation des symboles, en utilisant ce que nous avons fait dans le chapitre sur la synchronisation.</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># comme dans le chapitre de la synchronisation</span>
<span class="n">samples_interpolated</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># Nous utiliserons 32 comme facteur d&#39;interpolation, choisi arbitrairement.</span>
<span class="n">sps</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># estimation initiale de la phase de l&#39;échantillon</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">out_rail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span> <span class="c1"># stocke les valeurs, à chaque itération nous avons besoin des 2 valeurs précédentes plus la valeur actuelle.</span>
<span class="n">i_in</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># index des échantillons d&#39;entrée</span>
<span class="n">i_out</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># indice de sortie (les deux premières sorties sont 0)</span>
<span class="k">while</span> <span class="n">i_out</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i_in</span><span class="o">+</span><span class="mi">32</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_interpolated</span><span class="p">[</span><span class="n">i_in</span><span class="o">*</span><span class="mi">32</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="mi">32</span><span class="p">)]</span> <span class="c1"># prendre ce que nous pensons être le &quot;meilleur&quot; échantillon</span>
    <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">+=</span> <span class="n">sps</span> <span class="o">+</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">mm_val</span>
    <span class="n">i_in</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="c1"># arrondir à l&#39;entier le plus proche puisque nous l&#39;utilisons comme un index</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="c1"># supprimer la partie entière de mu</span>
    <span class="n">i_out</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># incrémenter l&#39;indice de sortie</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">i_out</span><span class="p">]</span> <span class="c1"># supprimer les deux premiers, et tout ce qui suit i_out (qui n&#39;a jamais été rempli)</span>

<span class="c1"># Synchronisation fine de la fréquence</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># comme dans le chapitre de la synchro</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Ces deux paramètres suivants sont ce qu&#39;il faut ajuster, pour rendre la boucle de rétroaction plus rapide ou plus lente (ce qui a un impact sur la stabilité).</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">8.0</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.002</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">freq_log</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="c1"># ajuster l&#39;échantillon d&#39;entrée par l&#39;inverse du décalage de phase estimé</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># Voici la formule d&#39;erreur pour une boucle de Costas de 2ème ordre (par exemple pour BPSK)</span>

    <span class="c1"># Avancer la boucle (recalculer la phase et le décalage de fréquence)</span>
    <span class="n">freq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">freq_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="c1"># convertir de la vitesse angulaire en Hz pour les logs</span>
    <span class="n">phase</span> <span class="o">+=</span> <span class="n">freq</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>

    <span class="c1"># Facultatif : Ajustez la phase pour qu&#39;elle soit toujours comprise entre 0 et 2pi, rappelez-vous que la phase tourne autour 2pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">out</span>

<span class="c1"># Demodulation BPSK</span>
<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># 1s et 0s</span>

<span class="c1"># Décodage différentiel, de sorte qu&#39;il importe peu que notre BPSK ait subi une rotation de 180 degrés sans que nous nous en rendions compte.</span>
<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="c1"># decodage</span>

<span class="c1">############</span>
<span class="c1"># DECODAGE #</span>
<span class="c1">############</span>

<span class="c1"># Constants</span>
<span class="n">syndrome</span> <span class="o">=</span> <span class="p">[</span><span class="mi">383</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">303</span><span class="p">,</span> <span class="mi">663</span><span class="p">,</span> <span class="mi">748</span><span class="p">]</span>
<span class="n">offset_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">offset_word</span> <span class="o">=</span> <span class="p">[</span><span class="mi">252</span><span class="p">,</span> <span class="mi">408</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">436</span><span class="p">,</span> <span class="mi">848</span><span class="p">]</span>

<span class="c1"># regardez Annex B, page 64 du standard</span>
<span class="k">def</span> <span class="nf">calc_syndrome</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
    <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">plen</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)):</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">^</span> <span class="mh">0x5B9</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)):</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">^</span> <span class="mh">0x5B9</span>
    <span class="k">return</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">plen</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># sélectionner les plen bits de reg les plus bas</span>

<span class="c1"># Initialiser toutes les variables de travail dont nous aurons besoin pendant la boucle.</span>
<span class="n">synced</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">group_good_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># était unsigned long en C++ (64 bits) mais numpy ne supporte pas les opérations bit à bit de uint64, je ne pense pas qu&#39;il atteigne cette valeur de toute façon.</span>
<span class="n">lastseen_offset_counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lastseen_offset</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># le processus de synchronisation est décrit dans l&#39;annexe C, page 66 de la norme */</span>
<span class="n">bytes_out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)):</span>
    <span class="c1"># en C++, reg n&#39;est pas initié, il sera donc aléatoire au début, pour le nôtre, il s&#39;agit de 0.</span>
    <span class="c1"># C&#39;était aussi un unsigned long  mais il ne semblait pas s&#39;approcher de la valeur maximale.</span>
    <span class="c1"># les bits sont soit 0 soit 1</span>
    <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># reg contient les 26 derniers bits de RDS. Ce sont tous deux des opérations par bit.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">synced</span><span class="p">:</span>
        <span class="n">reg_syndrome</span> <span class="o">=</span> <span class="n">calc_syndrome</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reg_syndrome</span> <span class="o">==</span> <span class="n">syndrome</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">presync</span><span class="p">:</span>
                    <span class="n">lastseen_offset</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">lastseen_offset_counter</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">presync</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">block_distance</span> <span class="o">=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">block_distance</span> <span class="o">=</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset_pos</span><span class="p">[</span><span class="n">lastseen_offset</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">block_distance</span><span class="o">*</span><span class="mi">26</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">lastseen_offset_counter</span><span class="p">):</span>
                        <span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Etat de la synchronisation détecté&#39;</span><span class="p">)</span>
                        <span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">block_bit_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">block_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
                        <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">synced</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span> <span class="c1"># syndrome trouvé, plus de cycles</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># SYNCHRONISÉ</span>
        <span class="c1"># attendre que 26 bits entrent dans le tampon */</span>
        <span class="k">if</span> <span class="n">block_bit_counter</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">:</span>
            <span class="n">block_bit_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dataword</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span>
            <span class="n">block_calculated_crc</span> <span class="o">=</span> <span class="n">calc_syndrome</span><span class="p">(</span><span class="n">dataword</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
            <span class="n">checkword</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span>
            <span class="k">if</span> <span class="n">block_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># gérer le cas particulier du mot de décalage C ou C&#39;.</span>
                <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="n">block_number</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">):</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">):</span>
                        <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">wrong_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block_received_crc</span> <span class="o">=</span> <span class="n">checkword</span> <span class="o">^</span> <span class="n">offset_word</span><span class="p">[</span><span class="n">block_number</span><span class="p">]</span> <span class="c1"># xor binaire</span>
                <span class="k">if</span> <span class="n">block_received_crc</span> <span class="o">==</span> <span class="n">block_calculated_crc</span><span class="p">:</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wrong_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_block</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Vérification du CRC terminée</span>
            <span class="k">if</span> <span class="n">block_number</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">good_block</span><span class="p">:</span>
                <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">group_good_blocks_counter</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="nb">bytes</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># 8 octets remplis de 0</span>
            <span class="k">if</span> <span class="n">group_assembly_started</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">good_block</span><span class="p">:</span>
                    <span class="n">group_assembly_started</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># octets de données brutes, tels que reçus du RDS. 8 octets d&#39;information, suivis de 4 caractères de décalage RDS : ABCD/ABcD/EEEE (aux Etats-Unis) que nous laissons de côté ici.</span>
                    <span class="c1"># Mots d&#39;information RDS</span>
                    <span class="c1"># le numéro de bloc est soit 0,1,2,3 donc c&#39;est comme ça qu&#39;on remplit les 8 octets</span>
                    <span class="nb">bytes</span><span class="p">[</span><span class="n">block_number</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataword</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span>
                    <span class="nb">bytes</span><span class="p">[</span><span class="n">block_number</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataword</span> <span class="o">&amp;</span> <span class="mi">255</span>
                    <span class="n">group_good_blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1">#print(&#39;group_good_blocks_counter:&#39;, group_good_blocks_counter)</span>
                <span class="k">if</span> <span class="n">group_good_blocks_counter</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="c1">#print(bytes)</span>
                    <span class="n">bytes_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span> <span class="c1"># liste de listes d&#39;octets de longueur 8</span>
            <span class="n">block_bit_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">block_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
            <span class="n">blocks_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">blocks_counter</span> <span class="o">==</span> <span class="mi">50</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">wrong_blocks_counter</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">:</span> <span class="c1"># Autant de blocs erronés doivent signifier que nous avons perdu la synchronisation.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Perte de synchronisation (obtient &quot;</span><span class="p">,</span> <span class="n">wrong_blocks_counter</span><span class="p">,</span> <span class="s2">&quot; mauvais blocs sur &quot;</span><span class="p">,</span> <span class="n">blocks_counter</span><span class="p">,</span> <span class="s2">&quot; en total)&quot;</span><span class="p">)</span>
                    <span class="n">synced</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">presync</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Toujours synchronisé (obtient &quot;</span><span class="p">,</span> <span class="n">wrong_blocks_counter</span><span class="p">,</span> <span class="s2">&quot; mauvais blocs sur &quot;</span><span class="p">,</span> <span class="n">blocks_counter</span><span class="p">,</span> <span class="s2">&quot; en total)&quot;</span><span class="p">)</span>
                <span class="n">blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">wrong_blocks_counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">############</span>
<span class="c1"># Analyse  #</span>
<span class="c1">############</span>

<span class="c1"># Annexe F de la norme RBDS Tableau F.1 (Amérique du Nord) et Tableau F.2 (Europe)</span>
<span class="c1">#              Europe                   Amérique du Nord</span>
<span class="n">pty_table</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;Undefined&quot;</span><span class="p">,</span>             <span class="s2">&quot;Undefined&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;News&quot;</span><span class="p">,</span>                  <span class="s2">&quot;News&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Current Affairs&quot;</span><span class="p">,</span>       <span class="s2">&quot;Information&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Information&quot;</span><span class="p">,</span>           <span class="s2">&quot;Sports&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Sport&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Education&quot;</span><span class="p">,</span>             <span class="s2">&quot;Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Drama&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Classic Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Culture&quot;</span><span class="p">,</span>               <span class="s2">&quot;Adult Hits&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Science&quot;</span><span class="p">,</span>               <span class="s2">&quot;Soft Rock&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Varied&quot;</span><span class="p">,</span>                <span class="s2">&quot;Top 40&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Pop Music&quot;</span><span class="p">,</span>             <span class="s2">&quot;Country&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Rock Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Oldies&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Easy Listening&quot;</span><span class="p">,</span>        <span class="s2">&quot;Soft&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Light Classical&quot;</span><span class="p">,</span>       <span class="s2">&quot;Nostalgia&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Serious Classical&quot;</span><span class="p">,</span>     <span class="s2">&quot;Jazz&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Other Music&quot;</span><span class="p">,</span>           <span class="s2">&quot;Classical&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Weather&quot;</span><span class="p">,</span>               <span class="s2">&quot;Rhythm &amp; Blues&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Finance&quot;</span><span class="p">,</span>               <span class="s2">&quot;Soft Rhythm &amp; Blues&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Children’s Programmes&quot;</span><span class="p">,</span> <span class="s2">&quot;Language&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Social Affairs&quot;</span><span class="p">,</span>        <span class="s2">&quot;Religious Music&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Religion&quot;</span><span class="p">,</span>              <span class="s2">&quot;Religious Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Phone-In&quot;</span><span class="p">,</span>              <span class="s2">&quot;Personality&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Travel&quot;</span><span class="p">,</span>                <span class="s2">&quot;Public&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Leisure&quot;</span><span class="p">,</span>               <span class="s2">&quot;College&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Jazz Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Spanish Talk&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Country Music&quot;</span><span class="p">,</span>         <span class="s2">&quot;Spanish Music&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;National Music&quot;</span><span class="p">,</span>        <span class="s2">&quot;Hip Hop&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Oldies Music&quot;</span><span class="p">,</span>          <span class="s2">&quot;Unassigned&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Folk Music&quot;</span><span class="p">,</span>            <span class="s2">&quot;Unassigned&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Documentary&quot;</span><span class="p">,</span>           <span class="s2">&quot;Weather&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Alarm Test&quot;</span><span class="p">,</span>            <span class="s2">&quot;Emergency Test&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Alarm&quot;</span><span class="p">,</span>                 <span class="s2">&quot;Emergency&quot;</span><span class="p">]]</span>
<span class="n">pty_locale</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># mis à 0 pour l&#39;Europe qui utilisera la première colonne à la place.</span>

<span class="c1"># page 72, Annex D, table D.2 in the standard</span>
<span class="n">coverage_area_codes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Local&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;International&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;National&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Supra-regional&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 1&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 2&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 3&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 4&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 5&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 6&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 7&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 8&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 9&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 10&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 11&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Regional 12&quot;</span><span class="p">]</span>

<span class="n">radiotext_AB_flag</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">radiotext</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">65</span>
<span class="n">first_time</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">for</span> <span class="nb">bytes</span> <span class="ow">in</span> <span class="n">bytes_out</span><span class="p">:</span>
    <span class="n">group_0</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_1</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_2</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">group_3</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>

    <span class="n">group_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span> <span class="c1"># voici ce que chacun signifie, par exemple RT est radiotexte qui est le seul que nous décodons ici : [&quot;BASIC&quot;, &quot;PIN/SL&quot;, &quot;RT&quot;, &quot;AID&quot;, &quot;CT&quot;, &quot;TDC&quot;, &quot;IH&quot;, &quot;RP&quot;, &quot;TMC&quot;, &quot;EWS&quot;, &quot;___&quot;, &quot;___&quot;, &quot;___&quot;, &quot;___&quot;, &quot;EON&quot;, &quot;___&quot;]</span>
    <span class="n">AB</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="c1"># b si 1, a si 0</span>

    <span class="c1">#print(&quot;group_type:&quot;, group_type) # il s&#39;agit essentiellement du type de message, je ne vois que les types 0 et 2 dans mon enregistrement.</span>
    <span class="c1">#print(&quot;AB:&quot;, AB)</span>

    <span class="n">program_identification</span> <span class="o">=</span> <span class="n">group_0</span>     <span class="c1"># &quot;PI&quot;</span>

    <span class="n">program_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span> <span class="c1"># &quot;PTY&quot;</span>
    <span class="n">pty</span> <span class="o">=</span> <span class="n">pty_table</span><span class="p">[</span><span class="n">program_type</span><span class="p">][</span><span class="n">pty_locale</span><span class="p">]</span>

    <span class="n">pi_area_coverage</span> <span class="o">=</span> <span class="p">(</span><span class="n">program_identification</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
    <span class="n">coverage_area</span> <span class="o">=</span> <span class="n">coverage_area_codes</span><span class="p">[</span><span class="n">pi_area_coverage</span><span class="p">]</span>

    <span class="n">pi_program_reference_number</span> <span class="o">=</span> <span class="n">program_identification</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="c1"># juste un entier</span>

    <span class="k">if</span> <span class="n">first_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PTY:&quot;</span><span class="p">,</span> <span class="n">pty</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;program:&quot;</span><span class="p">,</span> <span class="n">pi_program_reference_number</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;coverage_area:&quot;</span><span class="p">,</span> <span class="n">coverage_area</span><span class="p">)</span>
        <span class="n">first_time</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">group_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># lorsque le flag A/B est activé, effacez votre radiotexte actuel.</span>
        <span class="k">if</span> <span class="n">radiotext_AB_flag</span> <span class="o">!=</span> <span class="p">((</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">):</span>
            <span class="n">radiotext</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">65</span>
        <span class="n">radiotext_AB_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">group_1</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span>
        <span class="n">text_segment_address_code</span> <span class="o">=</span> <span class="n">group_1</span> <span class="o">&amp;</span> <span class="mh">0x0f</span>
        <span class="k">if</span> <span class="n">AB</span><span class="p">:</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">2</span>    <span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_3</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span><span class="mi">4</span>     <span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_2</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_2</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">((</span><span class="n">group_3</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">radiotext</span><span class="p">[</span><span class="n">text_segment_address_code</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">group_3</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">radiotext</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1">#print(&quot;group_type non supporté:&quot;, group_type)</span>
</pre></div>
</div>
</details><p>Encore une fois, l’exemple d’enregistrement FM connu pour fonctionner avec ce code <a class="reference external" href="https://github.com/777arc/498x/blob/master/fm_rds_250k_1Msamples.iq?raw=true" rel="noopener noreferrer" target="_blank">peut être trouvé ici</a>.</p>
<p>Pour ceux qui sont intéressés par la démodulation du signal audio réel, il suffit d’ajouter les lignes suivantes juste après (merci à <a class="reference external" href="http://github.com/joeugenio" rel="noopener noreferrer" target="_blank">Joel Cordeiro</a> pour le code):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Ajoutez le code suivant juste après la section acquisition d&#39;un signal.</span>

<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">wavfile</span>

<span class="c1"># Demodulation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

<span class="c1"># Filtre de désaccentuation (de-emphasis), H(s) = 1/(RC*s + 1), implémenté comme un IIR via une transformation bilinéaire</span>
<span class="n">bz</span><span class="p">,</span> <span class="n">az</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mf">75e-6</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">bz</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c1"># filtre de décimation pour obtenir un son mono</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="mi">6</span><span class="p">]</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">6</span>

<span class="c1"># normaliser le volume</span>
<span class="n">x</span> <span class="o">/=</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

<span class="c1"># Enregistrez dans un fichier wav, vous pouvez l&#39;ouvrir dans Audacity par exemple.</span>
<span class="n">wavfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;fm.wav&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>La partie la plus compliquée est le filtre de désaccentuation (ou de-emphasis), <a class="reference external" href="https://wiki.gnuradio.org/index.php/FM_Preemphasis" rel="noopener noreferrer" target="_blank">que vous pouvez apprendre ici</a>, bien qu’il s’agisse en fait d’une étape optionnelle si vous pouvre vous suffir d’un audio qui a un mauvais équilibre entre les basses et les aigus. Pour les curieux, voici à quoi ressemble la réponse en fréquence de ce filtre <a class="reference external" href="https://fr.wikipedia.org/wiki/Filtre_à_réponse_impulsionnelle_infinie" rel="noopener noreferrer" target="_blank">IIR</a>, il ne filtre pas complètement les fréquences, c’est plus un filtre de “mise en forme”.</p>
<a class="reference external image-reference" href="../_images/fm_demph_filter_freq_response.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fm_demph_filter_freq_response.svg" class="align-center" src="../_images/fm_demph_filter_freq_response.svg" /></a>
</div>
<div class="section" id="remerciements">
<h2>Remerciements<a class="headerlink" href="#remerciements" title="Permalink to this headline">¶</a></h2>
<p>La plupart des étapes ci-dessus utilisées pour recevoir le RDS ont été adaptées de l’implémentation GNU Radio du RDS, qui est dans le module GNU Radio appelé <a class="reference external" href="https://github.com/bastibl/gr-rds" rel="noopener noreferrer" target="_blank">gr-rds</a>, créé à l’origine par Dimitrios Symeonidis et maintenu par Bastian Bloessl, et je voudrais remercier le travail de ces auteurs. Afin de créer ce chapitre, j’ai commencé par utiliser gr-rds dans GNU Radio, avec un enregistrement FM fonctionnel, et j’ai converti pas-à-pas chacun des blocs (y compris de nombreux blocs intégrés) en Python. Cela a pris pas mal de temps, il y a des nuances dans les blocs intégrés qui sont faciles à rater, et passer d’un traitement de signal de type stream (c’est-à-dire utilisant une fonction de travail qui traite quelques milliers d’échantillons à la fois) à un bloc de Python n’a pas été toujours simple. GNU Radio est un outil extraordinaire pour ce type de prototypage et je n’aurais jamais pu créer tout ce code Python fonctionnel sans lui.</p>
</div>
<div class="section" id="aller-plus-loin">
<h2>Aller plus loin<a class="headerlink" href="#aller-plus-loin" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><a class="reference external" href="https://fr.wikipedia.org/wiki/RDS_(radio" rel="noopener noreferrer" target="_blank">https://fr.wikipedia.org/wiki/RDS_(radio</a>)</li>
<li><a class="reference external" href="https://www.sigidwiki.com/wiki/Radio_Data_System_(RDS)" rel="noopener noreferrer" target="_blank">https://www.sigidwiki.com/wiki/Radio_Data_System_(RDS) (anglais)</a></li>
<li><a class="reference external" href="https://github.com/bastibl/gr-rds" rel="noopener noreferrer" target="_blank">https://github.com/bastibl/gr-rds</a></li>
<li><a class="reference external" href="https://www.gnuradio.org/" rel="noopener noreferrer" target="_blank">https://www.gnuradio.org/</a></li>
</ol>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="sync.html" title="Previous document"><span class="section-number">14. </span>Synchronisation</a>
        </li>
        <li>
          <a href="about_author.html" title="Next document"><span class="section-number">16. </span>A propos de l’auteur</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>