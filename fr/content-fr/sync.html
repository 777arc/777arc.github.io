
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>14. Synchronisation &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="15. Exemple bout en bout" href="rds.html" />
    <link rel="prev" title="13. Mise en Forme" href="pulse_shaping.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">14. Synchronisation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulation-d-un-canal-sans-fil">Simulation d’un canal sans fil</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronisation-du-temps">Synchronisation du temps</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronisation-du-temps-avec-interpolation">Synchronisation du temps avec interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronisation-grossiere-des-frequences">Synchronisation grossière des fréquences</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronisation-fine-de-la-frequence">Synchronisation fine de la fréquence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronisation-des-trames">Synchronisation des trames</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="pulse_shaping.html" title="previous chapter"><span class="section-number">13. </span>Mise en Forme</a></li>
      <li>Next: <a href="rds.html" title="next chapter"><span class="section-number">15. </span>Exemple bout en bout</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pulse_shaping.html" title="Previous document"><span class="section-number">13. </span>Mise en Forme</a>
        </li>
        <li>
          <a href="rds.html" title="Next document"><span class="section-number">15. </span>Exemple bout en bout</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="synchronisation">
<span id="sync-chapter"></span><h1><span class="section-number">14. </span>Synchronisation<a class="headerlink" href="#synchronisation" title="Permalink to this headline">¶</a></h1>
<p>Ce chapitre traite de la synchronisation des signaux sans fil en temps et en fréquence, afin de corriger les décalages de la fréquence porteuse et d’effectuer un alignement temporel au niveau des symboles et des trames.  Nous utiliserons la technique de récupération d’horloge de Mueller et Muller, ainsi que la boucle de Costas, en Python.</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Nous avons vu comment transmettre numériquement par voie hertzienne, en utilisant un schéma de modulation numérique comme la QPSK et en appliquant une mise en forme des impulsions pour limiter la largeur de bande du signal.  Le codage de canal peut être utilisé pour traiter les canaux bruyants, par exemple lorsque le rapport signal/bruit est faible au niveau du récepteur.  Il est toujours utile de filtrer autant que possible le signal avant de le traiter numériquement.  Dans ce chapitre, nous allons étudier la manière dont la synchronisation est effectuée du côté de la réception.  La synchronisation est un ensemble de traitements qui se produisent <em>avant</em> la démodulation et le décodage du canal.  La chaîne globale tx-canal-rx est représentée ci-dessous, avec les blocs abordés dans ce chapitre surlignés en jaune.  (Ce diagramme n’est pas exhaustif : la plupart des systèmes incluent également l’égalisation et le multiplexage).</p>
<a class="reference external image-reference" href="../_images/sync-diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/sync-diagram.svg" class="align-center" src="../_images/sync-diagram.svg" /></a>
</div>
<div class="section" id="simulation-d-un-canal-sans-fil">
<h2>Simulation d’un canal sans fil<a class="headerlink" href="#simulation-d-un-canal-sans-fil" title="Permalink to this headline">¶</a></h2>
<p>Avant d’apprendre à mettre en œuvre la synchronisation temporelle et fréquentielle, nous devons rendre nos signaux simulés plus réalistes.  Sans l’ajout d’un retard aléatoire, la synchronisation dans le temps est triviale.  En fait, il suffit de prendre en compte le retard d’échantillonnage de tous les filtres que vous utilisez.  Nous voulons également simuler un décalage de fréquence car, comme nous le verrons, les oscillateurs ne sont pas parfaits; il y aura toujours un certain décalage entre la fréquence centrale de l’émetteur et celle du récepteur.</p>
<p>Examinons maintenant le code Python permettant de simuler un retard non entier et un décalage de fréquence. Le code Python de ce chapitre part du code que nous avons écrit lors de l’exercice Python de mise en forme des impulsions (cliquez ci-dessous si vous en avez besoin); vous pouvez le considérer comme le point de départ du code de ce chapitre, et le nouveau code viendra ensuite.</p>
<details>
<summary>Code Python de la mise en forme des impulsions</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># cette partie provient de l&#39;exercice des impulsions de mise en forme</span>
<span class="n">num_symbols</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">sps</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_symbols</span><span class="p">)</span> <span class="c1"># Nos données à transmettre: des 1 et des 0.</span>
<span class="n">pulse_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
<span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">:</span>
    <span class="n">pulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sps</span><span class="p">)</span>
    <span class="n">pulse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bit</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># définir la première valeur à 1 ou -1</span>
    <span class="n">pulse_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pulse_train</span><span class="p">,</span> <span class="n">pulse</span><span class="p">))</span> <span class="c1"># ajouter les 8 échantillons au signal</span>

<span class="c1"># Créer notre filtre à base de cosinus surélevé</span>
<span class="n">num_taps</span> <span class="o">=</span> <span class="mi">101</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.35</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">sps</span> <span class="c1"># Supposons que la fréquence d&#39;échantillonnage est de 1Hz, donc la période d&#39;échantillonnage est de 1, donc la période du *symbole* est de 8.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">51</span><span class="p">,</span> <span class="mi">52</span><span class="p">)</span> <span class="c1"># n&#39;oubliez pas que le nombre final n&#39;est pas inclus</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Filtrer notre signal, afin d&#39;appliquer l&#39;impulsion de mise en forme</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">pulse_train</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
</details><p>Nous laisserons de côté le code relatif au tracé car vous avez probablement déjà appris à tracer n’importe quel signal. Pour que les tracés soient jolis, comme c’est souvent le cas dans ce manuel, il faut beaucoup de code supplémentaire qu’il n’est pas nécessaire de comprendre.</p>
<div class="section" id="ajouter-un-delai">
<h3>Ajouter un délai<a class="headerlink" href="#ajouter-un-delai" title="Permalink to this headline">¶</a></h3>
<p>Nous pouvons facilement simuler un retard en décalant les échantillons, mais cela ne simule qu’un retard qui est un multiple entier de notre période d’échantillonnage.  Dans le monde réel, le retard sera une fraction de la période d’échantillonnage.  Nous pouvons simuler le retard d’une fraction d’échantillon en créant un filtre à “retard fractionnel”, qui laisse passer toutes les fréquences mais retarde les échantillons d’une certaine quantité qui n’est pas limitée à l’intervalle d’échantillonnage.  Vous pouvez l’imaginer comme un filtre passe-tout qui applique le même déphasage à toutes les fréquences.  (Rappelez-vous qu’un retard temporel et un déphasage sont équivalents.) Le code Python permettant de créer ce filtre est présenté ci-dessous:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Créer et appliquer un filtre à retard fractionnel</span>
<span class="n">delay</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1"># délai fractionné, en échantillons</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">21</span> <span class="c1"># nombre de taps</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># ...-3,-2,-1,0,1,2,3...</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">delay</span><span class="p">)</span> <span class="c1"># calcul des taps du filtre</span>
<span class="n">h</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># fenêtre du filtre pour s&#39;assurer qu&#39;il décroit vers 0 des deux côtés</span>
<span class="n">h</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="c1"># normaliser pour obtenir un gain unitaire, nous ne voulons pas changer l&#39;amplitude/puissance</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="c1"># appliquer le filtre</span>
</pre></div>
</div>
<p>Comme vous pouvez le voir, nous calculons les prises du filtre à l’aide d’une fonction sinc().  Une fonction sinc dans le domaine temporel est un rectangle dans le domaine fréquentiel, et notre rectangle pour ce filtre couvre toute la gamme de fréquences de notre signal.  Ce filtre ne remodèle pas le signal, il le retarde simplement dans le temps.  Dans notre exemple, nous retardons de 0.4 échantillon.  N’oubliez pas que l’application de <em>n’importe quel</em> filtre retarde un signal de la moitié des taps du filtre moins un, en raison de la convolution du signal à travers le filtre.</p>
<p>Si nous traçons le graphique “avant” et “après” le filtrage d’un signal, nous pouvons observer le retard fractionnel.  Dans notre graphique, nous ne zoomons que sur quelques symboles.  Sinon, le retard fractionnel n’est pas visible.</p>
<a class="reference external image-reference" href="../_images/fractional-delay-filter.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fractional-delay-filter.svg" class="align-center" src="../_images/fractional-delay-filter.svg" /></a>
</div>
<div class="section" id="ajout-d-un-decalage-de-frequence">
<h3>Ajout d’un décalage de fréquence<a class="headerlink" href="#ajout-d-un-decalage-de-frequence" title="Permalink to this headline">¶</a></h3>
<p>Pour rendre notre signal simulé plus réaliste, nous allons appliquer un décalage de fréquence.  Disons que notre fréquence d’échantillonnage dans cette simulation est de 1 MHz (la valeur n’a pas vraiment d’importance, mais vous verrez pourquoi il est plus facile de choisir un nombre).  Si nous voulons simuler un décalage de fréquence de 13 kHz (un nombre arbitraire), nous pouvons le faire via le code suivant:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># appliquer un décalage de fréquence</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># supposons que notre fréquence d&#39;échantillonnage est de 1 MHz</span>
<span class="n">fo</span> <span class="o">=</span> <span class="mi">13000</span> <span class="c1"># simuler le décalage de la fréquence</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span> <span class="c1"># période d&#39;échantillonnage</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ts</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="n">Ts</span><span class="p">)</span> <span class="c1"># créer un vecteur temps</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">fo</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># effectuer un décalage de fréquence</span>
</pre></div>
</div>
<p>La figure ci-dessous montre le signal avant et après l’application du décalage de fréquence.</p>
<a class="reference external image-reference" href="../_images/sync-freq-offset.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/sync-freq-offset.svg" class="align-center" src="../_images/sync-freq-offset.svg" /></a>
<p>Nous n’avons pas représenté graphiquement la partie Q puisque nous transmettions en BPSK, ce qui fait que la partie Q est toujours nulle.  Maintenant que nous ajoutons un décalage de fréquence pour simuler les canaux sans fil, l’énergie s’étend sur I et Q. À partir de maintenant, nous devrions tracer à la fois I et Q. N’hésitez pas à substituer un décalage de fréquence différent pour votre code.  Si vous abaissez le décalage à environ 1 kHz, vous serez en mesure de voir la sinusoïde dans l’enveloppe du signal car elle oscille suffisamment lentement pour couvrir plusieurs symboles.</p>
<p>En ce qui concerne le choix d’une fréquence d’échantillonnage arbitraire, si vous examinez le code, vous remarquerez que ce qui importe est le rapport entre <code class="code docutils literal notranslate"><span class="pre">fo</span></code> et <code class="code docutils literal notranslate"><span class="pre">fs</span></code>.</p>
<p>Vous pouvez prétendre que les deux blocs de code présentés précédemment simulent un canal sans fil.  Le code devrait venir après le code côté émission (ce que nous avons fait dans le chapitre sur les impulsions de mise en forme) et avant le code côté réception, qui est ce que nous allons explorer dans le reste de ce chapitre.</p>
</div>
</div>
<div class="section" id="synchronisation-du-temps">
<h2>Synchronisation du temps<a class="headerlink" href="#synchronisation-du-temps" title="Permalink to this headline">¶</a></h2>
<p>Lorsque nous transmettons un signal sans fil, il arrive au récepteur avec un déphasage aléatoire dû au temps parcouru.  Nous ne pouvons pas simplement commencer à échantillonner les symboles à notre débit de symboles car il est peu probable que nous l’échantillonnions au bon endroit dans l’impulsion, comme nous l’avons vu à la fin du chapitre <a class="reference internal" href="pulse_shaping.html#pulse-shaping-chapter"><span class="std std-ref">Mise en Forme</span></a>.  Revoyez les trois figures à la fin de ce chapitre si vous ne suivez pas.</p>
<p>La plupart des techniques de synchronisation prennent la forme d’une boucle à verrouillage de phase (ou PLL en anglais pour <em>phase locked loop</em>). Nous n’étudierons pas les PLL ici, mais il est important de connaître ce terme et vous pouvez vous documenter sur le sujet si vous êtes intéressé.  Les PLL sont des systèmes en boucle fermée qui utilisent la rétroaction pour ajuster continuellement un paramètre; dans notre cas, un décalage temporel nous permet d’échantillonner au pic des symboles numériques.</p>
<p>Vous pouvez vous représenter la récupération du temps comme un bloc dans le récepteur, qui accepte un flux d’échantillons et sort un autre flux d’échantillons (similaire à un filtre).  Nous programmons ce bloc de récupération du temps avec des informations sur notre signal, la plus importante étant le nombre d’échantillons par symbole (ou notre meilleure estimation de celui-ci, si nous ne sommes pas sûrs à 100 % de ce qui a été transmis).  Ce bloc agit comme un “décimateur”, c’est-à-dire que notre échantillon de sortie sera une fraction du nombre d’échantillons d’entrée.  Nous voulons un échantillon par symbole numérique, donc le taux de décimation est simplement les échantillons par symbole.  Si l’émetteur transmet à 1M symboles par seconde et que nous échantillonnons à 16 Msps, nous recevrons 16 échantillons par symbole.  Ce sera le taux d’échantillonnage entrant dans le bloc de synchronisation.  Le taux d’échantillonnage sortant du bloc sera de 1 Msps car nous voulons un échantillon par symbole numérique.</p>
<p>La plupart des méthodes de récupération du temps reposent sur le fait que nos symboles numériques montent puis descendent, et que la crête est le point auquel nous voulons échantillonner le symbole. En d’autres termes, nous échantillonnons le point maximum après avoir pris la valeur absolue :</p>
<a class="reference internal image-reference" href="../_images/symbol_sync2.png"><img alt="../_images/symbol_sync2.png" class="align-center" src="../_images/symbol_sync2.png" style="width: 667.6px; height: 194.8px;" /></a>
<p>Il existe de nombreuses méthodes de récupération du temps, la plupart ressemblant à une PLL. La différence entre elles réside généralement dans l’équation utilisée pour effectuer la “correction” du décalage temporel, que nous désignons par <img class="math" src="../_images/math/c859a8f80a5b73b97ecb9d3c15842e979a0f6fe2.svg" alt="\mu"/> ou <code class="code docutils literal notranslate"><span class="pre">mu</span></code> dans le code.  La valeur de <code class="code docutils literal notranslate"><span class="pre">mu</span></code> est mise à jour à chaque itération de la boucle.  Elle est exprimée en unités d’échantillons, et vous pouvez l’imaginer comme le décalage que nous devons faire pour pouvoir échantillonner au moment “parfait”.  Ainsi, si <code class="code docutils literal notranslate"><span class="pre">mu</span> <span class="pre">=</span> <span class="pre">3.61</span></code>, cela signifie que nous devons décaler l’entrée de 3.61 échantillons pour échantillonner au bon endroit.  Comme nous avons 8 échantillons par symbole, si <code class="code docutils literal notranslate"><span class="pre">mu</span></code> dépasse 8, il revient simplement à zéro.</p>
<p>Le code Python suivant implémente la technique de récupération d’horloge de Mueller et Muller.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># estimation initiale de la phase de l&#39;échantillon</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
<span class="n">out_rail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span> <span class="c1"># stocke les valeurs, à chaque itération nous avons besoin des 2 valeurs précédentes plus la valeur actuelle.</span>
<span class="n">i_in</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># index des échantillons d&#39;entrée</span>
<span class="n">i_out</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># indice de sortie (les deux premières sorties sont 0)</span>
<span class="k">while</span> <span class="n">i_out</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i_in</span><span class="o">+</span><span class="mi">16</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i_in</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="p">)]</span> <span class="c1"># prendre ce que nous pensons être le &quot;meilleur&quot; échantillon.</span>
    <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out_rail</span><span class="p">[</span><span class="n">i_out</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">+=</span> <span class="n">sps</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">mm_val</span>
    <span class="n">i_in</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="c1"># arrondir à l&#39;entier le plus proche puisque nous l&#39;utilisons comme un index</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="c1"># supprimer la partie entière de mu</span>
    <span class="n">i_out</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># incrémenter l&#39;indice de sortie</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">i_out</span><span class="p">]</span> <span class="c1"># supprimer les deux premiers, et tout ce qui suit i_out (qui n&#39;a jamais été rempli)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">out</span> <span class="c1"># n&#39;incluez cette ligne que si vous voulez connecter cet extrait de code avec la boucle Costas plus tard</span>
</pre></div>
</div>
<p>Le bloc de récupération du timing reçoit les échantillons “reçus” et produit un échantillon de sortie un par un (notez que <code class="code docutils literal notranslate"><span class="pre">i_out</span></code> est incrémenté de 1 à chaque itération de la boucle).  Le bloc de récupération n’utilise pas seulement les échantillons “reçus” l’un après l’autre à cause de la façon dont la boucle ajuste <code class="code docutils literal notranslate"><span class="pre">i_in</span></code>.  Elle sautera quelques échantillons pour essayer de tirer le “bon” échantillon, qui serait celui au pic de l’impulsion.  Au fur et à mesure que la boucle traite les échantillons, elle se synchronise lentement sur le symbole, ou du moins elle tente de le faire en ajustant <code class="code docutils literal notranslate"><span class="pre">mu</span></code>.  Étant donné la structure du code, la partie entière de <code class="code docutils literal notranslate"><span class="pre">mu</span></code> est ajoutée à <code class="code docutils literal notranslate"><span class="pre">i_in</span></code>, puis retirée de <code class="code docutils literal notranslate"><span class="pre">mu</span></code> (gardez à l’esprit que <code class="code docutils literal notranslate"><span class="pre">mm_val</span></code> peut être négatif ou positif à chaque boucle).  Une fois qu’elle est complètement synchronisée, la boucle ne devrait tirer que l’échantillon central de chaque symbole/impulsion.  Vous pouvez ajuster la constante 0.3, qui modifiera la vitesse de réaction de la boucle de rétroaction; une valeur plus élevée la fera réagir plus rapidement, mais avec un risque plus élevé de problèmes de stabilité.</p>
<p>Le graphique suivant montre un exemple de sortie où nous avons <em>désactivé</em> le délai fractionnel ainsi que le décalage de fréquence.  Nous montrons seulement I parce que Q est tout à fait nul avec le décalage de fréquence désactivé.  Les trois graphiques sont empilés les uns sur les autres pour montrer comment les bits sont alignés verticalement.</p>
<dl class="docutils">
<dt><strong>Graphique du haut</strong></dt><dd>Symboles BPSK originaux, c’est-à-dire des 1 et des -1.  Rappelez-vous qu’il y a des zéros entre les deux car nous voulons 8 échantillons par symbole.</dd>
<dt><strong>Graphique du milieu</strong></dt><dd>Echantillons après l’impulsion de mise en forme mais avant le synchronisation.</dd>
<dt><strong>Graphique du bas</strong></dt><dd>Sortie de la synchronisation de symboles, qui fournit seulement 1 échantillon par symbole.  Cela signifie que ces échantillons peuvent être introduits directement dans un démodulateur, qui, pour la BPSK, vérifie si la valeur est supérieure ou inférieure à 0.</dd>
</dl>
<a class="reference external image-reference" href="../_images/time-sync-output.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-output.svg" class="align-center" src="../_images/time-sync-output.svg" /></a>
<p>Concentrons-nous sur le graphique du bas, qui est la sortie de la synchronisation.  Il a fallu près de 30 symboles pour que la synchronisation se verrouille sur le bon délai.  En raison inévitablement du temps nécessaire aux synchroniseurs pour se verrouiller, de nombreux protocoles de communication utilisent un préambule contenant une séquence de synchronisation: il sert à annoncer l’arrivée d’un nouveau paquet et donne au récepteur le temps de se synchroniser sur celui-ci.  Mais après ces ~30 échantillons, la synchronisation fonctionne parfaitement.  Nous nous retrouvons avec des 1 et des -1 parfaits qui correspondent aux données d’entrée.  Il est utile que cet exemple n’ait pas eu de bruit ajouté.  N’hésitez pas à ajouter du bruit ou des décalages temporels et voyez comment la synchronisation se comporte.  Si nous utilisions la QPSK, nous aurions affaire à des nombres complexes, mais l’approche serait la même.</p>
</div>
<div class="section" id="synchronisation-du-temps-avec-interpolation">
<h2>Synchronisation du temps avec interpolation<a class="headerlink" href="#synchronisation-du-temps-avec-interpolation" title="Permalink to this headline">¶</a></h2>
<p>Les synchroniseurs de symboles ont tendance à interpoler les échantillons d’entrée par un certain nombre, par exemple 16, afin de pouvoir se décaler d’une <em>fraction</em> d’échantillon.  Le retard aléatoire causé par le canal sans fil ne sera probablement pas un multiple exact d’un échantillon, de sorte que le pic du symbole peut ne pas se produire réellement sur un échantillon.  C’est particulièrement vrai dans le cas où il n’y aurait que 2 ou 4 échantillons par symbole reçu.  L’interpolation des échantillons nous permet d’échantillonner “entre” les échantillons réels, afin d’atteindre le pic de chaque symbole.  La sortie du synchroniseur n’est toujours qu’un échantillon par symbole. Les échantillons d’entrée sont eux-mêmes interpolés.</p>
<p>Le code Python de synchronisation temporelle que nous avons implémenté ci-dessus n’incluait pas d’interpolation.  Pour étendre notre code, activez le retard temporel fractionnaire que nous avons implémenté au début de ce chapitre afin que notre signal reçu ait un retard plus réaliste.  Laissez le décalage de fréquence désactivé pour le moment.  Si vous relancez la simulation, vous constaterez que la synchronisation ne parvient pas à se synchroniser complètement sur le signal.  C’est parce que nous n’interpolons pas, et que le code n’a aucun moyen “d’échantillonner entre les échantillons” pour compenser le retard fractionnel.  Ajoutons l’interpolation.</p>
<p>Un moyen rapide d’interpoler un signal en Python est d’utiliser <code class="code docutils literal notranslate"><span class="pre">signal.resample</span></code> ou <code class="code docutils literal notranslate"><span class="pre">signal.resample_poly</span></code> de scipy.  Ces deux fonctions font la même chose mais fonctionnent différemment.  Nous utiliserons la dernière fonction car elle a tendance à être plus rapide.  Interpolons par 16, c’est-à-dire que nous allons insérer 15 échantillons supplémentaires entre chaque échantillon.  Cela peut être fait en une ligne de code, et cela devrait se faire <em>avant</em> d’effectuer la synchronisation temporelle (avant le gros extrait de code ci-dessus).  Nous allons également tracer le graphique avant et après pour voir la différence:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">samples_interpolated</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Tracez l&#39;ancien et le nouveau</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;avant interp&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s1">&#39;après interp&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">samples_interpolated</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Si on zoome <em>beaucoup</em>, on voit que c’est le même signal, mais avec 16x plus de points :</p>
<a class="reference external image-reference" href="../_images/time-sync-interpolated-samples.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-interpolated-samples.svg" class="align-center" src="../_images/time-sync-interpolated-samples.svg" /></a>
<p>J’espère que la raison pour laquelle nous devons interpoler à l’intérieur du bloc de synchronisation temporelle devient claire.  Ces échantillons supplémentaires nous permettront de prendre en compte une fraction d’un échantillon de retard.  En plus de calculer <code class="code docutils literal notranslate"><span class="pre">samples_interpolated</span></code>, nous devons également modifier une ligne de code dans notre synchronisation temporelle.  Nous allons changer la première ligne à l’intérieur de la boucle <em>while</em> pour devenir:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">i_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_interpolated</span><span class="p">[</span><span class="n">i_in</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="mi">16</span><span class="p">)]</span>
</pre></div>
</div>
<p>Nous avons fait plusieurs choses ici.  D’abord, nous ne pouvons plus utiliser <code class="code docutils literal notranslate"><span class="pre">i_in</span></code> comme index de l’échantillon d’entrée.  Nous devons le multiplier par 16 car nous avons interpolé nos échantillons d’entrée par 16.  Rappelez-vous que la boucle de rétroaction ajuste la variable <code class="code docutils literal notranslate"><span class="pre">mu</span></code>.  Elle représente le délai qui nous permet d’échantillonner au bon moment.  Rappelez-vous également qu’après avoir calculé la nouvelle valeur de <code class="code docutils literal notranslate"><span class="pre">mu</span></code>, nous avons ajouté la partie entière à <code class="code docutils literal notranslate"><span class="pre">i_in</span></code>.  Maintenant, nous allons utiliser la partie restante, qui est un flottant de 0 à 1, et qui représente la fraction d’échantillon que nous devons retarder.  Avant, nous n’étions pas capables de retarder d’une fraction d’échantillon, mais maintenant nous le pouvons, au moins par incréments de 16ème d’échantillon.  Il faut donc multiplier <code class="code docutils literal notranslate"><span class="pre">mu</span></code> par 16 pour savoir de combien d’échantillons de notre signal interpolé nous devons retarder.  Ensuite, nous devons arrondir ce nombre, car la valeur entre parenthèses est finalement un index et doit être un nombre entier.  Si ce paragraphe n’a pas eu de sens, essayez de revenir au code initial de récupération d’horloge de Mueller et Muller, et lisez également les commentaires à côté de chaque ligne de code.</p>
<p>Le résultat du tracé de ce nouveau code devrait être à peu près le même que précédemment.  Tout ce que nous avons fait, c’est rendre notre simulation plus réaliste en ajoutant un retard d’échantillon fractionnaire, puis nous avons ajouté l’interpolateur à la synchronisation afin de compenser ce retard d’échantillon fractionnaire.</p>
<p>N’hésitez pas à jouer avec différents facteurs d’interpolation, c’est-à-dire à remplacer tous les 16 par une autre valeur.  Vous pouvez également essayer d’activer le décalage de fréquence, ou d’ajouter un bruit blanc gaussien au signal avant qu’il ne soit reçu, pour voir comment cela affecte les performances de synchronisation (indice : vous devrez peut-être ajuster le multiplicateur de 0.3).</p>
<p>Si nous activons uniquement le décalage de fréquence en utilisant une fréquence de 1kHz, nous obtenons les performances de synchronisation suivantes.  Nous devons montrer à la fois I et Q maintenant que nous avons ajouté un décalage de fréquence :</p>
<a class="reference external image-reference" href="../_images/time-sync-output2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-output2.svg" class="align-center" src="../_images/time-sync-output2.svg" /></a>
<p>C’est peut-être difficile à voir, mais la synchronisation du temps fonctionne toujours très bien.  Il faut environ 20 à 30 symboles avant qu’elle ne soit verrouillée.  Cependant, il y a un motif sinusoïdal parce que nous avons encore un décalage de fréquence, et nous allons apprendre à le gérer dans la section suivante.</p>
<p>La figure ci-dessous montre le graphique IQ (aussi appelé constellation) du signal avant et après la synchronisation.  Rappelez-vous que vous pouvez tracer des échantillons sur un graphique IQ en utilisant un nuage de points : <code class="code docutils literal notranslate"><span class="pre">plt.plot(np.real(samples),</span> <span class="pre">np.imag(samples),</span> <span class="pre">'.')</span></code>.  Dans l’animation ci-dessous, nous avons spécifiquement laissé de côté les 30 premiers symboles.  Ils sont apparus avant la fin de la synchronisation temporelle.  Les symboles restants sont tous approximativement sur le cercle des unités en raison du décalage de fréquence.</p>
<a class="reference external image-reference" href="../_images/time-sync-constellation.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-sync-constellation.svg" class="align-center" src="../_images/time-sync-constellation.svg" /></a>
<p>Pour en savoir encore plus, nous pouvons observer la constellation dans le temps afin de discerner ce qui arrive réellement aux symboles.  Au tout début, pendant une courte période de temps, les symboles ne sont pas à 0 ou sur le cercle unitaire.  C’est la période pendant laquelle la synchronisation temporelle trouve le bon délai.  C’est très rapide, regardez bien! La rotation est juste le décalage de fréquence.  La fréquence est un changement constant de la phase, donc un décalage de fréquence provoque une rotation de la BPSK (créant un cercle dans le tracé statique/persistant ci-dessus).</p>
<img alt="../_images/time-sync-constellation-animated.gif" class="align-center" src="../_images/time-sync-constellation-animated.gif" />
<p>Nous espérons qu’en voyant un exemple de synchronisation temporelle, vous avez une idée de ce qu’elle fait et une idée générale de son fonctionnement.  En pratique, la boucle while que nous avons créée ne fonctionnerait que sur un petit nombre d’échantillons à la fois (par exemple, 1000).  Vous devez vous souvenir de la valeur de <code class="code docutils literal notranslate"><span class="pre">mu</span></code> entre les appels à la fonction sync, ainsi que des deux dernières valeurs de <code class="code docutils literal notranslate"><span class="pre">out</span></code> et <code class="code docutils literal notranslate"><span class="pre">out_rail</span></code>.</p>
<p>Ensuite, nous allons étudier la synchronisation de la fréquence, que nous divisons en synchro de fréquence grossière et fine.  La synchronisation grossière vient généralement avant la synchronisation temporelle, tandis que la synchronisation fine vient après.</p>
</div>
<div class="section" id="synchronisation-grossiere-des-frequences">
<h2>Synchronisation grossière des fréquences<a class="headerlink" href="#synchronisation-grossiere-des-frequences" title="Permalink to this headline">¶</a></h2>
<p>Même si nous demandons à l’émetteur et au récepteur de fonctionner sur la même fréquence centrale, il y aura un léger décalage de fréquence entre les deux en raison d’imperfections matérielles (par exemple, l’oscillateur) ou d’un décalage Doppler dû au mouvement.  Ce décalage de fréquence sera minuscule par rapport à la fréquence porteuse, mais même un petit décalage peut perturber un signal numérique.  Le décalage évoluera probablement dans le temps, ce qui nécessite une boucle de rétroaction permanente pour corriger le décalage.  Par exemple, l’oscillateur à l’intérieur du Pluto a une spécification de décalage maximale de 25 PPM.  C’est-à-dire 25 parties par million par rapport à la fréquence centrale.  Si vous êtes réglé sur 2.4 GHz, le décalage maximal serait de +/- 60 kHz.  Les échantillons que notre SDR nous fournit sont en bande de base, ce qui fait que tout décalage de fréquence se manifeste dans ce signal en bande de base.  Un signal BPSK avec un petit décalage de la porteuse ressemblera au tracé temporel ci-dessous, ce qui n’est évidemment pas idéal pour démoduler des bits.  Nous devons supprimer tout décalage de fréquence avant la démodulation.</p>
<a class="reference internal image-reference" href="../_images/carrier-offset.png"><img alt="../_images/carrier-offset.png" class="align-center" src="../_images/carrier-offset.png" style="width: 744.6px; height: 147.6px;" /></a>
<p>La synchronisation de fréquence est généralement décomposée en synchronisation grossière et synchronisation fine, où la synchronisation grossière corrige les grands décalages de l’ordre du kHz ou plus, tandis que la synchronisation fine corrige ce qui reste.  La synchronisation grossière intervient avant la synchronisation temporelle, tandis que la synchronisation fine intervient après.</p>
<p>Mathématiquement, si nous disposons d’un signal en bande de base <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> et qu’il subit un décalage de fréquence (aussi appelé porteuse) de <img class="math" src="../_images/math/0c8e13216427d3fcc928d732f6a1b2ead245a9f7.svg" alt="f_o"/> Hz, nous pouvons représenter ce qui est reçu comme suit:</p>
<div class="math">
<p><img src="../_images/math/a9cd4948a8e460934c220cb41203d2346e1d6a12.svg" alt="r(t) = s(t) e^{j2\pi f_o t} + n(t)"/></p>
</div><p>où <img class="math" src="../_images/math/9a5bb2f9fe74aa0a2242ca907f54bb133b0ca3f7.svg" alt="n(t)"/> est le bruit.</p>
<p>La première astuce que nous allons apprendre, afin d’effectuer une estimation grossière du décalage de fréquence (si nous pouvons estimer la fréquence de décalage, alors nous pouvons la compenser), est de prendre le carré de notre signal.  Ignorons le bruit pour l’instant, afin de garder les mathématiques plus simples :</p>
<div class="math">
<p><img src="../_images/math/9ec5450b2123e5d0e20fd6f35232f3310e662e5f.svg" alt="r^2(t) = s^2(t) e^{j4\pi f_o t}"/></p>
</div><p>Voyons ce qui se passe lorsque nous prenons le carré de notre signal <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> en considérant ce que ferait la QPSK.  L’élévation au carré de nombres complexes donne lieu à un comportement intéressant, surtout lorsqu’il s’agit de constellations comme la BPSK et la QPSK.  L’animation suivante montre ce qui se passe lorsqu’on élève au carré une QPSK, puis si on l’élève encore une deuxième fois.  J’ai utilisé spécifiquement la QPSK au lieu de la BPSK parce que vous pouvez voir que lorsque vous érigez la QPSK une fois, vous obtenez essentiellement la BPSK.  Et après un autre carré, on obtient un cluster.  (Merci à <a class="reference external" href="http://ventrella.com/ComplexSquaring/" rel="noopener noreferrer" target="_blank">http://ventrella.com/ComplexSquaring/</a> qui a créé cette belle application web).</p>
<a class="reference internal image-reference" href="../_images/squaring-qpsk.gif"><img alt="../_images/squaring-qpsk.gif" class="align-center" src="../_images/squaring-qpsk.gif" style="width: 480.0px; height: 468.0px;" /></a>
<p>Voyons ce qui se passe lorsqu’on applique à notre signal QPSK une petite rotation de phase et une mise à l’échelle de l’amplitude, ce qui est plus réaliste :</p>
<a class="reference internal image-reference" href="../_images/squaring-qpsk2.gif"><img alt="../_images/squaring-qpsk2.gif" class="align-center" src="../_images/squaring-qpsk2.gif" style="width: 480.0px; height: 468.0px;" /></a>
<p>Il s’agit toujours d’un seul groupe, mais avec un déphasage.  Ce qu’il faut retenir, c’est que si vous mettez la QPSK au carré deux fois (et la BPSK une fois), les quatre groupes de points seront fusionnés en un seul groupe.  Pourquoi cela est-il utile?  En fusionnant les groupes, nous supprimons essentiellement la modulation!  Si tous les points sont maintenant dans le même groupe, c’est comme si on avait un tas de constantes dans une rangée.  C’est comme s’il n’y avait plus de modulation, et que la seule chose qui restait était la sinusoïde causée par le décalage de fréquence (nous avons aussi du bruit, mais ignorons-le pour l’instant).  Il s’avère que vous devez élever le signal au carré N fois, où N est l’ordre du schéma de modulation utilisé, ce qui signifie que cette astuce ne fonctionne que si vous connaissez le schéma de modulation à l’avance.  L’équation est en fait la suivante :</p>
<div class="math">
<p><img src="../_images/math/d5846eced1c768d7a0703bb7168e341a9b0cb475.svg" alt="r^N(t) = s^N(t) e^{j2N\pi f_o t}"/></p>
</div><p>Pour notre cas de BPSK, nous avons un schéma de modulation d’ordre 2, nous utiliserons donc l’équation suivante pour notre synchronisation grossière de la fréquence:</p>
<div class="math">
<p><img src="../_images/math/9ec5450b2123e5d0e20fd6f35232f3310e662e5f.svg" alt="r^2(t) = s^2(t) e^{j4\pi f_o t}"/></p>
</div><p>Nous avons découvert ce qui arrive à la partie <img class="math" src="../_images/math/f7732f55dfe0207d534c035f09daf8d2ab5ff9c4.svg" alt="s(t)"/> de l’équation, mais qu’en est-il de la partie sinusoïde (alias exponentielle complexe)?  Comme on peut le voir, on ajoute le terme <img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/>, ce qui la rend équivalente à une sinusoïde à une fréquence de <img class="math" src="../_images/math/04194ee8a94a5914d95f7166a63d9eeef0a33a45.svg" alt="Nf_o"/> au lieu de <img class="math" src="../_images/math/0c8e13216427d3fcc928d732f6a1b2ead245a9f7.svg" alt="f_o"/>.  Une méthode simple pour déterminer <img class="math" src="../_images/math/5b4d646bd637804d0898d428de76fe15564bfd0f.svg" alt="nf_o"/> est de prendre la FFT du signal après l’avoir élevé au carré N fois et de voir où le pic se produit.  Faisons une simulation en Python.  Nous allons retourner à la génération de notre signal BPSK, et au lieu de lui appliquer un retard fractionnel, nous allons appliquer un décalage de fréquence en multipliant le signal par <img class="math" src="../_images/math/226b304dd210bb038b11265f241851a89755b42b.svg" alt="e^{j2\pi f_o t}"/> comme nous l’avons fait dans le chapitre <a class="reference internal" href="filters.html#filters-chapter"><span class="std std-ref">Filtres</span></a> pour convertir un filtre passe-bas en un filtre passe-haut.</p>
<p>En utilisant le code du début de ce chapitre, appliquez un décalage de fréquence de +13 kHz à votre signal numérique.  Cela peut se produire juste avant ou juste après l’ajout du retard fractionné; cela n’a pas d’importance. Quoi qu’il en soit, cela doit se faire <em>après</em> l’impulsion de mise en forme, mais avant d’effectuer toute fonction côté réception, comme la synchronisation temporelle.</p>
<p>Maintenant que nous avons un signal avec un décalage de fréquence de 13kHz, traçons la FFT avant et après la mise au carré, pour voir ce qui se passe. Vous devriez maintenant savoir comment effectuer une FFT, y compris les opérations abs() et fftshift(). Pour cet exercice, peu importe que vous preniez ou non le logarithme ou que vous éleviez au carré le signal après avoir effectué l’opération abs().</p>
<p>Regardez d’abord le signal avant de l’élever au carré (juste une FFT normale):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">samples</span><span class="p">)))</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">psd</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/coarse-freq-sync-before.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/coarse-freq-sync-before.svg" class="align-center" src="../_images/coarse-freq-sync-before.svg" /></a>
<p>On ne voit pas vraiment de pic associé au décalage de la porteuse.  Il est couvert par notre signal.</p>
<p>Maintenant avec l’élévation au carré ajoutée (juste une puissance de 2 parce que c’est une BPSK) :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Ajoutez ceci avant la ligne FFT</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>Il faut zoomer pour voir sur quelle fréquence se trouve le pic :</p>
<a class="reference external image-reference" href="../_images/coarse-freq-sync.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/coarse-freq-sync.svg" class="align-center" src="../_images/coarse-freq-sync.svg" /></a>
<p>Vous pouvez essayer d’augmenter le nombre de symboles simulés (par exemple, 1000 symboles) afin d’avoir suffisamment d’échantillons pour travailler.  Plus il y a d’échantillons dans notre FFT, plus notre estimation du décalage de fréquence sera précise.  Pour rappel, le code ci-dessus doit venir <em>avant</em> la synchornisation de temps.</p>
<p>Le pic de fréquence apparaît à <img class="math" src="../_images/math/04194ee8a94a5914d95f7166a63d9eeef0a33a45.svg" alt="Nf_o"/>.  Nous devons diviser cette valeur (26.6kHz) par 2 pour trouver notre réponse finale, qui est très proche du décalage de fréquence de 13kHz que nous avons appliqué au début du chapitre!  Si vous avez joué avec ce nombre et qu’il n’est plus de 13kHz, ce n’est pas grave.  Assurez-vous simplement que vous êtes conscient de ce que vous avez réglé.</p>
<p>Comme notre fréquence d’échantillonnage est de 1 MHz, les fréquences maximales que nous pouvons voir sont de -500kHz à 500kHz.  Si nous portons notre signal à la puissance N, cela signifie que nous ne pouvons “voir” les décalages de fréquence que jusqu’à <img class="math" src="../_images/math/9f8fbbfae43237084e6408414562f2680f1d1700.svg" alt="500e3/N"/>, ou dans le cas de la BPSK +/- 250kHz.  Si nous recevions un signal QPSK, il ne serait que de +/- 125kHz, et un décalage de la porteuse supérieur ou inférieur à cette valeur serait hors de notre portée avec cette technique.  Pour vous donner une idée du décalage Doppler, si vous transmettez dans la bande des 2.4GHz et que l’émetteur ou le récepteur se déplace à 96km/h (c’est la vitesse relative qui compte), cela entraînera un décalage de fréquence de 214Hz.  Le décalage dû à un oscillateur de mauvaise qualité sera probablement le principal coupable dans cette situation.</p>
<p>En fait, la correction de ce décalage de fréquence se fait exactement comme nous avons simulé le décalage en premier lieu: en multipliant par une exponentielle complexe, mais avec un signe négatif puisque nous voulons supprimer le décalage.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">max_freq</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">psd</span><span class="p">)]</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span> <span class="c1"># période d&#39;échantillonnage</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ts</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="n">Ts</span><span class="p">)</span> <span class="c1"># vecteur de temps</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">max_freq</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>C’est à vous de décider si vous voulez le corriger ou modifier le décalage de fréquence initial que nous avons appliqué au début à un nombre plus petit (comme 500Hz) pour tester la synchronisation de fréquence fine que nous allons maintenant apprendre à faire.</p>
</div>
<div class="section" id="synchronisation-fine-de-la-frequence">
<h2>Synchronisation fine de la fréquence<a class="headerlink" href="#synchronisation-fine-de-la-frequence" title="Permalink to this headline">¶</a></h2>
<p>Ensuite, nous allons passer à la synchronisation fine de la fréquence. L’astuce précédente est plutôt destinée à l’évanouissement grossier, et ce n’est pas une opération en boucle fermée (de type feedback).  Mais pour la synchronisation fine de la fréquence, nous aurons besoin d’une boucle de rétroaction par laquelle nous ferons passer des échantillons, ce qui sera une fois de plus une forme de PLL.  Notre objectif est de ramener le décalage de fréquence à zéro et de l’y maintenir, même si le décalage change au fil du temps.  Nous devons continuellement suivre le décalage.  Les techniques de synchronisation fine de la fréquence fonctionnent mieux avec un signal qui a déjà été synchronisé dans le temps au niveau du symbole, donc le code dont nous parlons dans cette section viendra <em>après</em> la synchronisation temporelle.</p>
<p>Nous allons utiliser une technique appelée boucle de Costas.  Il s’agit d’une forme de PLL spécialement conçue pour la correction du décalage de la fréquence de la porteuse pour les signaux numériques tels que BPSK et QPSK.  Elle a été inventée par John P. Costas chez General Electric dans les années 1950 et a eu un impact majeur sur les communications numériques modernes.  La boucle de Costas supprime le décalage de fréquence tout en fixant le décalage de phase.  L’énergie est alignée avec l’axe I.  La fréquence n’est qu’un changement de phase, ils peuvent donc être suivis comme un tout.  La boucle de Costas est résumée à l’aide du diagramme suivant (notez que les 1/2 ont été laissés de côté dans les équations car ils n’ont pas d’importance fonctionnelle).</p>
<a class="reference external image-reference" href="../_images/costas-loop.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop.svg" class="align-center" src="../_images/costas-loop.svg" /></a>
<p>L’oscillateur commandé en tension (ou VCO en anglais pour <em>voltage controlled oscillator</em>) est simplement un générateur d’ondes sin/cos qui utilise une fréquence basée sur l’entrée.  Dans notre cas, puisque nous simulons un canal sans fil, il ne s’agit pas d’une tension, mais plutôt d’un niveau représenté par une variable.  Elle détermine la fréquence et la phase des ondes sinus et cosinus générées.  Ce qu’il fait, c’est multiplier le signal reçu par une sinusoïde générée en interne, afin de tenter d’annuler le décalage de fréquence et de phase.  Ce comportement est similaire à celui d’une SDR qui effectue une conversion de fréquence et crée les branches I et Q.</p>
<p>Voici le code Python qui constitue notre boucle Costas:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Ces deux paramètres suivants sont ce qu&#39;il faut ajuster, pour rendre la boucle de rétroaction plus rapide ou plus lente (ce qui a un impact sur la stabilité).</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.132</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.00932</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
<span class="n">freq_log</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="c1"># ajuster l&#39;échantillon d&#39;entrée par l&#39;inverse du décalage de phase estimé</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># Voici la formule d&#39;erreur pour une boucle de Costas de 2ème ordre (par exemple pour BPSK)</span>

    <span class="c1"># Avancer la boucle (recalculer la phase et le décalage de fréquence)</span>
    <span class="n">freq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">freq_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="c1"># convertir de la vitesse angulaire en Hz pour la journalisation</span>
    <span class="n">phase</span> <span class="o">+=</span> <span class="n">freq</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>

    <span class="c1"># Facultatif: Ajustez la phase de façon à ce qu&#39;elle soit toujours entre 0 et 2pi, rappelez-vous que la phase s&#39;enroule autour de chaque 2pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">while</span> <span class="n">phase</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="c1"># Tracez la fréquence en fonction du temps pour voir combien de temps il faut pour atteindre le bon décalage.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq_log</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Il y a beaucoup de choses ici, alors passons-les en revue.  Certaines lignes sont simples et d’autres sont super compliquées. <code class="code docutils literal notranslate"><span class="pre">samples</span></code> est notre entrée, et <code class="code docutils literal notranslate"><span class="pre">out</span></code> les échantillons de sortie. <code class="code docutils literal notranslate"><span class="pre">phase</span></code> et <code class="code docutils literal notranslate"><span class="pre">frequency</span></code> sont comme le <code class="code docutils literal notranslate"><span class="pre">mu</span></code> du code de synchronisation temporelle.  Ils contiennent les estimations du décalage actuel, et à chaque itération de la boucle, nous créons les échantillons de sortie en multipliant les échantillons d’entrée par <code class="code docutils literal notranslate"><span class="pre">np.exp(-1j*phase)</span></code>.  La variable <code class="code docutils literal notranslate"><span class="pre">error</span></code> contient la métrique d’erreur, et pour une boucle de Costas d’ordre 2, c’est une équation très simple.  Nous multiplions la partie réelle de l’échantillon (I) par la partie imaginaire (Q), et parce que Q devrait être égal à zéro pour la BPSK, la fonction d’erreur est minimisée lorsqu’il n’y a pas de décalage de phase ou de fréquence qui fait passer l’énergie de I à Q. Pour une boucle de Costas d’ordre 4, c’est encore relativement simple mais pas tout à fait une ligne, car I et Q auront de l’énergie même lorsqu’il n’y a pas de décalage de phase ou de fréquence, pour la QPSK.  Si vous êtes curieux de voir à quoi cela ressemble, cliquez ci-dessous, mais nous ne l’utiliserons pas dans notre code pour le moment.  La raison pour laquelle cela fonctionne pour la QPSK est que lorsque vous prenez la valeur absolue de I et Q, vous obtenez +1+1j, et s’il n’y a pas de décalage de phase ou de fréquence, la différence entre la valeur absolue de I et Q devrait être proche de zéro.</p>
<details>
<summary>Équation d'erreur de la boucle de Costas de l'ordre 4 (pour les curieux)</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For QPSK</span>
<span class="k">def</span> <span class="nf">phase_detector_4</span><span class="p">(</span><span class="n">sample</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">real</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sample</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sample</span><span class="o">.</span><span class="n">real</span>
</pre></div>
</div>
</details><p>Les variables <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> et <code class="code docutils literal notranslate"><span class="pre">beta</span></code> définissent la vitesse de mise à jour de la phase et de la fréquence, respectivement.  Il y a une certaine théorie derrière le choix de ces deux valeurs, mais nous ne l’aborderons pas ici.  Si vous êtes curieux, vous pouvez essayer de modifier <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> et/ou <code class="code docutils literal notranslate"><span class="pre">beta</span></code> pour voir ce qui se passe.</p>
<p>Nous enregistrons la valeur de <code class="code docutils literal notranslate"><span class="pre">freq</span></code> à chaque itération afin de pouvoir la tracer à la fin, pour voir comment la boucle de Costas converge vers le décalage de fréquence correct.  Nous devons multiplier <code class="code docutils literal notranslate"><span class="pre">freq</span></code> par la fréquence d’échantillonnage et convertir la fréquence angulaire en Hz, en la divisant par <img class="math" src="../_images/math/bf50b56b21d67ede45fc1ec5b8213871824fe365.svg" alt="2\pi"/>.  Notez que si vous avez effectué une synchronisation temporelle avant la boucle Costas, vous devrez également diviser par votre facteur de suréchantillonnage <code class="code docutils literal notranslate"><span class="pre">sps</span></code> (par exemple, 8), car les échantillons provenant de la synchronisation temporelle sont à un taux égal à votre taux d’échantillonnage original divisé par <code class="code docutils literal notranslate"><span class="pre">sps</span></code>.</p>
<p>Enfin, après avoir recalculé la phase, nous ajoutons ou supprimons suffisamment de <img class="math" src="../_images/math/adbf740b3ae712140edad99b950ffd8c9ec2919b.svg" alt="2 \pi"/>’s pour maintenir la phase entre 0 et <img class="math" src="../_images/math/adbf740b3ae712140edad99b950ffd8c9ec2919b.svg" alt="2 \pi"/>’s, ce qui enroule la phase autour.</p>
<p>Notre signal avant et après la boucle de Costas ressemble à ceci:</p>
<a class="reference external image-reference" href="../_images/costas-loop-output.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop-output.svg" class="align-center" src="../_images/costas-loop-output.svg" /></a>
<p>Et l’estimation du décalage de fréquence au fil du temps, se stabilisant sur le décalage correct (un décalage de -300Hz a été utilisé dans cet exemple de signal) :</p>
<a class="reference external image-reference" href="../_images/costas-loop-freq-tracking.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/costas-loop-freq-tracking.svg" class="align-center" src="../_images/costas-loop-freq-tracking.svg" /></a>
<p>Il faut près de 70 échantillons pour que l’algorithme se verrouille complètement sur le décalage de fréquence.  Vous pouvez voir que dans mon exemple simulé, il restait environ -300 Hz après la synchronisation grossière de la fréquence.  Les vôtres peuvent varier.  Comme je l’ai déjà mentionné, vous pouvez désactiver la synchronisation grossière de la fréquence et définir le décalage initial de la fréquence à la valeur de votre choix et voir si la boucle de Costas s’en rend compte.</p>
<p>La boucle de Costas, en plus de supprimer le décalage de fréquence, a aligné notre signal BPSK pour qu’il soit sur la partie I, ce qui rend Q à nouveau nul.  Il s’agit d’un effet secondaire pratique de la boucle de Costas, et il permet à la boucle de Costas d’agir essentiellement comme notre démodulateur.  Maintenant, tout ce que nous avons à faire est de prendre I et de voir s’il est supérieur ou inférieur à zéro.  Nous ne saurons pas vraiment comment transformer un négatif et un positif en 0 et 1 parce qu’il peut y avoir ou non une inversion; il n’y a aucun moyen pour la boucle de Costas (ou notre synchronisation temporelle) de le savoir.  C’est là que le codage différentiel entre en jeu.  Il lève l’ambiguïté car les 1 et les 0 sont basés sur le fait que le symbole a changé ou non, et non sur le fait qu’il était +1 ou -1.  Si on ajoute le codage différentiel, on utilise toujours la BPSK.  Nous ajouterions un bloc de codage différentiel juste avant la modulation du côté Tx et juste après la démodulation du côté Rx.</p>
<p>Vous trouverez ci-dessous une animation de la synchronisation temporelle et de la synchronisation de fréquence. La synchronisation temporelle se produit presque immédiatement, mais la synchronisation de fréquence prend presque toute l’animation pour s’installer complètement, et ce parce que <code class="code docutils literal notranslate"><span class="pre">alpha</span></code> et <code class="code docutils literal notranslate"><span class="pre">beta</span></code> ont été réglés trop bas, à 0.005 et 0.001 respectivement.  Le code utilisé pour générer cette animation peut être trouvé <a class="reference external" href="https://github.com/777arc/textbook/blob/master/figure-generating-scripts/costas_loop_animation.py" rel="noopener noreferrer" target="_blank">ici</a>.</p>
<img alt="../_images/costas_animation.gif" class="align-center" src="../_images/costas_animation.gif" />
</div>
<div class="section" id="synchronisation-des-trames">
<h2>Synchronisation des trames<a class="headerlink" href="#synchronisation-des-trames" title="Permalink to this headline">¶</a></h2>
<p>Nous avons vu comment corriger les décalages de temps, de fréquence et de phase dans notre signal reçu.  Mais la plupart des protocoles de communication modernes ne se contentent pas de transmettre des bits en continu à un taux d’utilisation de 100%.  Ils utilisent plutôt des paquets/trames.  Au niveau du récepteur, nous devons être en mesure d’identifier le début d’une nouvelle trame.  Habituellement, l’en-tête de trame (au niveau de la couche MAC) indique le nombre d’octets contenus dans la trame.  Nous pouvons utiliser cette information pour connaître la longueur de la trame, par exemple, en unités d’échantillons ou de symboles.  Néanmoins, la détection du début de la trame est une tâche totalement distincte.  Vous trouverez ci-dessous un exemple de structure de trame WiFi.  Notez que la toute première chose transmise est un en-tête de la couche PHY, et que la première moitié de cet en-tête est un “préambule”.  Ce préambule contient une séquence de synchronisation que le récepteur utilise pour détecter le début des trames, et c’est une séquence connue d’avance par le récepteur.</p>
<a class="reference internal image-reference" href="../_images/wifi-frame.png"><img alt="../_images/wifi-frame.png" class="align-center" src="../_images/wifi-frame.png" style="width: 772.1999999999999px; height: 147.0px;" /></a>
<p>Une méthode courante et simple de détection de ces séquences au niveau du récepteur consiste à effectuer une corrélation croisée entre les échantillons reçus et la séquence connue.  Lorsque la séquence se produit, cette intercorrélation ressemble à une autocorrélation (avec du bruit ajouté).  Typiquement, les séquences choisies pour les préambules auront de belles propriétés d’autocorrélation, telles que l’autocorrélation de la séquence crée un seul pic fort à 0 et aucun autre pic.  Les codes de Barker en sont un exemple. Dans la norme 802.11/WiFi, une séquence de Barker de longueur 11 est utilisée pour les débits de 1 et 2Mbit/sec :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>+1 +1 +1 −1 −1 −1 +1 −1 −1 +1 −1
</pre></div>
</div>
<p>On peut l’assimiler à 11 symboles BPSK.  Nous pouvons regarder l’autocorrélation de cette séquence très facilement en Python :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;same&#39;</span><span class="p">),</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/barker-code.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/barker-code.svg" class="align-center" src="../_images/barker-code.svg" /></a>
<p>Vous pouvez voir qu’il y a 11 (longueur de la séquence) au centre, et -1 ou 0 pour tous les autres délais.  Il fonctionne bien pour trouver le début d’une trame car il intègre essentiellement 11 symboles d’énergie dans une tentative de créer un pic de 1 bit dans la sortie de la corrélation croisée.  En fait, la partie la plus difficile de la détection du début d’une trame est de trouver un bon seuil.  Vous ne voulez pas que des trames qui ne font pas réellement partie de votre protocole le déclenchent.  Cela signifie qu’en plus de la corrélation croisée, vous devez également effectuer une sorte de normalisation de la puissance, que nous n’examinerons pas ici.  En décidant d’un seuil, vous devez faire un compromis entre la probabilité de détection et la probabilité de fausses alarmes.  Rappelez-vous que l’en-tête de trame lui-même contiendra des informations, donc certaines fausses alarmes sont acceptables; vous découvrirez rapidement qu’il ne s’agit pas d’une trame lorsque vous décoderez l’en-tête et que le CRC échouera inévitablement (parce qu’il ne s’agissait pas d’une trame).  Cependant, si certaines fausses alarmes sont acceptables, manquer complètement la détection d’une trame est une mauvaise chose.</p>
<p>Les séquences de Zadoff-Chu, utilisées en LTE, sont une autre séquence présentant d’excellentes propriétés d’autocorrélation.  Elles ont l’avantage de se présenter sous forme d’ensembles; vous pouvez avoir plusieurs séquences différentes qui ont toutes de bonnes propriétés d’autocorrélation, mais elles ne se déclencheront pas les unes les autres (c’est-à-dire qu’elles ont également de bonnes propriétés de corrélation croisée, lorsque vous corrèlez différentes séquences de l’ensemble).  Grâce à cette fonctionnalité, des séquences différentes seront attribuées à différentes stations de bases, de sorte qu’un téléphone puisse non seulement trouver le début de la trame mais aussi savoir de quelle station il reçoit.</p>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pulse_shaping.html" title="Previous document"><span class="section-number">13. </span>Mise en Forme</a>
        </li>
        <li>
          <a href="rds.html" title="Next document"><span class="section-number">15. </span>Exemple bout en bout</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>