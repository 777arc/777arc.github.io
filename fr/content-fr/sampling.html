
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. échantillonnage IQ &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Modulation numérique" href="digital_modulation.html" />
    <link rel="prev" title="2. Domaine fréquentiel" href="frequency_domain.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. échantillonnage IQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#les-bases-de-l-echantillonnage">Les bases de l’échantillonnage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#echantillonnage-de-nyquist">Echantillonnage de Nyquist</a></li>
<li class="toctree-l2"><a class="reference internal" href="#echantillonnage-en-quadrature">Échantillonnage en quadrature</a></li>
<li class="toctree-l2"><a class="reference internal" href="#les-nombres-complexes">Les nombres complexes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#les-nombres-complexes-dans-les-fft">Les nombres complexes dans les FFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cote-recepteur">Côté récepteur</a></li>
<li class="toctree-l2"><a class="reference internal" href="#porteurse-et-descente-en-frequence">Porteurse et Descente en Fréquence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#architectures-des-recepteurs">Architectures des récepteurs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#signaux-en-bande-de-base-et-passe-bande">Signaux en Bande de Base et Passe-Bande</a></li>
<li class="toctree-l2"><a class="reference internal" href="#le-pic-dc-et-le-decalage-dc">Le Pic DC et le décalage DC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#echantillonnage-a-l-aide-de-notre-sdr">Echantillonnage à l’aide de notre SDR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calcul-de-la-puissance-moyenne">Calcul de la puissance moyenne</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calcul-de-la-densite-spectrale-de-puissance">Calcul de la densité spectrale de puissance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aller-plus-loin-anglais">Aller plus loin (anglais)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
      <li>Previous: <a href="frequency_domain.html" title="previous chapter"><span class="section-number">2. </span>Domaine fréquentiel</a></li>
      <li>Next: <a href="digital_modulation.html" title="next chapter"><span class="section-number">4. </span>Modulation numérique</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="frequency_domain.html" title="Previous document"><span class="section-number">2. </span>Domaine fréquentiel</a>
        </li>
        <li>
          <a href="digital_modulation.html" title="Next document"><span class="section-number">4. </span>Modulation numérique</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="echantillonnage-iq">
<span id="sampling-chapter"></span><h1><span class="section-number">3. </span>échantillonnage IQ<a class="headerlink" href="#echantillonnage-iq" title="Permalink to this headline">¶</a></h1>
<p>Dans ce chapitre, nous présentons un concept appelé échantillonnage IQ, ou échantillonnage complexe ou échantillonnage en quadrature.  Nous abordons également l’échantillonnage de Nyquist, les nombres complexes, les porteuses RF, les fréquences intermédiaires, et la densité spectrale de puissance.  L’échantillonnage IQ est la forme d’échantillonnage utilisée par la radio logicielle, ainsi que par de nombreux récepteurs (et émetteurs) numériques.  Il s’agit d’une version légèrement plus complexe de l’échantillonnage numérique ordinaire (jeu de mots), nous allons donc y aller doucement et, avec un peu de pratique, le concept va certainement faire tilt!</p>
<div class="section" id="les-bases-de-l-echantillonnage">
<h2>Les bases de l’échantillonnage<a class="headerlink" href="#les-bases-de-l-echantillonnage" title="Permalink to this headline">¶</a></h2>
<p>Avant d’aborder l’échantillonnage QI, voyons d’abord ce que signifie l’échantillonnage. Vous avez peut-être déjà rencontré l’échantillonnage sans vous en rendre compte en enregistrant des données audio avec un microphone. Le microphone est un transducteur qui convertit les ondes sonores en un signal électrique (un niveau de tension). Ce signal électrique est transformé par un convertisseur analogique-numérique (CAN), produisant une représentation numérique de l’onde sonore. Pour simplifier, le microphone capte les ondes sonores qui sont converties en électricité, et cette électricité est à son tour convertie en nombres. Le CAN fait le lien entre les domaines analogique et numérique. Les SDR sont étonnamment similaires. Au lieu d’un microphone, ils utilisent une antenne, et utilisent également des ADC. Dans les deux cas, le niveau de tension est échantillonné par un CAN. Pour les SDR, il s’agit d’ondes radio en entrée et de nombres en sortie.</p>
<p>Qu’il s’agisse d’audio ou de radiofréquences, nous devons échantillonner si nous voulons capturer, traiter ou enregistrer un signal numériquement.  L’échantillonnage peut sembler simple, mais il est très complexe.  Une façon plus technique d’envisager l’échantillonnage d’un signal est de saisir des valeurs à des moments précis et de les sauvegarder numériquement. Disons que nous avons une fonction aléatoire, <img class="math" src="../_images/math/097ad9d7221d263c5c30372cb84f502da58dc6ff.svg" alt="S(t)"/>, qui peut représenter n’importe quoi, et que c’est une fonction continue que nous voulons échantillonner :</p>
<img alt="../_images/sampling.svg" class="align-center" src="../_images/sampling.svg" /><p>Nous enregistrons la valeur de <img class="math" src="../_images/math/097ad9d7221d263c5c30372cb84f502da58dc6ff.svg" alt="S(t)"/> à intervalles réguliers de <img class="math" src="../_images/math/51acb7b4939189dc34f1c1f10cf8acb7aeb5218a.svg" alt="T"/> secondes, appelés <strong>période d’échantillonnage</strong>.  La fréquence à laquelle nous échantillonnons, c’est-à-dire le nombre d’échantillons prélevés par seconde, est simplement <img class="math" src="../_images/math/a32df15aba09f5932ad327e03821a26c43439f98.svg" alt="\frac{1}{T}"/>.  Nous l’appelons le <strong>taux d’échantillonnage</strong>, et c’est l’inverse de la période d’échantillonnage. Par exemple, si nous avons une fréquence d’échantillonnage de 10 Hz, la période d’échantillonnage est de 0.1 seconde; il y aura 0.1 seconde entre chaque échantillon.  Dans la pratique, nos fréquences d’échantillonnage seront de l’ordre de centaines de kHz à des dizaines de MHz, voire plus. Lorsque nous échantillonnons des signaux, nous devons être attentifs à la fréquence d’échantillonnage, c’est un paramètre très important.</p>
<p>Pour ceux qui préfèrent les mathématiques, soit <img class="math" src="../_images/math/15edb6f2acafa5e06d8997e1682d87cc39351360.svg" alt="S_n"/> l’échantillon <img class="math" src="../_images/math/f7a9f3c7a45b9df2dac17c2a197dd82e66e4a44a.svg" alt="n"/>, généralement un nombre entier commençant à 0. En utilisant cette convention, le processus d’échantillonnage peut être représenté mathématiquement comme <img class="math" src="../_images/math/b5116a6f84baffdd75bcbf68ab2adfbaa31357bc.svg" alt="S_n = S(nT)"/> pour des valeurs entières de <img class="math" src="../_images/math/f7a9f3c7a45b9df2dac17c2a197dd82e66e4a44a.svg" alt="n"/>.  C’est-à-dire que nous évaluons le signal analogique <img class="math" src="../_images/math/097ad9d7221d263c5c30372cb84f502da58dc6ff.svg" alt="S(t)"/> à ces intervalles de <img class="math" src="../_images/math/f64c1fd61d41bf096882352bc2e26a0f173e538d.svg" alt="nT"/>.</p>
</div>
<div class="section" id="echantillonnage-de-nyquist">
<h2>Echantillonnage de Nyquist<a class="headerlink" href="#echantillonnage-de-nyquist" title="Permalink to this headline">¶</a></h2>
<p>Pour un signal donné, la grande question est souvent de savoir à quelle vitesse nous devons échantillonner. Examinons un signal qui est juste une onde sinusoïdale, de fréquence f, représentée en vert ci-dessous. Disons que nous échantillonnons à une fréquence Fs (échantillons représentés en bleu).  Si nous échantillonnons ce signal à une fréquence égale à f (c’est-à-dire Fs = f), nous obtiendrons quelque chose qui ressemble à ceci:</p>
<img alt="../_images/sampling_Fs_0.3.svg" class="align-center" src="../_images/sampling_Fs_0.3.svg" /><p>La ligne pointillée rouge dans l’image ci-dessus reconstruit une fonction différente (incorrecte) qui aurait pu conduire à l’enregistrement des mêmes échantillons. Elle indique que notre taux d’échantillonnage était trop faible car les mêmes échantillons auraient pu provenir de deux fonctions différentes, entraînant une ambiguïté. Si nous voulons reconstruire avec précision le signal original, nous ne pouvons pas tolérer cette ambiguïté.</p>
<p>Essayons d’échantillonner un peu plus rapidement, à Fs = 1.2f:</p>
<img alt="../_images/sampling_Fs_0.36.svg" class="align-center" src="../_images/sampling_Fs_0.36.svg" /><p>Là encore, il existe un signal différent qui pourrait correspondre à ces échantillons. Cette ambiguïté signifie que si quelqu’un nous donnait cette liste d’échantillons, nous ne pourrions pas distinguer quel signal est le signal original sur la base de notre échantillonnage.</p>
<p>Que diriez-vous d’un échantillonnage à Fs = 1.5f:</p>
<img alt="../_images/sampling_Fs_0.45.svg" class="align-center" src="../_images/sampling_Fs_0.45.svg" /><p>Toujours pas assez rapide! Selon une partie de la théorie du DSP dans laquelle nous ne nous plongerons pas, vous devez échantillonner à <strong>deux fois</strong> la fréquence du signal afin de lever l’ambiguïté que nous rencontrons:</p>
<img alt="../_images/sampling_Fs_0.6.svg" class="align-center" src="../_images/sampling_Fs_0.6.svg" /><p>Il n’y a pas de signal erroné cette fois-ci, car nous avons échantillonné suffisamment rapidement pour qu’il n’existe aucun signal correspondant à ces échantillons autre que celui que vous voyez (à moins que vous n’alliez <em>plus haut</em> en fréquence, mais nous en discuterons plus tard).</p>
<p>Dans l’exemple ci-dessus, notre signal était une simple onde sinusoïdale. La plupart des signaux réels comportent de nombreuses composantes de fréquence. Pour échantillonner avec précision un signal donné, la fréquence d’échantillonnage doit être “au moins deux fois la fréquence de la composante de fréquence maximale”. Voici une visualisation à l’aide d’un exemple de tracé dans le domaine fréquentiel. Notez qu’il y aura toujours un plancher de bruit et que la fréquence la plus élevée est généralement une approximation:</p>
<img alt="../_images/max_freq.svg" class="align-center" src="../_images/max_freq.svg" /><p>Nous devons identifier la composante de fréquence la plus élevée, puis la doubler, et nous assurer que nous échantillonnons à cette fréquence ou plus rapidement. La fréquence minimale à laquelle nous pouvons échantillonner est connue sous le nom de taux de Nyquist. En d’autres termes, le taux de Nyquist est le taux minimum auquel un signal (à bande passante finie) doit être échantillonné pour conserver toutes ses informations. Il s’agit d’un élément théorique extrêmement important dans le domaine du DSP et de la SDR, qui sert de pont entre les signaux continus et discrets.</p>
<a class="reference internal image-reference" href="../_images/nyquist_rate.png"><img alt="../_images/nyquist_rate.png" class="align-center" src="../_images/nyquist_rate.png" style="width: 364.7px; height: 158.2px;" /></a>
<p>Si l’échantillonnage n’est pas assez rapide, nous obtenons ce que l’on appelle le repliement ou l’alaising, dont nous parlerons plus tard, et que nous essayons d’éviter à tout prix. Ce que font nos SDR (et la plupart des récepteurs en général), c’est filtrer tout ce qui est au-dessus de Fs/2 juste avant l’échantillonnage. Si nous essayons de recevoir un signal avec une fréquence d’échantillonnage trop faible, ce filtre coupera une partie du signal. Nos récepteurs SDR se donnent beaucoup de mal pour nous fournir des échantillons exempts de repliement ainsi que d’autres imperfections.</p>
</div>
<div class="section" id="echantillonnage-en-quadrature">
<h2>Échantillonnage en quadrature<a class="headerlink" href="#echantillonnage-en-quadrature" title="Permalink to this headline">¶</a></h2>
<p>Le terme “quadrature” a de nombreuses significations, mais dans le contexte du DSP et de la SDR, il désigne deux ondes déphasées de 90 degrés. Pourquoi un déphasage de 90 degrés? Observez que deux ondes qui sont déphasées de 180 degrés sont essentiellement la même onde avec une multipliée par -1. En étant déphasées de 90 degrés, elles deviennent orthogonales, et il y a beaucoup de choses intéressantes à faire avec les fonctions orthogonales. Par souci de simplicité, nous utilisons le sinus et le cosinus comme nos deux ondes sinusoïdales déphasées de 90 degrés.</p>
<p>Ensuite, attribuons des variables pour représenter la <strong>amplitude</strong> du sinus et du cosinus.  Nous utiliserons <img class="math" src="../_images/math/39034215a6dc97c339d8d966435f213b2d5f1205.svg" alt="I"/> pour le cos() et <img class="math" src="../_images/math/4aefab53c6f372bea2c7ebee8743862e44376226.svg" alt="Q"/> pour le sin():</p>
<div class="math">
<p><img src="../_images/math/80a7eb6646b7124039443483ffd0ac0abc437075.svg" alt="I \cos(2\pi ft)

Q \sin(2\pi ft)"/></p>
</div><p>Nous pouvons le constater visuellement en traçant I et Q égaux à 1 :</p>
<a class="reference internal image-reference" href="../_images/IQ_wave.png"><img alt="../_images/IQ_wave.png" class="align-center" src="../_images/IQ_wave.png" style="width: 481.59999999999997px; height: 242.2px;" /></a>
<p>Nous appelons le fonction cos() la composante “en phase”, noté par la lettre I (pour <em>in-phase</em> en anglais), et le sin() la composante “en quadrature”, d’où Q. Toutefois, si vous mélangez accidentellement les deux et attribuez Q au cos() et I au sin(), cela ne fera pas de différence dans la plupart des situations.</p>
<p>L’échantillonnage IQ est plus facile à comprendre en se plaçant du point de vue de l’émetteur, c’est-à-dire en considérant la tâche consistant à transmettre un signal RF dans l’air. Ce que nous faisons, en tant qu’émetteur, c’est additionner la composante sin() et la composante cos(). Disons que x(t) est notre signal à transmettre:</p>
<div class="math">
<p><img src="../_images/math/85952bb9ba66501bd120de475a08d40ff06ed52b.svg" alt="x(t) = I \cos(2\pi ft)  + Q \sin(2\pi ft)"/></p>
</div><p>Que se passe-t-il lorsque l’on additionne un sinus et un cosinus? Ou plutôt, que se passe-t-il lorsque nous additionnons deux sinusoïdes déphasées de 90 degrés? Dans l’animation ci-dessous, il y a un curseur pour ajuster I et un autre pour ajuster Q. Ce qui est tracé est le cosinus, le sinus, et ensuite la somme des deux.</p>
<a class="reference internal image-reference" href="../_images/IQ3.gif"><img alt="../_images/IQ3.gif" class="align-center" src="../_images/IQ3.gif" style="width: 600.0px; height: 396.0px;" /></a>
<p>(Le code utilisé pour cette application Python pyqtgraph se trouve à l’adresse suivante <a class="reference external" href="https://raw.githubusercontent.com/777arc/textbook/master/figure-generating-scripts/sin_plus_cos.py" rel="noopener noreferrer" target="_blank">ici</a>)</p>
<p>Ce qu’il faut retenir, c’est que lorsque nous additionnons le cos() et le sin(), nous obtenons une autre onde sinusoïdale pure avec une phase et une amplitude différentes. De plus, la phase se décale lorsque nous retirons ou ajoutons lentement l’une des deux parties. L’amplitude change également. Tout ceci est le résultat de l’identité trigonométrique : <img class="math" src="../_images/math/ab3695b42f9cb6efd2d838efca3dd84c82e2f586.svg" alt="a \cos(x) + b \sin(x) = A \cos(x-\phi)"/>, sur laquelle nous reviendrons plus tard. “L’utilité” de ce résultat est que nous pouvons contrôler la phase et l’amplitude d’une onde sinusoïdale résultante en ajustant les amplitudes I et Q (nous n’avons pas besoin d’ajuster la phase du cosinus ou du sinus). Par exemple, nous pouvons ajuster I et Q de manière à ce que l’amplitude reste constante et que la phase soit celle que nous voulons. En tant qu’émetteur, cette approche est extrêmement utile car nous savons que nous devons transmettre un signal sinusoïdal pour qu’il se propage dans l’air comme une onde électromagnétique. Et il est beaucoup plus facile de régler deux amplitudes et d’effectuer une opération d’addition que de régler une amplitude et une phase. Le résultat est que notre émetteur ressemblera à quelque chose comme ceci:</p>
<a class="reference internal image-reference" href="../_images/IQ_diagram.png"><img alt="../_images/IQ_diagram.png" class="align-center" src="../_images/IQ_diagram.png" style="width: 434.40000000000003px; height: 256.8px;" /></a>
<p>Il nous suffit de générer une onde sinusoïdale et de la décaler de 90 degrés pour obtenir la partie Q.</p>
</div>
<div class="section" id="les-nombres-complexes">
<h2>Les nombres complexes<a class="headerlink" href="#les-nombres-complexes" title="Permalink to this headline">¶</a></h2>
<p>En fin de compte, la convention IQ est un moyen alternatif de représenter la magnitude et la phase, ce qui nous amène aux nombres complexes et à la possibilité de les représenter sur un plan complexe. Vous avez peut-être déjà vu des nombres complexes dans d’autres cours. Prenons par exemple le nombre complexe 0.7-0.4j:</p>
<a class="reference internal image-reference" href="../_images/complex_plane_1.png"><img alt="../_images/complex_plane_1.png" class="align-center" src="../_images/complex_plane_1.png" style="width: 258.3px; height: 251.99999999999997px;" /></a>
<p>Un nombre complexe n’est en fait que deux nombres réunis, une partie réelle et une partie imaginaire. Un nombre complexe a également une magnitude et une phase, ce qui est plus logique si vous le considérez comme un vecteur plutôt que comme un point. La magnitude est la longueur de la ligne entre l’origine et le point (c’est-à-dire la longueur du vecteur), tandis que la phase est l’angle entre ce vecteur et la ligne à 0 degré, que nous définissons comme l’axe réel positif:</p>
<a class="reference internal image-reference" href="../_images/complex_plane_2.png"><img alt="../_images/complex_plane_2.png" class="align-center" src="../_images/complex_plane_2.png" style="width: 246.39999999999998px; height: 240.79999999999998px;" /></a>
<p>Cette représentation d’une sinusoïde est connue sous le nom de “diagramme de phase”. Il s’agit simplement de tracer des nombres complexes et de les traiter comme des vecteurs. Maintenant, quelles sont la magnitude et la phase de notre exemple de nombre complexe 0.7-0.4j?  Pour un nombre complexe donné où <img class="math" src="../_images/math/375383b47352eb6cd2f5c760a77a36e69e4ed098.svg" alt="a"/> est la partie réelle et <img class="math" src="../_images/math/b9226f3d70379a250fb90320a3c57039c88e5f51.svg" alt="b"/> la partie imaginaire :</p>
<div class="math">
<p><img src="../_images/math/b5a551214962cc324e2172e9b8f0227114232a90.svg" alt="\mathrm{magnitude} = \sqrt{a^2 + b^2} = 0.806

\mathrm{phase} = \tan^{-1} \left( \frac{b}{a} \right) = -29.7^{\circ} = -0.519 \quad \mathrm{radians}"/></p>
</div><p>En Python, vous pouvez utiliser np.abs(x) et np.angle(x) pour la magnitude et la phase. L’entrée peut être un nombre complexe ou un tableau de nombres complexes, et la sortie sera un ou plusieurs nombres <strong>réels</strong> (du type float).</p>
<p>Vous avez peut-être déjà compris comment ce diagramme vectoriel est lié à la convention IQ: I est réel et Q est imaginaire. À partir de maintenant, lorsque nous dessinerons le plan complexe, nous l’étiquetterons avec I et Q au lieu de réel et imaginaire. Mais il s’agira toujours des mmême nombres complexes!</p>
<a class="reference internal image-reference" href="../_images/complex_plane_3.png"><img alt="../_images/complex_plane_3.png" class="align-center" src="../_images/complex_plane_3.png" style="width: 221.89999999999998px; height: 230.99999999999997px;" /></a>
<p>Disons maintenant que nous voulons transmettre notre point d’exemple 0.7-0.4j. Nous allons transmettre:</p>
<div class="math">
<p><img src="../_images/math/c01b0df5cd8a4203575a68a9140c0533158e2092.svg" alt="x(t) = I \cos(2\pi ft)  + Q \sin(2\pi ft)

\quad \quad \quad = 0.7 \cos(2\pi ft) - 0.4 \sin(2\pi ft)"/></p>
</div><p>Nous pouvons utiliser l’identité trigonométrique <img class="math" src="../_images/math/ab3695b42f9cb6efd2d838efca3dd84c82e2f586.svg" alt="a \cos(x) + b \sin(x) = A \cos(x-\phi)"/> où <img class="math" src="../_images/math/ac179881032d4f94f75075513db7b13aba211803.svg" alt="A"/> est notre magnitude trouvée avec <img class="math" src="../_images/math/293562bb226d0886091673a318188c3719f6b8f3.svg" alt="\sqrt{I^2 + Q^2}"/> et <img class="math" src="../_images/math/f41d2a61cd1827c3e57537176609abab588ccc27.svg" alt="\phi"/> est notre phase, égale à <img class="math" src="../_images/math/df5e33a7622555c99bdbd841c05645a2204f49dc.svg" alt="\tan^{-1} \left( Q/I \right)"/>. L’équation ci-dessus devient alors:</p>
<div class="math">
<p><img src="../_images/math/94756445d61a3e62aa78948913becd1a7245b5a7.svg" alt="x(t) = 0.806 \cos(2\pi ft + 0.519)"/></p>
</div><p>Même si nous avons commencé avec un nombre complexe, ce que nous transmettons est réel, ce qui est une bonne chose car vous ne pouvez pas réellement transmettre quelque chose d’imaginaire avec des ondes électromagnétiques. Nous utilisons simplement des nombres imaginaires/complexes pour représenter <em>ce que</em> nous transmettons. Nous parlerons bientôt de la fonction <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/>.</p>
</div>
<div class="section" id="les-nombres-complexes-dans-les-fft">
<h2>Les nombres complexes dans les FFT<a class="headerlink" href="#les-nombres-complexes-dans-les-fft" title="Permalink to this headline">¶</a></h2>
<p>Les nombres complexes ci-dessus ont été supposés être des échantillons du domaine temporel, mais vous rencontrerez également des nombres complexes lorsque vous effectuerez une FFT. Lorsque nous avons abordé les séries de Fourier et les FFT au chapitre précédent, nous n’avions pas encore plongé dans les nombres complexes. Lorsque vous effectuez la FFT d’une série d’échantillons, vous obtenez la représentation dans le domaine fréquentiel. Nous avons parlé de la façon dont la FFT détermine quelles fréquences existent dans cet ensemble d’échantillons (l’amplitude de la FFT indique la “puissance” de chaque fréquence). Mais la FFT détermine également le retard (décalage temporel) nécessaire à appliquer à chacune de ces fréquences, afin que l’ensemble des sinusoïdes puisse être additionné pour reconstruire le signal dans le domaine temporel. Ce retard est simplement la phase de la FFT. La sortie d’une FFT est un tableau de nombres complexes, et chaque nombre complexe vous donne la magnitude et la phase, et l’indice de ce nombre vous donne la fréquence. Si vous générez des sinusoïdes à ces fréquences/amplitudes/phases et que vous les additionnez, vous obtiendrez votre signal original dans le domaine temporel (ou quelque chose de très proche, et c’est là que le théorème d’échantillonnage de Nyquist entre en jeu).</p>
</div>
<div class="section" id="cote-recepteur">
<h2>Côté récepteur<a class="headerlink" href="#cote-recepteur" title="Permalink to this headline">¶</a></h2>
<p>Prenons maintenant la perspective d’un récepteur radio qui essaie de recevoir un signal (par exemple, un signal radio FM). En utilisant l’échantillonnage IQ, le diagramme se présente maintenant comme suit:</p>
<a class="reference internal image-reference" href="../_images/IQ_diagram_rx.png"><img alt="../_images/IQ_diagram_rx.png" class="align-center" src="../_images/IQ_diagram_rx.png" style="width: 409.5px; height: 225.39999999999998px;" /></a>
<p>Ce qui entre est un signal réel reçu par notre antenne, et ceux-ci sont transformés en valeurs IQ.  Ce que nous faisons, c’est échantillonner les branches I et Q individuellement, en utilisant deux ADC, puis nous combinons les paires et les stockons sous forme de nombres complexes. En d’autres termes, à chaque pas de temps, on échantillonne une valeur I et une valeur Q et on les combine sous la forme <img class="math" src="../_images/math/d51b1ee62b9705749afbf567d0f9576f9e8588cf.svg" alt="I + jQ"/> (c’est-à-dire un nombre complexe par échantillon IQ).  Il y aura toujours une “fréquence d’échantillonnage”, c’est-à-dire la vitesse à laquelle l’échantillonnage est effectué. Quelqu’un pourrait dire : “J’ai une radio logicielle qui fonctionne à une fréquence d’échantillonnage de 2 MHz”. Ce qu’il veut dire, c’est que la radio logicielle génère deux millions d’échantillons IQ par seconde.</p>
<p>Si quelqu’un vous donne un fichier d’échantillons QI, cela ressemblera à un tableau/vecteur 1D de nombres complexes. Ce point, complexe ou non, est le but de départ de tout ce chapitre, et nous l’avons finalement atteint.</p>
<p>Tout au long de ce manuel, vous deviendrez <strong>très</strong> familier avec le fonctionnement des échantillons IQ, comment les recevoir et les transmettre avec un SDR, comment les traiter dans Python et comment les enregistrer dans un fichier pour une analyse ultérieure.</p>
<p>Une dernière remarque importante: la figure ci-dessus montre ce qui se passe <strong>à l’intérieur</strong> de la SDR. Nous n’avons pas besoin de générer une onde sinusoïdale, de la décaler de 90, de la multiplier ou de l’additionner - la SDR le fait pour nous. Nous indiquons à la SDR la fréquence à laquelle nous voulons échantillonner, ou la fréquence à laquelle nous voulons transmettre nos échantillons. Du côté du récepteur, le SDR nous fournira les échantillons IQ. Du côté de l’émetteur, nous devons fournir au SDR les échantillons IQ. En termes de type de données, il s’agira soit d’entiers complexes, soit de flottants.</p>
</div>
<div class="section" id="porteurse-et-descente-en-frequence">
<h2>Porteurse et Descente en Fréquence<a class="headerlink" href="#porteurse-et-descente-en-frequence" title="Permalink to this headline">¶</a></h2>
<p>Jusqu’à présent, nous n’avons pas parlé de la fréquence, mais nous avons vu qu’il y avait un <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> dans les équations impliquant le cos() et le sin(). Cette fréquence est la fréquence de l’onde sinusoïdale que nous envoyons réellement dans l’air (la fréquence de l’onde électromagnétique). Nous l’appelons la “porteuse” car elle transporte nos informations sur une certaine fréquence. Lorsque nous nous accordons sur une fréquence avec notre SDR et recevons des échantillons, nos informations sont stockées dans I et Q; cette porteuse n’apparaît pas dans I et Q, en supposant que nous nous sommes réglés sur la porteuse.</p>
<a class="reference internal image-reference" href="../_images/carrier.png"><img alt="../_images/carrier.png" class="align-center" src="../_images/carrier.png" style="width: 366.09999999999997px; height: 186.89999999999998px;" /></a>
<p>Pour référence, les signaux radio tels que la radio FM, le WiFi, le Bluetooth, le LTE, le GPS, etc., utilisent généralement une fréquence (c’est-à-dire une porteuse) comprise entre 100 MHz et 6 GHz. Ces fréquences se déplacent vraiment bien dans l’air, mais elles ne nécessitent pas de super longues antennes ou une grande puissance pour transmettre ou recevoir. Votre micro-ondes cuit les aliments avec des ondes électromagnétiques à 2.4 GHz. S’il y a une fuite dans la porte, votre micro-ondes brouillera les signaux WiFi et pourra peut-être aussi vous brûler la peau. La lumière est une autre forme d’ondes électromagnétiques. La lumière visible a une fréquence d’environ 500 THz. Cette fréquence est si élevée que nous n’utilisons pas d’antennes traditionnelles pour transmettre la lumière. Nous utilisons des méthodes comme les LED, qui sont des dispositifs semi-conducteurs. Elles créent de la lumière lorsque les électrons sautent entre les orbites atomiques du matériau semi-conducteur, et la couleur dépend de la distance à laquelle ils sautent. Techniquement, la radiofréquence (RF) est définie comme la plage comprise entre 20 kHz et 300 GHz environ. Il s’agit des fréquences auxquelles l’énergie d’un courant électrique oscillant peut rayonner à partir d’un conducteur (une antenne) et voyager dans l’espace. Les fréquences comprises entre 100 MHz et 6 GHz sont les plus utiles, du moins pour la plupart des applications modernes. Les fréquences supérieures à 6 GHz ont été utilisées pour les radars et les communications par satellite pendant des décennies, et sont maintenant utilisées dans la 5G “mmWave” (24 - 29 GHz) pour compléter les bandes inférieures et augmenter les débits.</p>
<p>Lorsque nous changeons rapidement nos valeurs IQ et que nous transmettons notre porteuse, cela s’appelle “moduler” la porteuse (avec des données ou ce que nous voulons).  Lorsque nous changeons I et Q, nous modifions la phase et l’amplitude de la porteuse.  Une autre option consiste à modifier la fréquence de la porteuse, c’est-à-dire à la décaler légèrement vers le haut ou vers le bas, ce que fait la radio FM.</p>
<p>Pour prendre un exemple simple, disons que nous transmettons l’échantillon IQ 1+0j, puis que nous passons à la transmission de 0+1j.  Nous passons de <img class="math" src="../_images/math/500350f14f961e15e3aa1cc429df3236aba61acd.svg" alt="\cos(2\pi ft)"/> à <img class="math" src="../_images/math/9af12e10a6d9c096760b9646a4d41f6f9a0176f7.svg" alt="\sin(2\pi ft)"/>, ce qui signifie que notre porteuse se déphase de 90 degrés lorsque nous passons d’un échantillon à un autre.</p>
<p>Revenons maintenant à l’échantillonnage pour une seconde.  Au lieu de recevoir des échantillons en multipliant ce qui provient de l’antenne par un cos() et un sin() puis en enregistrant I et Q, que se passerait-il si nous envoyions le signal de l’antenne dans un seul CAN, comme dans l’architecture d’échantillonnage direct dont nous venons de parler?  Supposons que la fréquence porteuse soit de 2.4 GHz, comme le WiFi ou le Bluetooth. Cela signifie que nous devrions échantillonner à 4.8 GHz, comme nous l’avons appris. C’est extrêmement rapide! Un CAN qui échantillonne aussi rapidement coûte des milliers de dollars. Au lieu de cela, nous “descendant en fréquence” (<em>downconversion</em> en anglais) le signal pour que le signal que nous voulons échantillonner soit centré sur le courant continu ou 0 Hz. Cette descente en fréquence a lieu avant l’échantillonnage. Nous passons de:</p>
<div class="math">
<p><img src="../_images/math/80a7eb6646b7124039443483ffd0ac0abc437075.svg" alt="I \cos(2\pi ft)

Q \sin(2\pi ft)"/></p>
</div><p>à juste I et Q.</p>
<p>Visualisons la conversion de fréquence dans le domaine des fréquences:
.. image:: ../_images/downconversion.png</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">scale:</th><td class="field-body">60%</td>
</tr>
<tr class="field-even field"><th class="field-name">align:</th><td class="field-body">center</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Lorsque nous sommes centrés autour de 0 Hz, la fréquence maximale n’est plus de 2,4 GHz mais est basée sur les caractéristiques du signal car nous avons supprimé la porteuse. La plupart des signaux ont une largeur de bande d’environ 100 kHz à 40 MHz, de sorte que, grâce à la conversion de fréquence, nous pouvons échantillonner à un taux <em>beaucoup</em> plus faible. Les USRP B2X0 et PlutoSDR contiennent un circuit intégré RF (RFIC) qui peut échantillonner jusqu’à 56 MHz, ce qui est suffisamment élevé pour la plupart des signaux que nous rencontrerons dans la vie de tous les jours.</p>
<p>Pour rappel, le processus de conversion de fréquence est effectué par notre SDR; en tant qu’utilisateur de la SDR, nous n’avons rien à faire autre que de lui indiquer sur quelle fréquence s’accorder. La conversion de fréquence est effectuée par un composant appelé mélangeur, généralement représenté dans les diagrammes par un symbole de multiplication à l’intérieur d’un cercle.  Le mélangeur reçoit un signal, émet le signal converti en fréquence et possède un troisième port d’entrée pour un oscillateur. La fréquence de l’oscillateur détermine le décalage de fréquence appliqué au signal, et le mélangeur est essentiellement une fonction de multiplication (rappelons que la multiplication par une sinusoïde entraîne justement un décalage de fréquence).</p>
<p>Enfin, vous êtes peut-être curieux de savoir à quelle vitesse les signaux se déplacent dans l’air.  Rappelez-vous que les ondes radio ne sont que des ondes électromagnétiques à basse fréquence (entre 3 kHz et 80 GHz environ). La lumière visible est également constituée d’ondes électromagnétiques, à des fréquences beaucoup plus élevées (400 THz à 700 THz). Toutes les ondes électromagnétiques se déplacent à la vitesse de la lumière, qui est d’environ 3e8 m/s, du moins lorsqu’elles se déplacent dans le vide. Comme elles se déplacent toujours à la même vitesse, la distance parcourue par l’onde en une oscillation complète (une période complète de l’onde sinusoïdale) dépend de sa fréquence.  Nous appelons cette distance la longueur d’onde, désignée par <img class="math" src="../_images/math/5d20f71e79182adab536e881e1c524d2a073268f.svg" alt="\lambda"/>.  Vous avez probablement déjà vu cette relation :</p>
<div class="math">
<p><img src="../_images/math/df4ec1581556a2443c91c41eecd5bb92336ea3da.svg" alt="f = \frac{c}{\lambda}"/></p>
</div><p>où <img class="math" src="../_images/math/341ae5f7c52af1963e056b70131682274a396508.svg" alt="c"/> est la vitesse de la lumière, généralement fixée à 3e8 lorsque <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> est en Hz et :math:<a href="#id1"><span class="problematic" id="id2">``</span></a>lambda` en mètre.  Dans le domaine des communications sans fil, cette relation devient importante lorsqu’il s’agit d’antennes, car pour recevoir un signal à une certaine fréquence porteuse, <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/>, vous avez besoin d’une antenne qui correspond à sa longueur d’onde, <img class="math" src="../_images/math/5d20f71e79182adab536e881e1c524d2a073268f.svg" alt="\lambda"/>, généralement l’antenne a une longueur de <img class="math" src="../_images/math/2fc2aecc8a1770c94019faa3ff6548fa89ac9144.svg" alt="\lambda/2"/> ou <img class="math" src="../_images/math/90b1c873bdb5a2fb7b76cec5eb1d5fe1ab3872f5.svg" alt="\lambda/4"/>.  Cependant, quelle que soit la fréquence/longueur d’onde, l’information transportée par ce signal se déplace toujours à la vitesse de la lumière, de l’émetteur au récepteur.  Pour calculer ce délai dans l’air, une règle empirique est que la lumière parcourt environ un 30 cm en une nanoseconde. Autre règle empirique : un signal se rendant à un satellite en orbite géostationnaire et en revenant prendra environ 0.25 seconde pour l’ensemble du trajet.</p>
</div>
<div class="section" id="architectures-des-recepteurs">
<h2>Architectures des récepteurs<a class="headerlink" href="#architectures-des-recepteurs" title="Permalink to this headline">¶</a></h2>
<p>La figure de la section “Côté récepteur” montre comment le signal d’entrée est converti et divisé en I et Q. Cet arrangement est appelé “conversion directe”, car les fréquences RF sont directement converties en bande de base. Une autre option consiste à ne pas effectuer de conversion de fréquence du tout et à échantillonner très rapidement pour tout capturer de 0 Hz à la moitié de la fréquence d’échantillonnage. Cette stratégie est appelée “échantillonnage direct”, et elle nécessite une puce CAN extrêmement coûteuse.  Une troisième architecture, populaire car c’est ainsi que fonctionnaient les anciennes radios, est connue sous le nom de “superhétérodyne”. Elle implique une conversion vers le bas, mais pas jusqu’à 0 Hz. Elle place le signal d’intérêt à une fréquence intermédiaire, appelée “FI”.  Un amplificateur à faible bruit (LNA pour <em>Low Noise Amplifier</em> en anglais) est simplement un amplificateur conçu pour des signaux de très faible puissance à l’entrée.  Voici les schémas fonctionnels de ces trois architectures, notez que des variations et des hybrides de ces architectures existent également :</p>
<img alt="../_images/receiver_arch_diagram.svg" class="align-center" src="../_images/receiver_arch_diagram.svg" /></div>
<div class="section" id="signaux-en-bande-de-base-et-passe-bande">
<h2>Signaux en Bande de Base et Passe-Bande<a class="headerlink" href="#signaux-en-bande-de-base-et-passe-bande" title="Permalink to this headline">¶</a></h2>
<p>On dit d’un signal centré autour de 0 Hz qu’il est en “bande de base”.  À l’inverse, on parle de “bande passante” lorsqu’un signal existe à une fréquence RF qui n’est pas proche de 0 Hz, mais qui a été décalée vers le haut dans le but d’une transmission sans fil.  Il n’y a pas de notion de “transmission en bande de base”, car on ne peut pas transmettre quelque chose d’imaginaire.  Un signal en bande de base peut être parfaitement centré à 0 Hz, comme la partie droite de la figure de la section précédente. Il peut être <em>proche</em> de 0 Hz, comme les deux signaux illustrés ci-dessous. Ces deux signaux sont toujours considérés comme étant en bande de base. Vous trouverez également un exemple de signal passe-bande, centré sur une fréquence très élevée notée <img class="math" src="../_images/math/852c5d6001dcb2c5d6047cc1ee451735a4153eec.svg" alt="f_c"/>.</p>
<a class="reference internal image-reference" href="../_images/baseband_bandpass.png"><img alt="../_images/baseband_bandpass.png" class="align-center" src="../_images/baseband_bandpass.png" style="width: 712.0px; height: 186.5px;" /></a>
<p>Vous pouvez également entendre le terme de fréquence intermédiaire (abrégé en FI); pour l’instant, considérez la FI comme une étape de conversion intermédiaire dans une radio entre la bande de base et la bande passante RF.</p>
<p>Nous avons tendance à créer, enregistrer ou analyser des signaux en bande de base parce que nous pouvons travailler à une fréquence d’échantillonnage inférieure (pour les raisons évoquées dans la sous-section précédente).  Il est important de noter que les signaux en bande de base sont souvent des signaux complexes, tandis que les signaux en bande passante (par exemple, les signaux que nous transmettons réellement par RF) sont réels.  Comme le signal transmis par une antenne doit être réel, vous ne pouvez pas transmettre directement un signal complexe/imaginaire.  Vous saurez qu’un signal est définitivement un signal complexe si les parties de fréquence négative et de fréquence positive du signal ne sont pas exactement les mêmes. Après tout, les nombres complexes sont la façon dont nous représentons les fréquences négatives. En réalité, il n’y a pas de fréquences négatives; il s’agit simplement de la partie du signal située en dessous de la fréquence porteuse.</p>
<p>Dans la section précédente où nous avons joué avec le point complexe 0.7-0.4j, il s’agissait essentiellement d’un échantillon dans un signal en bande de base.  La plupart du temps, lorsque vous voyez des échantillons complexes (échantillons IQ), vous êtes en bande de base.  Les signaux sont rarement représentés ou stockés numériquement en RF, en raison de la quantité de données que cela prendrait, et du fait que nous ne sommes généralement intéressés que par une petite partie du spectre RF.</p>
</div>
<div class="section" id="le-pic-dc-et-le-decalage-dc">
<h2>Le Pic DC et le décalage DC<a class="headerlink" href="#le-pic-dc-et-le-decalage-dc" title="Permalink to this headline">¶</a></h2>
<p>Lorsque vous commencez à travailler avec les SDR, vous trouvez souvent un pic important au centre de la FFT. On l’appelle “offset DC” ou “pic DC” ou parfois “fuite LO”, où LO signifie <em>Local oscilator</em> pour <em>oscillateur local</em> en français.</p>
<p>Voici un exemple d’un pic de courant continu:</p>
<a class="reference internal image-reference" href="../_images/dc_spike.png"><img alt="../_images/dc_spike.png" class="align-center" src="../_images/dc_spike.png" style="width: 257.5px; height: 244.0px;" /></a>
<p>Because the SDR tunes to a center frequency, the 0 Hz portion of the FFT corresponds to the center frequency.  Ceci étant dit, un pic de courant continu ne signifie pas nécessairement qu’il y a de l’énergie à la fréquence centrale. S’il n’y a qu’un pic de courant continu et que le reste de la FFT ressemble à du bruit, il est fort probable qu’il n’y a pas de signal présent à l’endroit où elle vous le montre.</p>
<p>Un décalage DC est un artefact commun dans les récepteurs à conversion directe, qui est l’architecture utilisée pour les SDRs comme le PlutoSDR, RTL-SDR, LimeSDR, et de nombreux USRPs Ettus. Dans les récepteurs à conversion directe, un oscillateur local convertit le signal de sa fréquence réelle en bande de base. Par conséquent, les fuites de cet oscillateur apparaissent au centre de la bande passante observée. La fuite du LO est une énergie supplémentaire créée à cause de la combinaison des fréquences. L’élimination de ce bruit supplémentaire est difficile car il est proche du signal de sortie souhaité. De nombreux circuits intégrés RF (RFIC) intègrent une fonction automatique d’élimination du décalage continu, mais elle nécessite généralement la présence d’un signal pour fonctionner. C’est pourquoi le pic de courant continu est très apparent lorsqu’aucun signal n’est présent.</p>
<p>Un moyen rapide de gérer le décalage en courant continu consiste à suréchantillonner le signal et à le désaccorder (ou <em>detune</em> en anglais). Par exemple, disons que nous voulons visualiser 5 MHz de spectre à 100 MHz. Ce que nous pouvons faire, c’est échantillonner à 20 MHz à une fréquence centrale de 95 MHz.</p>
<a class="reference internal image-reference" href="../_images/offtuning.png"><img alt="../_images/offtuning.png" class="align-center" src="../_images/offtuning.png" style="width: 422.40000000000003px; height: 134.4px;" /></a>
<p>La boîte bleue ci-dessus montre ce qui est effectivement échantillonné par la radio SDR, et la boîte verte affiche la partie du spectre que nous voulons.  Notre LO sera réglé sur 95 MHz car c’est la fréquence sur laquelle nous demandons au SDR de s’accorder. Comme 95 MHz est en dehors de la boîte verte, nous n’aurons pas de pic de courant continu.</p>
<p>Il y a un problème: si nous voulons que notre signal soit centré à 100 MHz et ne contienne que 5 MHz, nous devrons effectuer nous-mêmes un décalage de fréquence, un filtrage et un sous-échantillonnage du signal (ce que nous apprendrons à faire plus tard). Heureusement, ce processus de désaccordage, c’est-à-dire l’application d’un décalage du LO, est souvent intégré aux SDR, qui effectuent automatiquement le désaccordage et décalent ensuite la fréquence vers la fréquence centrale souhaitée. L’avantage est que la SDR peut le faire en interne: nous n’avons pas besoin d’envoyer une fréquence d’échantillonnage plus élevée sur notre connexion USB ou Ethernet, chose qui limitera la fréquence d’échantillonnage que nous pouvons utiliser.</p>
<p>Cette sous-section concernant les décalages DC est un bon exemple de ce qui différencie ce manuel des autres. Votre manuel DSP moyen abordera l’échantillonnage, mais il a tendance à ne pas inclure les obstacles à la mise en œuvre tels que les décalages DC, malgré leur importance dans la pratique.</p>
</div>
<div class="section" id="echantillonnage-a-l-aide-de-notre-sdr">
<h2>Echantillonnage à l’aide de notre SDR<a class="headerlink" href="#echantillonnage-a-l-aide-de-notre-sdr" title="Permalink to this headline">¶</a></h2>
<p>Pour obtenir des informations spécifiques à la SDR sur l’exécution de l’échantillonnage, consultez l’un des chapitres suivants :</p>
<ul class="simple">
<li>Chapitre <a class="reference internal" href="pluto.html#pluto-chapter"><span class="std std-ref">PlutoSDR en Python</span></a></li>
<li>Chapitre <a class="reference internal" href="usrp.html#usrp-chapter"><span class="std std-ref">USRP en Python</span></a></li>
</ul>
</div>
<div class="section" id="calcul-de-la-puissance-moyenne">
<h2>Calcul de la puissance moyenne<a class="headerlink" href="#calcul-de-la-puissance-moyenne" title="Permalink to this headline">¶</a></h2>
<p>Pour un signal complexe discret, c’est-à-dire un signal que nous avons échantillonné, nous pouvons trouver la puissance moyenne en prenant la module de chaque échantillon, en l’élevant au carré, puis en calculant la moyenne :</p>
<div class="math">
<p><img src="../_images/math/5ce37305be13d8e76bc41fea570f7b3041d860c2.svg" alt="P = \frac{1}{N} \sum_{n=1}^{N} |x[n]|^2"/></p>
</div><p>Rappelez-vous que la valeur absolue d’un nombre complexe est juste le module, c’est-à-dire, <img class="math" src="../_images/math/a2cfebc8da1e2453e86d1fdf34c5af28729b7ea9.svg" alt="\sqrt{I^2+Q^2}"/></p>
<p>En Python, le calcul de la puissance moyenne ressemblera à ceci :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">avg_pwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Voici une astuce très utile pour calculer la puissance moyenne d’un signal échantillonné.
Si votre signal a une moyenne approximativement nulle - ce qui est généralement le cas dans la SDR (nous verrons pourquoi plus tard) - alors la puissance du signal peut être trouvée en prenant la variance des échantillons. Dans ces circonstances, vous pouvez calculer la puissance de cette façon en Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">avg_pwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># (signal should have roughly zero mean)</span>
</pre></div>
</div>
<p>La raison pour laquelle la variance des échantillons calcule la puissance moyenne est assez simple: l’équation de la variance est <img class="math" src="../_images/math/399bf68509fdd516e4e2437f32dba2c8c9635ff7.svg" alt="\frac{1}{N}\sum^N_{n=1} |x[n]-\mu|^2"/> où <img class="math" src="../_images/math/c859a8f80a5b73b97ecb9d3c15842e979a0f6fe2.svg" alt="\mu"/> est la moyenne du signal. Cette équation semble familière! Si <img class="math" src="../_images/math/c859a8f80a5b73b97ecb9d3c15842e979a0f6fe2.svg" alt="\mu"/> est égal à zéro, l’équation permettant de déterminer la variance des échantillons devient équivalente à l’équation de la puissance.  Vous pouvez également soustraire la moyenne des échantillons de votre fenêtre d’observation, puis calculer la variance. Sachez simplement que si la valeur moyenne n’est pas nulle, la variance et la puissance ne sont pas égales.</p>
</div>
<div class="section" id="calcul-de-la-densite-spectrale-de-puissance">
<h2>Calcul de la densité spectrale de puissance<a class="headerlink" href="#calcul-de-la-densite-spectrale-de-puissance" title="Permalink to this headline">¶</a></h2>
<p>Dans le chapitre précédent, nous avons appris que nous pouvions convertir un signal dans le domaine des fréquences à l’aide d’une FFT, et que le résultat était appelé densité spectrale de puissance (DSP), qu’on notera par la suite PSD (pour <em>Power Spectral Density</em>) et eviter ainsi toute confusion avec DSP de <em>Digitl Signal Processing</em>.</p>
<p>Mais pour trouver réellement la PSD d’un lot d’échantillons et la tracer, nous ne nous contentons pas d’effectuer une FFT. Nous devons effectuer les six opérations suivantes:</p>
<ol class="arabic simple">
<li>Prenez la FFT de nos échantillons.  Si nous avons x échantillons, la taille de la FFT sera la longueur de x par défaut. Utilisons les 1024 premiers échantillons comme exemple pour créer une FFT de taille 1024. La sortie sera de 1024 flottants complexes.</li>
<li>Prenez le module de la sortie de la FFT, ce qui nous donne 1024 flottants réels.</li>
<li>Normalisez: divisez par la taille de la FFT (<img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/>, ou 1024 dans ce cas).</li>
<li>Elevez au carré le module résultante pour obtenir la puissance.</li>
<li>Convertissez en dB en utilisant <img class="math" src="../_images/math/f4455b0aaee830c84338328975fa7b9956463d04.svg" alt="10 \log_{10}()"/> ; nous considérons toujours les PSD en échelle logarithmique.</li>
<li>Effectuez un décalage FFT, abordé dans le chapitre précédent, pour déplacer ” 0 Hz ” au centre et les fréquences négatives à gauche du centre.</li>
</ol>
<p>Ces six étapes en Python sont:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Fs</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="c1"># Disons que nous échantillonnons à 1 MHz</span>
<span class="c1"># supposez que x contient votre tableau d&#39;échantillons de QI</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="c1"># nous ne prendrons que la FFT des 1024 premiers échantillons, voir le texte ci-dessous</span>
<span class="n">PSD</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">PSD_log</span> <span class="o">=</span> <span class="mf">10.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">PSD</span><span class="p">)</span>
<span class="n">PSD_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">PSD_log</span><span class="p">)</span>
</pre></div>
</div>
<p>En option, nous pouvons appliquer une fenêtre, comme nous l’avons appris dans le chapitre <a class="reference internal" href="frequency_domain.html#freq-domain-chapter"><span class="std std-ref">Domaine fréquentiel</span></a>. Le fenêtrage aura lieu juste avant la ligne de code avec fft().</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ajouter la ligne suivante après avoir fait x = x[0:1024]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># appliquer une fenêtre de Hamming</span>
</pre></div>
</div>
<p>Pour tracer cette PSD, nous devons connaître les valeurs de l’axe des abscisses.
Comme nous l’avons appris au chapitre précédent, lorsque nous échantillonnons un signal, nous ne “voyons” que le spectre compris entre -Fs/2 et Fs/2, Fs étant notre fréquence d’échantillonnage.
La résolution que nous obtenons dans le domaine fréquentiel dépend de la taille de notre FFT, qui par défaut est égale au nombre d’échantillons sur lesquels nous effectuons l’opération de FFT.
Dans ce cas, notre axe des x est constitué de 1024 points équidistants entre -0,5 MHz et 0,5 MHz.
Si nous avions réglé notre SDR sur 2.4 GHz, notre fenêtre d’observation serait comprise entre 2.3995 GHz et 2.4005 GHz.
En Python, le déplacement de la fenêtre d’observation ressemblera à ceci :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">center_freq</span> <span class="o">=</span> <span class="mf">2.4e9</span> <span class="c1"># fréquence sur laquelle nous avons réglé notre SDR.</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Fs</span><span class="o">/-</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="c1"># début, fin, pas, centré autour de 0 Hz</span>
<span class="n">f</span> <span class="o">+=</span> <span class="n">center_freq</span> <span class="c1"># ajoutez maintenant la fréquence centrale</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">PSD_shifted</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Nous devrions nous retrouver avec un magnifique PSD!</p>
<p>Si vous voulez trouver la DSP de millions d’échantillons, ne faites pas une FFT d’un million de points car cela prendra probablement une éternité. Cela vous donnera une sortie d’un million de “bins de fréquence”, après tout, ce qui est trop pour être affiché dans un graphique.
Je vous suggère plutôt de faire plusieurs DSP plus petites et d’en faire la moyenne ou de les afficher à l’aide d’un spectrogramme.
Alternativement, si vous savez que votre signal ne change pas rapidement, il est adéquat d’utiliser quelques milliers d’échantillons et de trouver la DSP de ceux-ci; dans ce laps de temps de quelques milliers d’échantillons, vous aurez probablement capturé assez du signal pour obtenir une bonne représentation.</p>
<p>Voici un exemple de code complet qui inclut la génération d’un signal (exponentielle complexe à 50 Hz) et de bruit.  Notez que N, le nombre d’échantillons à simuler, devient la longueur de la FFT car nous prenons la FFT de tout le signal simulé.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">Fs</span> <span class="o">=</span> <span class="mi">300</span> <span class="c1"># taux d&#39;échantillonnage</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span> <span class="c1"># période d&#39;échantillonnage</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2048</span> <span class="c1"># nombre d&#39;échantillons à simuler</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Ts</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">50</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># simule une sinusoïde à 50 Hz</span>

<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># bruit complexe à puissance unitaire</span>
<span class="n">noise_power</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">)</span>

<span class="n">PSD</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">PSD_log</span> <span class="o">=</span> <span class="mf">10.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">PSD</span><span class="p">)</span>
<span class="n">PSD_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">PSD_log</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Fs</span><span class="o">/-</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="c1"># début, fin, pas</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">PSD_shifted</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Fréquence [Hz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude [dB]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>sortie:</p>
<img alt="../_images/fft_example1.svg" class="align-center" src="../_images/fft_example1.svg" /></div>
<div class="section" id="aller-plus-loin-anglais">
<h2>Aller plus loin (anglais)<a class="headerlink" href="#aller-plus-loin-anglais" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><a class="reference external" href="http://rfic.eecs.berkeley.edu/~niknejad/ee242/pdf/eecs242_lect3_rxarch.pdf" rel="noopener noreferrer" target="_blank">http://rfic.eecs.berkeley.edu/~niknejad/ee242/pdf/eecs242_lect3_rxarch.pdf</a></li>
</ol>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="frequency_domain.html" title="Previous document"><span class="section-number">2. </span>Domaine fréquentiel</a>
        </li>
        <li>
          <a href="digital_modulation.html" title="Next document"><span class="section-number">4. </span>Modulation numérique</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>