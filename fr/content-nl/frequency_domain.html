
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2. Het Frequentiedomein &#8212; PySDR: A Guide to SDR and DSP using Python</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TGRQK1JJYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TGRQK1JJYD');
</script>

<!-- French/English Chooser, couldnt get it working with local URLs -->
<div style="float: right; padding-bottom: 0;">
  <select onchange="location = this.value;">
    <option value="https://pysdr.org/index.html">English</option>
    <option value="https://pysdr.org/nl/index-nl.html">Dutch</option>
    <option value="https://pysdr.org/fr/index-fr.html">French</option>
  </select>
</div>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index-fr.html">
    <img class="logo" src="../_static/logo.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">PySDR: A Guide to SDR and DSP using Python</h1>
    
  </a>
</p>



<p class="blurb">By <a href="https://pysdr.org/content/about_author.html">Dr. Marc Lichtman</a></p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/frequency_domain.html">2. Domaine fréquentiel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/sampling.html">3. échantillonnage IQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/digital_modulation.html">4. Modulation numérique</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/pluto.html">5. PlutoSDR en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/usrp.html">6. USRP en Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/noise.html">7. le Bruit et les dB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/filters.html">8. Filtres</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/link_budgets.html">9. Bilans de liaison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/channel_coding.html">10. Codage Canal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/iq_files.html">11. Fichiers IQ et SigMF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/multipath_fading.html">12. Evanouissement par Multi-Trajets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/pulse_shaping.html">13. Mise en Forme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/sync.html">14. Synchronisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/rds.html">15. Exemple bout en bout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content-fr/about_author.html">16. A propos de l’auteur</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://trinket.io/embed/python3">Online Python Console</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index-fr.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="het-frequentiedomein">
<span id="freq-domain-chapter"></span><h1><span class="section-number">2. </span>Het Frequentiedomein<a class="headerlink" href="#het-frequentiedomein" title="Permalink to this headline">¶</a></h1>
<p>Dit hoofdstuk introduceert het frequentiedomein en behandelt de Fourierreeks, Fouriertransformatie, Fourier eigenschappen, FFT, vensterfuncties en spectrogrammen, door gebruik te maken van Python voorbeelden.</p>
<p>Een van de coolste gevolgen van het leren over DSP en draadloze communicatie is dat je ook leert te denken in het frequentiedomein. De ervaring met het werken in het frequentiedomein voor de meeste mensen is gelimiteerd tot het aanpassen van de bas/mid/treble knoppen op het audiosysteem van een auto. De ervaring met het <em>zien</em> van het frequentiedomein voor de meeste mensen is gelimiteerd tot het zien van een audio equalizer, zoals deze clip:</p>
<img alt="../_images/audio_equalizer.webp" class="align-center" src="../_images/audio_equalizer.webp" />
<p>Wanneer je dit hoofdstuk hebt afgerond zul je begrijpen wat het frequentiedomein echt betekent.
Je leert hoe je kunt schakelen tussen tijd en frequentie (en wat er gebeurt als we dit doen) en wat andere interessante principes die we zullen gebruiken door ons onderzoek naar DSP en SDR.
Wanneer je dit boek hebt afgerond zul je een master zijn in het werken in het frequentiedomein. Gegarandeerd!</p>
<p>Als eerste, waarom willen we naar signalen kijken in het frequentiedomein? Nou, hieronder staan twee voorbeelden, weergeven in beide het tijd- en frequentiedomein.</p>
<a class="reference internal image-reference" href="../_images/time_and_freq_domain_example_signals.png"><img alt="../_images/time_and_freq_domain_example_signals.png" class="align-center" src="../_images/time_and_freq_domain_example_signals.png" style="width: 576.0px; height: 238.8px;" /></a>
<p>Zoals je ziet, in het tijddomein lijken beide figuren op ruis, maar in het frequentiedomein kunnen we verschillende eigenschappen van de signalen onderscheiden. Alles is van nature in het tijddomein; wanneer we signalen samplen, doen we dit in het tijddomein, want je kunt een signaal niet <em>direct</em> samplen in het frequentiedomein.</p>
<div class="section" id="fourierreeks">
<h2>Fourierreeks<a class="headerlink" href="#fourierreeks" title="Permalink to this headline">¶</a></h2>
<p>Het begrip dat elk signaal gerepresenteerd kan worden door een optelling van sinussen is de basis van het frequentiedomein. Wanneer we een signaal opbreken in sinussen noemen we dat de Fourierreeks. Hier is een voorbeeld van een signaal wat slechts uit twee sinussen bestaat:</p>
<a class="reference external image-reference" href="../_images/summing_sinusoids.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/summing_sinusoids.svg" class="align-center" src="../_images/summing_sinusoids.svg" /></a>
<p>Hier is nog een voorbeeld; de rode curve in de animatie benadert een zaagtandsignaal door het optellen van 10 sinussen. We kunnen zien dat dit geen perfecte reconstructie is van de zaagtand - er zou een oneindig aantal sinussen nodig zijn om de scherpe transities van de zaagtand te kunnen reproduceren.</p>
<a class="reference internal image-reference" href="../_images/fourier_series_triangle.gif"><img alt="../_images/fourier_series_triangle.gif" class="align-center" src="../_images/fourier_series_triangle.gif" style="width: 561.4px; height: 180.6px;" /></a>
<p>Sommige signalen hebben meer sinussen nodig dan andere, en sommige een oneindig aantal, maar ze kunnen altijd worden benaderd met een beperkt aantal. Hier is nog een voorbeeld van een signaal wat wordt opgebouwd door een reeks van sinussen.</p>
<a class="reference internal image-reference" href="../_images/fourier_series_arbitrary_function.gif"><img alt="../_images/fourier_series_arbitrary_function.gif" class="align-center" src="../_images/fourier_series_arbitrary_function.gif" style="width: 561.4px; height: 180.6px;" /></a>
<p>Om te begrijpen hoe een signaal kan worden opgebroken in sinussen, of sinusoïden, moeten we eerst de drie eigenschappen van een sinus bekijken:</p>
<ol class="arabic simple">
<li>Amplitude</li>
<li>Frequentie</li>
<li>Fase</li>
</ol>
<p><strong>Amplitude</strong> geeft de “kracht” van de golf, terwijl <strong>frequentie</strong> het aantal golven per seconde geeft. <strong>Fase</strong> wordt gebruikt om aan te geven hoever het signaal is verschoven in de tijd, alles tussen 0 en 180 graden (of 0 en <img class="math" src="../_images/math/bf50b56b21d67ede45fc1ec5b8213871824fe365.svg" alt="2\pi"/>). Dit moet wel relatief zijn aan iets anders, zoals twee sinussen met dezelfde frequentie die 30 graden uit fase lopen met elkaar, om wat te kunnen betekenen.</p>
<a class="reference external image-reference" href="images/amplitude_phase_period.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/amplitude_phase_period1.svg" class="align-center" src="../_images/amplitude_phase_period1.svg" /></a>
<p>Je hebt nu waarschijnlijk door dat een “signaal” in feite een functie is “van de tijd” (dus, de x-as). Een andere makkelijk onthoudbare eigenschap is <strong>periode</strong>, de inverse van <strong>frequentie</strong>. De <strong>periode</strong> van een sinusoïde is de hoeveelheid tijd, in seconden, dat de golf nodig heeft om 1 ronde af te maken. Dus, de eenheid van frequentie is 1/seconden, of Hz.</p>
<p>Wanneer een signaal wordt opgebroken in een sommatie van sinussen, dan zal elke een eigen <strong>amplitude</strong>, <strong>fase</strong> en <strong>frequentie</strong> hebben. De <strong>amplitude</strong> van elke sinus verteld ons hoe sterk deze <strong>frequentie</strong> aanwezig was in het originele signaal. Het enige wat je voor nu over <strong>fase</strong> moet beseffen is dat het verschil tussen een sin() en cos() een faseverschuiving (tijdverschuiving) is.</p>
<p>Het is belangrijker om de onderliggende concepten van de Fourierreeks te begrijpen, dan de vergelijkingen op te kunnen lossen. Maar voor hen die geïnteresseerd zijn verwijs ik je naar de beknopte uitleg van Wolfram: <a class="reference external" href="https://mathworld.wolfram.com/FourierSeries.html" rel="noopener noreferrer" target="_blank">https://mathworld.wolfram.com/FourierSeries.html</a>.</p>
</div>
<div class="section" id="tijd-frequentie-paren">
<h2>Tijd-Frequentie paren<a class="headerlink" href="#tijd-frequentie-paren" title="Permalink to this headline">¶</a></h2>
<p>We hebben vastgesteld dat signalen voorgesteld kunnen worden door een reeks sinussen, die een aantal attributen hebben.
Laten we nu leren hoe we deze signalen kunnen weergeven in het frequentiedomein.
Terwijl het tijddomein laat zien hoe het signaal varieert over de tijd, laat het frequentiedomein zien hoe sterk het signaal aanwezig is in welke frequenties.
De x-as stelt dan geen tijd, maar frequentie voor.
We kunnen een signaal beide in het tijddomein <em>en</em> frequentiedomein tonen.
Laten we om te beginnen naar een paar simpele voorbeelden kijken.</p>
<p>Dit is hoe een sinus met frequentie f eruitziet in het tijd- en frequentiedomein:</p>
<a class="reference internal image-reference" href="../_images/sine-wave.png"><img alt="../_images/sine-wave.png" class="align-center" src="../_images/sine-wave.png" style="width: 407.4px; height: 171.5px;" /></a>
<p>Het tijddomein moet er bekend uitzien.
Het is een oscillerende golf.
Maak je geen zorgen over wanneer de golf start of hoe lang een periode is, wat je moet onthouden is dat het een <em>enkele frequentie</em> heeft, waardoor we slechts een enkele piek in het frequentiedomein zien.
Op welke frequentie de sinus ook oscilleert, dat is de frequentie waar die piek zich zal bevinden in het frequentiedomein.
De wiskundige naam voor zo’n piek is een “impuls”.</p>
<p>En wat als we een impuls in het tijddomein hadden?
Stel je een opname voor van iemand die in zijn handen klapt of met een hamer slaat.
Dit tijd-frequentie paar is minder intuïtief.</p>
<a class="reference internal image-reference" href="../_images/impulse.png"><img alt="../_images/impulse.png" class="align-center" src="../_images/impulse.png" style="width: 409.5px; height: 161.0px;" /></a>
<p>Zoals je ziet, een piek in het tijddomein is een vlakke lijn in het frequentiedomein, en theoretisch bevat het elke frequentie.
Er is geen praktisch perfecte piek in het tijddomein, want dit zou oneindig kort moeten duren.
Net als de sinus maakt het niet uit waar in het tijddomein de piek plaatsvindt.
Wat je moet onthouden is dat snelle veranderingen in het tijddomein zullen leiden tot vele frequenties.</p>
<p>Laten we nu naar de tijd- en frequentiedomein-figuren kijken van een blokgolf:</p>
<a class="reference external image-reference" href="../_images/square-wave.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/square-wave.svg" class="align-center" src="../_images/square-wave.svg" /></a>
<p>Dit is ook minder intuïtief, maar we kunnen wel een sterke piek in het frequentiedomein zien op 10 Hz, wat de frequentie is van de blokgolf. Het lijkt door te blijven gaan.
Dit komt door de snelle overgangen in het tijddomein, net als het vorige voorbeeld.
Het is echter niet vlak in frequentie, maar het heeft pieken op verschillende afstanden en de amplitude neemt langzaam (en oneindig) af.
Een blokgolf in het tijddomein heeft een sin(x)/x vorm in het frequentiedomein.</p>
<p>En wat als we een constante hebben in het tijddomein?
Een constant signaal heeft geen “frequentie”.
Kijk maar:</p>
<a class="reference internal image-reference" href="../_images/dc-signal.png"><img alt="../_images/dc-signal.png" class="align-center" src="../_images/dc-signal.png" style="width: 633.0px; height: 217.0px;" /></a>
<p>Omdat er geen frequentie is, ontstaat er een piek op 0 Hz in het frequentiedomein.
Als je er over nadenkt, is dit logisch.
Het frequentiedomein is niet “leeg”, want dat zou alleen gebeuren als er helemaal geen signaal is (alleen nullen in het tijddomein).
We noemen 0 Hz in het frequentiedomein DC omdat het ontstaat door een dc-signaal in de tijd (een constant signaal wat niet verandert).
Let op dat wanneer we de amplitude van het dc-signaal groter maken, de piek op 0 Hz in het frequentiedomein ook groter wordt.</p>
<p>Later leren we wat precies de y-as in het frequentiedomein betekent.
Voor nu kun je het bekijken als een soort amplitude dat beschrijft hoe sterk een frequentie aanwezig was in het tijddomein-signaal.</p>
</div>
<div class="section" id="fouriertransformatie">
<h2>Fouriertransformatie<a class="headerlink" href="#fouriertransformatie" title="Permalink to this headline">¶</a></h2>
<p>Wiskundig gezien wordt de “transformatie” die we gebruiken om tussen het tijd- en frequentiedomein te wisselen de Fouriertransformatie genoemd.
Het is als volgt gedefinieerd:</p>
<div class="math">
<p><img src="../_images/math/6ec9b03637d9f36f1f21065d0ea5f51a02de4423.svg" alt="X(f) = \int x(t) e^{-j2\pi ft} dt"/></p>
</div><p>Voor een tijdsignaal x(t) kunnen we de frequentiedomein-versie, X(f), vinden met deze formule.
We willen de tijddomein-versie van een functie met x(t) of y(t) aangeven, en de corresponderende frequentiedomein-versie met X(f) en Y(F).
Hierbij staat de “t” voor tijd en “f” voor frequentie.
De “j” is simpelweg de imaginaire eenheid.
Misschien herken je dit als “i” van de wiskundelessen.
We gebruiken “j” in de elektrotechniek en computerkunde omdat “i” vaak gebruikt wordt voor stroom en bij programmeren voor een iterator.</p>
<p>Teruggaan naar het tijddomein vanuit het frequentiedomein is bijna hetzelfde, afgezien van een vermenigvuldigingsfactor en het minteken:</p>
<div class="math">
<p><img src="../_images/math/5be5072ccaf0978ad48c208cd73799c36aef51cd.svg" alt="x(t) = \frac{1}{2 \pi} \int X(f) e^{j2\pi ft} df"/></p>
</div><p>Let op dat veel boeken <img class="math" src="../_images/math/c37cd8faff2fe4e2b7d74bb3d54411948d081962.svg" alt="w"/> gebruiken in plaats van <img class="math" src="../_images/math/f2db2fc8f3c55a36937062e1797243b47a90f001.svg" alt="2\pi f"/>.  <img class="math" src="../_images/math/c37cd8faff2fe4e2b7d74bb3d54411948d081962.svg" alt="w"/> is de hoekfrequentie in radialen per seconde terwijl  <img class="math" src="../_images/math/6fae9f9f4e88f9ed9c4f703e00e569d4c953562b.svg" alt="f"/> in Hz is. Het enige wat je moet weten is</p>
<div class="math">
<p><img src="../_images/math/198ad5c1c03eb34cf94aa5de5ecc4e89624a2964.svg" alt="\omega = 2 \pi f"/></p>
</div><p>Ook al voegt dit een <img class="math" src="../_images/math/adbf740b3ae712140edad99b950ffd8c9ec2919b.svg" alt="2 \pi"/> term toe aan de vergelijkingen, het is toch makkelijker om frequentie in Hz te blijven gebruiken.
Uiteindelijk gebruik je ook Hz in je SDR-applicatie.</p>
<p>De bovenstaande vergelijking voor de Fouriertransformatie, wat je alleen in wiskunde problemen tegenkomt, is in de continue vorm.
De discrete versie lijkt veel meer op hoe het in de programmacode wordt geïmplementeerd.</p>
<div class="math">
<p><img src="../_images/math/d94eb6f124e7e929c0420fd6d6a19eb14903b593.svg" alt="X_k = \sum_{n=0}^{N-1} x_n e^{-\frac{j2\pi}{N}kn}"/></p>
</div><p>Het grootste verschil hierbij is dat de integraal is vervangen door een sommatie.
De index <img class="math" src="../_images/math/30d4f39194cc2ced00937a2642c0345222fed6cd.svg" alt="k"/> loopt van 0 tot N-1.</p>
<p>Het geeft niet als deze vergelijkingen voor jou niets betekenen.
We hoeven ze eigenlijk niet eens direct te gebruiken om coole dingen te doen met DSP en SDR’s!</p>
</div>
<div class="section" id="tijd-frequentie-eigenschappen">
<h2>Tijd-Frequentie Eigenschappen<a class="headerlink" href="#tijd-frequentie-eigenschappen" title="Permalink to this headline">¶</a></h2>
<p>We hebben eerder gekeken naar hoe signalen eruitzien in het tijd- en frequentiedomein.
Nu zullen we vijf belangrijke “Fourier eigenschappen” gaan behandelen.
Deze eigenschappen verklaren dat als we ____ doen op het tijdsignaal, dat er ____ gebeurt op het signaal in het frequentiedomein.
Dit zal ons belangrijke inzichten verschaffen over welke Digitale Signaal Bewerkingen (DSP) we in de praktijk zullen toepassen op onze signalen in het tijddomein.</p>
<ol class="arabic simple">
<li>Lineariteit:</li>
</ol>
<div class="math">
<p><img src="../_images/math/746a7887541f0ad9d3847793bc3a342014dc4d6d.svg" alt="a x(t) + b y(t) \leftrightarrow a X(f) + b Y(f)"/></p>
</div><p>Deze eigenschap is waarschijnlijk het makkelijkst om te begrijpen. Als we twee signalen optellen in de tijd dan zal de frequentiedomein-versie ook bestaan uit twee opgetelde frequentiedomein-signalen.
Dit vertelt ons ook dat als we enig signaal vermenigvuldigen met een factor, het signaal in het frequentiedomein met dezelfde factor zal groeien/krimpen.
Het nut van deze eigenschap zal duidelijker worden wanneer we meerdere signalen gaan optellen.</p>
<ol class="arabic simple">
<li>Frequentieverschuiving:</li>
</ol>
<div class="math">
<p><img src="../_images/math/be894b85227c716548c31342eccabe9c1b515b57.svg" alt="e^{2 \pi j f_0 t}x(t) \leftrightarrow X(f-f_0)"/></p>
</div><p>De term links van <img class="math" src="../_images/math/b52a14c3452fbd1a467b640bb6269127e997a8e3.svg" alt="x(t)"/> noemen we een “complexe sinusoïde” of een “complex exponent”.
Voor nu hoef je alleen te weten dat dit effectief gewoon een sinus is met frequentie <img class="math" src="../_images/math/da647bd66569f61d6a3f16c3c2e09085c351a343.svg" alt="f_0"/>.
Deze eigenschap vertelt ons dat wanneer we <img class="math" src="../_images/math/b52a14c3452fbd1a467b640bb6269127e997a8e3.svg" alt="x(t)"/> vermenigvuldigen met een sinus, we in het frequentiedomein <img class="math" src="../_images/math/8107fe72abc774dcc596c9fa4ee452bf8f6748af.svg" alt="X(f)"/> krijgen, maar verschoven met een frequentie <img class="math" src="../_images/math/da647bd66569f61d6a3f16c3c2e09085c351a343.svg" alt="f_0"/>.
Het is makkelijker om deze frequentieverschuiving visueel te weergeven:</p>
<a class="reference external image-reference" href="../_images/freq-shift.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/freq-shift.svg" class="align-center" src="../_images/freq-shift.svg" /></a>
<p>De frequentieverschuiving is een belangrijk onderdeel van DSP omdat we veel redenen hebben om signalen heen en weer te verschuiven in frequentie.
Deze eigenschap legt uit hoe we dat kunnen doen (vermenigvuldigen met een sinusoïde).
Hier is nog een manier om deze eigenschap te laten zien:</p>
<a class="reference external image-reference" href="../_images/freq-shift-diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/freq-shift-diagram.svg" class="align-center" src="../_images/freq-shift-diagram.svg" /></a>
<ol class="arabic simple" start="3">
<li>Vermenigvuldigen in de tijd</li>
</ol>
<div class="math">
<p><img src="../_images/math/0a4a9d25a8969bb46059aa8e6ae6672fce599b17.svg" alt="x(at) \leftrightarrow X\left(\frac{f}{a}\right)"/></p>
</div><p>Aan de linkerkant van de vergelijking zien we dat we ons signaal <img class="math" src="../_images/math/b52a14c3452fbd1a467b640bb6269127e997a8e3.svg" alt="x(t)"/> vermenigvuldigen in de tijd.
Hieronder een voorbeeld van een signaal wat in de tijd wordt vermenigvuldigd, en wat er gebeurt in de frequentieversie van het signaal.</p>
<a class="reference external image-reference" href="../_images/time-scaling.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/time-scaling.svg" class="align-center" src="../_images/time-scaling.svg" /></a>
<p>Effectief betekent vermenigvuldigen in de tijd dat je het signaal uitrekt of krimpt in de x-as richting.
Deze eigenschap vertelt ons dat vermenigvuldigen in de tijd een deling tot effect heeft in het bereik van frequenties.
Als voorbeeld, wanneer we bits sneller oversturen zullen we meer frequenties moeten gebruiken.
Deze eigenschap helpt dus uit te leggen waarom signalen met een hogere bitrate ook meer bandbreedte/spectrum innemen.
Als tijd-frequentie vermenigvuldiging recht evenredig zou zijn in plaats van omgekeerd evenredig, dan zouden de telefoonmaatschappijen zoveel bits per seconden kunnen versturen als ze wilden, zonder hiervoor miljarden uit te geven voor het spectrum!</p>
<p>Diegenen die bekend zijn met deze eigenschap valt het misschien op dat er een factor mist; deze is weggelaten voor de eenvoud.
Praktisch gezien heeft deze factor geen invloed.</p>
<ol class="arabic simple" start="4">
<li>Convolutie in de tijd</li>
</ol>
<div class="math">
<p><img src="../_images/math/866b024f252bc95ed034ab893af1cb799453d7d0.svg" alt="\int x(\tau) y(t-\tau) d\tau  \leftrightarrow X(f)Y(f)"/></p>
</div><p>Dit heet de convolutie eigenschap omdat we in het tijddomein <img class="math" src="../_images/math/b52a14c3452fbd1a467b640bb6269127e997a8e3.svg" alt="x(t)"/> en <img class="math" src="../_images/math/3ceb96452388fb9a286c026fe14672375d361d79.svg" alt="y(t)"/> convolueren. Misschien ken je de convolutie-operatie nog niet, dus bekijk het voor nu als een kruiscorrelatie.
Wanneer we tijddomein-signalen convolueren is dit gelijkwaardig aan het vermenigvuldigen van de frequentiedomein-signalen.
Het is totaal anders dan twee signalen bij elkaar optellen.
Wanneer je twee signalen bij elkaar optelt, gebeurt er bijna niets, zoals je hebt gezien, je telt gewoon de frequentiedomein-versies bij elkaar op.
Maar wanneer je twee signalen convolueert is het alsof je een derde signaal creëert.
Convolutie is de belangrijkste techniek in DSP, maar we moeten eerst begrijpen hoe filters werken om dit te laten bezinken.</p>
<p>Om uit te leggen hoe belangrijk deze eigenschap is, kijken we eerst naar deze situatie voor we verder gaan: Je hebt een signaal dat je wilt ontvangen en er staat een interfererend signaal naast.</p>
<a class="reference external image-reference" href="../_images/two-signals.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/two-signals.svg" class="align-center" src="../_images/two-signals.svg" /></a>
<p>Het concept van maskeren wordt bij programmeren veel toegepast, dus laten we dat hier ook doen.
Wat als we het onderstaande masker zouden kunnen maken, en dit kunnen vermenigvuldigen met het bovenstaande signaal om het signaal wat we niet willen te maskeren?</p>
<a class="reference external image-reference" href="../_images/masking.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/masking.svg" class="align-center" src="../_images/masking.svg" /></a>
<p>Meestal voeren we DSP-operaties uit in het tijddomein, dus laten we de convolutie eigenschap gebruiken om te kijken hoe we dit in het tijddomein voor elkaar kunnen krijgen.
Laten we zeggen dat <img class="math" src="../_images/math/b52a14c3452fbd1a467b640bb6269127e997a8e3.svg" alt="x(t)"/> ons ontvangen signaal is.
Laat <img class="math" src="../_images/math/58f99b864a18c160fad823195027eb6876f48a9e.svg" alt="Y(f)"/> het masker zijn wat we in het frequentiedomein willen toepassen.
Dat zou betekenen dat <img class="math" src="../_images/math/3ceb96452388fb9a286c026fe14672375d361d79.svg" alt="y(t)"/> de tijddomein-versie is van ons masker, en wanneer we dit convolueren met <img class="math" src="../_images/math/b52a14c3452fbd1a467b640bb6269127e997a8e3.svg" alt="x(t)"/> het signaal “wegfilteren” dat we niet willen.</p>
<p>Wanneer we filters gaan behandelen zal de convolutie eigenschap duidelijker worden.</p>
<ol class="arabic simple">
<li>Convolutie in Frequentie:</li>
</ol>
<p>Als laatste wil ik opmerken dat de convolutie eigenschap ook omgekeerd werkt, maar dit zullen we niet zoveel gebruiken als convolutie in het tijddomein:</p>
<div class="math">
<p><img src="../_images/math/4d0228bed6205664ca7c69fc28ff975676f0e932.svg" alt="x(t)y(t)  \leftrightarrow  \int X(g) Y(f-g) dg"/></p>
</div><p>Er zijn nog meer eigenschappen, maar de bovenstaande vijf zijn naar mijn mening de meest cruciale om te begrijpen.
Ook al zijn we niet door alle bewijzen heengelopen, de crux is dat we wiskundige eigenschappen gebruiken om inzicht te verschaffen in wat er gebeurt met echte signalen wanneer we deze analyseren en bewerken.
Blijf niet hangen op de vergelijkingen, zorg ervoor dat je de beschrijving van elke eigenschap begrijpt.</p>
</div>
<div class="section" id="fast-fourier-transform-fft">
<h2>Fast Fourier Transform (FFT)<a class="headerlink" href="#fast-fourier-transform-fft" title="Permalink to this headline">¶</a></h2>
<p>Terug naar de Fouriertransformatie.
Ik heb je de vergelijking van de discrete Fouriertransformatie al laten zien, maar wat je voor 99.9% van de tijd zult gebruiken bij het programmeren is de FFT functie, fft().
De Fast Fourier Transform (FFT) (Nederlands: Snelle Fouriertransformatie) is simpelweg een algoritme om de discrete Fouriertransformatie uit te voeren.
Ook al is het decennia geleden bedacht en zijn er vele variaties op de implementatie, het is nog steeds het meest gebruikte algoritme om de discrete Fouriertransformatie te berekenen.
Gelukkig maar, gezien ze “Fast” of “Snel” in de naam hebben gebruikt.</p>
<p>De FFT is een functie met een in- en uitgang. Het zet een signaal om van tijd naar frequentie:</p>
<a class="reference external image-reference" href="../_images/fft-block-diagram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fft-block-diagram.svg" class="align-center" src="../_images/fft-block-diagram.svg" /></a>
<p>In dit boek zullen we alleen 1-dimensionale FFT’s gebruiken (2D wordt bijvoorbeeld toegepast voor beeldverwerking). Voor ons doel, behandel de FFT als iets met een ingang: een vector van samples (samples), en een output: de frequentiedomein-versie van die vector met samples.
De lengte van de uitgang is altijd gelijk aan de ingang.
Als ik 1024 samples in de FFT stop, krijg ik er 1024 uit. Het verwarrende is dat de uitgang altijd in het frequentiedomein zit, dus het “bereik” van de frequentie-as verandert niet met het aantal samples van de tijddomein-ingang. We kunnen dit visualiseren door de in- en uitgangsvectoren en de eenheid van de elementen te bekijken:</p>
<a class="reference external image-reference" href="../_images/fft-io.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fft-io.svg" class="align-center" src="../_images/fft-io.svg" /></a>
<p>Omdat de uitgang in het frequentiedomein zit, is het bereik van de frequentie-as gebaseerd op de sample-frequentie (sample rate). Dit zal volgend hoofdstuk behandeld worden.
Als we meer samples gebruiken voor de ingangsvector dan krijgen we een hogere resolutie in het frequentiedomein (en we behandelen meer samples per keer). We zien niet “meer” (een groter bereik aan) frequenties wanneer we de ingang groter maken.
De enige manier om dat te bereiken is door de sample-frequentie te verhogen (en de periodetijd <img class="math" src="../_images/math/39bb0cf165301516f1e7396af7393a5b3f6c733e.svg" alt="\Delta t"/> te verlagen).</p>
<p>Hoe kunnen we de uitgang weergeven?
Ga er als voorbeeld van uit dat de sample-frequentie 1 miljoen samples per seconde was (1 MHz). Zoals we volgend hoofdstuk zullen leren betekent dit, dat we enkel signalen tot een 0.5 MHz zullen zien, onafhankelijk van de hoeveelheid samples aan de ingang van de FFT.
We kunnen de uitgang als volgt representeren:</p>
<a class="reference external image-reference" href="../_images/negative-frequencies.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/negative-frequencies.svg" class="align-center" src="../_images/negative-frequencies.svg" /></a>
<p>Dit is altijd het geval; de uitgang van de FFT zal <img class="math" src="../_images/math/cb05020c98608fb3c62ed9132b03cb70bfeac2d4.svg" alt="\text{-} f_s/2"/> tot <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/> laten zien, waar <img class="math" src="../_images/math/7daaccc7c28018a253e53d5cde99a13764df9a8d.svg" alt="f_s"/> de sample-frequentie is.
Dat betekent dat de uitgang altijd een positief en negatief deel heeft. Als de ingang complex is dan zijn beide helften verschillend, als de ingang reëel is dan zijn de helften identiek.</p>
<p>Over het bereik van frequenties; elk equidistant punt (Engels: bin) komt overeen met <img class="math" src="../_images/math/da39ae114c94fb9dc38f7c6bbe66183011c21dc3.svg" alt="f_s/N"/> Hz, d.w.z., meer samples aan de ingang geven zal leiden tot een hogere resolutie/kleinere stapjes aan de uitgang.
Een klein detail wat je kunt negeren als je nieuw bent: wiskundig gezien hoort het laatste element niet <em>precies</em> bij <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/>, maar bij <img class="math" src="../_images/math/85b4914ed3d51eb47935368044def8b2299898e1.svg" alt="f_s/2 - f_s/N"/> wat voor grote <img class="math" src="../_images/math/24ca8296258e6d43d10327cf05e8d5b650662803.svg" alt="N"/> gelijk wordt aan <img class="math" src="../_images/math/afde4de8938387b8c8e7277067b0eb0ab90ab483.svg" alt="f_s/2"/>.</p>
</div>
<div class="section" id="negatieve-frequenties">
<h2>Negatieve Frequenties<a class="headerlink" href="#negatieve-frequenties" title="Permalink to this headline">¶</a></h2>
<p>Wat is nu weer een negatieve frequentie? Voor nu heeft dit te maken met complexe (imaginaire) getallen, er is niet zoiets als “negatieve frequentie” bij het verzenden/ontvangen van RF-signalen.
Het is slechts hoe we dingen weergeven.
Hier is een intuïtieve manier om erover na te denken.
Stel voor dat we onze SDR instellen op een middenfrequentie van 100 MHz (de FM-radio band) en dit samplen op een frequentie van 10 MHz.
In andere woorden, we bekijken het spectrum van 95 MHz tot 105 MHz.
Misschien zijn er drie signalen aanwezig:</p>
<a class="reference external image-reference" href="../_images/negative-frequencies2.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/negative-frequencies2.svg" class="align-center" src="../_images/negative-frequencies2.svg" /></a>
<p>Wanner de SDR ons de samples teruggeeft ziet het er zo uit:</p>
<a class="reference external image-reference" href="../_images/negative-frequencies3.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/negative-frequencies3.svg" class="align-center" src="../_images/negative-frequencies3.svg" /></a>
<p>Vergeet niet dat we de SDR op 100 MHz hebben ingesteld.
Dus het signaal dat op ongeveer 97.5 MHz zat, is wanneer we het digitaal bekijken, te zien op -2.5 MHz, wat technisch gezien een negatieve frequentie is.
Reëel gezien is dit gewoon een frequentie die lager is dan de middenfrequentie.
Dit wordt logischer wanneer we meer over samplen leren en ervaring opdoen met onze SDR’s.</p>
</div>
<div class="section" id="volgorde-in-de-tijd-maakt-niet-uit">
<h2>Volgorde in de tijd maakt niet uit<a class="headerlink" href="#volgorde-in-de-tijd-maakt-niet-uit" title="Permalink to this headline">¶</a></h2>
<p>Nog een laatste eigenschap voordat we naar het gebruik van de FFT gaan.
De FFT “mixt” soort van het ingangssignaal naar de uitgang, wat een andere schaal en eenheden heeft.
We zitten namelijk niet langer in het tijddomein.
Een goede manier om dit te onthouden is om te beseffen dat de volgorde waarin dingen gebeuren in het tijddomein geen invloed heeft op hoe het frequentiedomein er uit ziet.
D.w.z., de FFT van het volgende signaal zal dezelfde twee pieken laten zien, want het signaal bestaat gewoon uit twee sinussen met verschillende frequenties.
Het feit dat er twee frequenties zijn, verandert niet wanneer we de volgorde van de sinussen omdraaien.</p>
<a class="reference internal image-reference" href="../_images/fft_signal_order.png"><img alt="../_images/fft_signal_order.png" class="align-center" src="../_images/fft_signal_order.png" style="width: 634.0px; height: 224.0px;" /></a>
<p>Technisch gezien zal de fase van de FFT-waarden wel veranderen vanwege het verschuiven in de tijd van de sinussen.
We zullen echter ons alleen druk maken over de amplitude voor de volgende paar hoofdstukken van dit boek.</p>
</div>
<div class="section" id="fft-in-python">
<h2>FFT in Python<a class="headerlink" href="#fft-in-python" title="Permalink to this headline">¶</a></h2>
<p>Nu we hebben gezien wat een FFT is en hoe de uitgang eruit ziet, zullen we gaan kijken naar wat Python code en NumPy’s FFT functie, <code class="code docutils literal notranslate"><span class="pre">np.fft.fft()</span></code>, toepassen. Het wordt aangeraden dat je een Python console/IDE op je computer gebruikt, maar eventueel zou je ook de online Python console kunnen gebruiken dat je onderaan de linker navigatiebalk kunt vinden.</p>
<p>Eerst moeten we een signaal maken in het tijddomein. Voel je vrij om zelf met de Python console mee te doen. Om dingen eenvoudig te houden maken we een enkele sinus op 0.15 Hz. We nemen ook een sample-frequentie van 1 Hz, wat betekent dat we samples nemen op 0, 1, 2, 3 seconden, etc.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.15</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Als we <code class="code docutils literal notranslate"><span class="pre">s</span></code> plotten lijkt dit op:</p>
<a class="reference internal image-reference" href="../_images/fft-python1.png"><img alt="../_images/fft-python1.png" class="align-center" src="../_images/fft-python1.png" style="width: 477.4px; height: 282.79999999999995px;" /></a>
<p>Laten we nu Numpy’s FFT-functie gebruiken:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Als we de inhoud van <code class="code docutils literal notranslate"><span class="pre">S</span></code> bekijken, zien we dat het een array is van complexe getallen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span>  <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.01865008</span> <span class="o">+</span><span class="mf">0.00000000e+00</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01171553</span> <span class="o">-</span><span class="mf">2.79073782e-01</span><span class="n">j</span><span class="p">,</span><span class="mf">0.02526446</span> <span class="o">-</span><span class="mf">8.82681208e-01</span><span class="n">j</span><span class="p">,</span>  <span class="mf">3.50536075</span> <span class="o">-</span><span class="mf">4.71354150e+01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.15045671</span> <span class="o">+</span><span class="mf">1.31884375e+00</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.10769903</span> <span class="o">+</span><span class="mf">7.10452463e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.09435855</span> <span class="o">+</span><span class="mf">5.01303240e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08808671</span> <span class="o">+</span><span class="mf">3.92187956e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08454414</span> <span class="o">+</span><span class="mf">3.23828386e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08231753</span> <span class="o">+</span><span class="mf">2.76337148e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08081535</span> <span class="o">+</span><span class="mf">2.41078885e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.07974909</span> <span class="o">+</span><span class="mf">2.13663710e-01</span><span class="n">j</span><span class="p">,</span><span class="o">...</span>
</pre></div>
</div>
<p>Hint: Wat je ook aan het doen bent, als je ooit complexe getallen tegenkomt, bereken dan de modulus en fase en bekijk of dat er logischer uitziet. Laten we dat doen en de modulus en fase weergeven. In de meeste talen geeft de abs()-functie de modulus van een complex getal. De functie om de fase te bepalen varieert, maar in Python kan dit met <code class="code docutils literal notranslate"><span class="pre">np.angle()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">S_mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">S_fase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S_mod</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S_fase</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/fft-python2.png"><img alt="../_images/fft-python2.png" class="align-center" src="../_images/fft-python2.png" style="width: 526.4px; height: 465.6px;" /></a>
<p>Momenteel hebben we de plot nog geen x-as gegeven, het is gewoon de index van de array (tellen vanaf 0). Door wiskundige redenen heeft de uitgang van de FFT deze vorm:</p>
<a class="reference external image-reference" href="../_images/fft-python3.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fft-python3.svg" class="align-center" src="../_images/fft-python3.svg" /></a>
<p>Maar we willen 0 Hz (DC) in het midden hebben, en de negatieve frequenties daar links van (zo willen we dat gewoon zien).
Dus telkens wanneer we een FFT uitvoeren, moeten we ook een “FFT shift” of verschuiving doen.
Dit is simpelweg een herordening van de array, dit lijkt op een circulaire verschuiving, maar is meer een “stop dit daar en dat hier” operatie.
Het diagram hieronder laat zien wat deze FFT-shift doet:</p>
<a class="reference external image-reference" href="../_images/fft-python4.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/fft-python4.svg" class="align-center" src="../_images/fft-python4.svg" /></a>
<p>Voor ons gemak heeft Numpy een FFT-shift functie <code class="code docutils literal notranslate"><span class="pre">np.fft.fftshift()</span></code>.  Vervang de np.fft.fft() regel met:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<p>Nu moeten we nog de x-as waardes/label uitvogelen. We hebben een sample-frequentie van 1 Hz gebruikt om dingen simpel te houden. Dat betekent dat de linker kant van de frequentiedomein-plot -0.5 Hz zal zijn en de rechter kant 0.5 Hz. Als dat nu nog niet logisch klinkt, wordt dat duidelijker in het hoofdstuk over <a class="reference internal" href="sampling.html#sampling-chapter"><span class="std std-ref">IQ-sampling</span></a>.  Laten we ervan uitgaan dat onze sample-frequentie 1 Hz is en de modulus en fase tonen van de uitgang van de FFT. Hier is de volledige versie van dit Python voorbeeld:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">Fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Hz</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># aantal punten om te simuleren, en onze FFT lengte</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># want de sample-frequentie is 1 Hz</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.15</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="n">S_mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">S_fase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Fs</span><span class="o">/-</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fs</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">S_mod</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">S_fase</span><span class="p">,</span><span class="s1">&#39;.-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/fft-python5.png"><img alt="../_images/fft-python5.png" class="align-center" src="../_images/fft-python5.png" style="width: 518.4px; height: 442.40000000000003px;" /></a>
<p>We zien onze piek op 0.15 Hz, de frequentie die we gebruikten voor onze sinus. Dit betekent dat onze FFT werkt! Als we de code dat onze sinus genereert niet hadden, maar wel een lijst met samples, dan zouden we de FFT kunnen gebruiken om de frequentie te bepalen! De reden dat we ook een piek zien op -0.15 Hz is omdat we werken met een reëel signaal, niet complex. Daar gaan we later dieper op in.</p>
</div>
<div class="section" id="vensterfunctie">
<h2>Vensterfunctie<a class="headerlink" href="#vensterfunctie" title="Permalink to this headline">¶</a></h2>
<p>Wanneer we een FFT gebruiken om de frequenties in ons signaal te bepalen, gaat de FFT ervan uit dat de ingang een <em>periodiek</em> signaal bevat. Het gedraagt zich alsof het signaal dat we geven zich oneindig herhaald. Het is alsof het laatste sample verbonden is aan het eerste sample. Dit vindt zijn basis in de theorie achter de Fouriertransformatie. Het betekent ook dat we plotselinge overgangen willen voorkomen tussen het eerste en laatste sample, want plotselinge veranderingen lijken op een boel frequenties. In werkelijkheid verbindt ons laatste sample niet met het eerste. Simpel gezegd: Wanneer we een FFT uitvoeren van 100 samples met <code class="code docutils literal notranslate"><span class="pre">np.fft.fft(x)</span></code>, willen we dat <code class="code docutils literal notranslate"><span class="pre">x[0]</span></code> en <code class="code docutils literal notranslate"><span class="pre">x[99]</span></code> (bijna) gelijk zijn.</p>
<p>We kunnen aan deze cyclische eigenschap voldoen met behulp van een “venster”. Net voor de FFT vermenigvuldigen we het signaal met een vensterfunctie. Dit is een functie dat aan beide kanten naar 0 gaat. Dit zal ervoor zorgen dat het deel van het signaal zal beginnen en eindigen bij 0, en dus zal verbinden. Veel voorkomende vensterfuncties zijn Hamming, Hanning, Blackman en Kaiser. Wanneer je geen venster toepast heet het een “rechthoekig” venster want het is alsof je het vermenigvuldigt met een array vol enen. Dit is hoe diverse vensterfuncties eruitzien:</p>
<a class="reference external image-reference" href="images/windows.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/windows1.svg" class="align-center" src="../_images/windows1.svg" /></a>
<p>Een simpele benadering voor beginners is om gewoon het Hamming venster te gebruiken. Dit kun je in Python maken met <code class="code docutils literal notranslate"><span class="pre">np.hamming(N)</span></code> waarbij N het aantal elementen in de array en onze FFT-grootte is. In het bovenstaande voorbeeld zouden we het venster toepassen net voor de FFT. Achter de tweede lijn code voegen we toe:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Niet bang zijn om het verkeerde venster te kiezen. Het verschil tussen Hamming, Hanning, Blackman en Kaiser is minimaal vergeleken met werken zonder venster. Ze gaan allemaal aan beide kanten naar 0 toe en lossen het onderliggende probleem op.</p>
</div>
<div class="section" id="fft-grootte">
<h2>FFT grootte<a class="headerlink" href="#fft-grootte" title="Permalink to this headline">¶</a></h2>
<p>Het laatste om te behandelen is de FFT-grootte. Vanwege de manier waarop de FFT is geïmplementeerd is de beste lengte van de FFT altijd een macht van 2. Je kunt wel een andere lengte gebruiken, maar dat is langzamer. Veelgebruikte lengtes zijn tussen de 128 en 4096, maar het kan zeker langer zijn. In de praktijk moeten we signalen verwerken die misschien wel miljoenen of miljarden samples lang zijn, en dus moeten opbreken in vele FFT’s. Dit betekent dat we ook vele uitgangen krijgen. We kunnen al die uitgangen middelen of weergeven over de tijd (zeker wanneer het signaal verandert over de tijd). Je hoeft niet <em>elk</em> sample van een signaal in de FFT te stoppen om een goede voorstelling te krijgen van de frequentiedomein-versie van dat signaal. Je zou bijvoorbeeld een 1024 FFT kunnen uitvoeren op elke 100e3 samples in een signaal en het zal er waarschijnlijk nog steeds goed uitzien, zolang het signaal altijd aan blijft.</p>
</div>
<div class="section" id="spectrogram-waterval">
<h2>Spectrogram/Waterval<a class="headerlink" href="#spectrogram-waterval" title="Permalink to this headline">¶</a></h2>
<p>Een spectrogram is een plot dat de frequentieverandering over de tijd laat zien. Het is simpel weg een hoop FFT’s op elkaar gestapeld (verticaal als je de frequentie op de horizontale as wilt hebben). We kunnen het ook real-time laten zien, dit heet meestal een waterval. Een spectrumanalyzer is het apparaat wat dit spectrogram/waterval laat zien. Hier is een voorbeeld van een spectrogram, met de frequentie op de horizontale/x-as en tijd op de verticale/y-as. Blauw stelt de laagste energie voor, en rood de hoogste. We zien in het midden een sterke piek op DC (0 Hz) met daarom heen een variërend signaal. Blauw laat hier onze ruisvloer zien.</p>
<a class="reference internal image-reference" href="../_images/waterfall.png"><img alt="../_images/waterfall.png" class="align-center" src="../_images/waterfall.png" style="width: 463.2px; height: 297.59999999999997px;" /></a>
<p>Probeer als oefening de Python code te schrijven waarmee we zo’n spectrogram kunnen maken. Bedenk dat het slechts op elkaar gestapelde rijen van FFT’s zijn. Elke rij is 1 FFT. Zorg ervoor dat je het tijdsignaal opbreekt in delen van jouw FFT-grootte (bijv. 1024 samples per deel). Om dingen simpel te houden kun je een reëel signaal invoeren en simpelweg het negatieve deel van de frequenties weggooien voordat je het spectrogram plot. Je kunt het volgende signaal als voorbeeld gebruiken, een enkele toon met witte ruis:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">sample_rate</span> <span class="o">=</span> <span class="mf">1e6</span>

<span class="c1"># Genereer de toon met ruis</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span> <span class="c1"># tijd vector</span>
<span class="n">f</span> <span class="o">=</span> <span class="mf">50e3</span> <span class="c1"># freq van toon</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>Zo ziet het eruit in het tijddomein (de eerste 200 samples):</p>
<a class="reference external image-reference" href="../_images/spectrogram_time.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/spectrogram_time.svg" class="align-center" src="../_images/spectrogram_time.svg" /></a>
<details>
<summary>Voorbeeld spectrogram code (Probeer het eerst zelf te schrijven!)</summary><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simuleer het bovenstaande signaal, of gebruik je eigen signaal</span>

<span class="n">fft_lengte</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">aantal_rijen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">fft_lengte</span><span class="p">))</span>
<span class="n">spectrogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">aantal_rijen</span><span class="p">,</span> <span class="n">fft_lengte</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">aantal_rijen</span><span class="p">):</span>
    <span class="n">spectrogram</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">fft_lengte</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">fft_lengte</span><span class="p">])))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">spectrogram</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">[:,</span><span class="n">fft_lengte</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span> <span class="c1"># negatieve frequenties weggooien want ons signaal is reeel</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">spectrogram</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [MHz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Time [s]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Dit zou het volgende moeten opleveren, wat niet zo spannend is want er is geen tijd variërend gedrag. Als extra oefening kun je het signaal laten variëren in de tijd, bekijk bijv. of je de toon kunt laten starten en stoppen.</p>
<a class="reference external image-reference" href="../_images/spectrogram.svg" rel="noopener noreferrer" target="_blank"><img alt="../_images/spectrogram.svg" class="align-center" src="../_images/spectrogram.svg" /></a>
</details></div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Marc Lichtman.
      
    </div>

    

    
  </body>
</html>